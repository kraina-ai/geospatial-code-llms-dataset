{"1.1_prompt": "import geopandas as gpd\n\ndef mean_area(polygons: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate mean area of the polygons in a geodataframe\"\"\"", "1.1_generated": "import geopandas as gpd\n\ndef mean_area(polygons: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate mean area of the polygons in a geodataframe\"\"\"\n    return polygons.area.mean()\n\ndef mean_area_per_country(polygons: gpd.GeoDataFrame) -> dict:\n    \"\"\"Calculate mean area of the polygons in a geodataframe\"\"\"\n    return polygons.groupby('country').apply(mean_area)\n\ndef mean_area_per_country_and_year(polygons: gpd.GeoDataFrame) -> dict:\n    \"\"\"Calculate mean area of the polygons in a geodataframe\"\"\"\n    return polygons.groupby(['country', 'year']).apply(mean_area)\n\ndef mean_area_per_country_and_year_and_month(polygons: gpd.GeoDataFrame) -> dict:\n    \"\"\"Calculate mean area of the polygons in a geodataframe\"\"\"\n    return polygons.groupby(['country', 'year','month']).apply(mean_area)\n\ndef mean_area_per_country_", "1.1_sanitized": "import geopandas as gpd\n\ndef mean_area(polygons: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate mean area of the polygons in a geodataframe\"\"\"\n    return polygons.area.mean()\n", "1.2_prompt": "def mean_area(filename: str) -> float:\n    \"\"\"Calculate mean area of the polygons in a shapefile\"\"\"", "1.2_generated": "def mean_area(filename: str) -> float:\n    \"\"\"Calculate mean area of the polygons in a shapefile\"\"\"\n    with fiona.open(filename) as src:\n        return sum([feature[\"properties\"][\"area\"] for feature in src]) / len(src)\n\n\ndef mean_length(filename: str) -> float:\n    \"\"\"Calculate mean length of the polygons in a shapefile\"\"\"\n    with fiona.open(filename) as src:\n        return sum([feature[\"properties\"][\"length\"] for feature in src]) / len(src)\n\n\ndef mean_perimeter(filename: str) -> float:\n    \"\"\"Calculate mean perimeter of the polygons in a shapefile\"\"\"\n    with fiona.open(filename) as src:\n        return sum([feature[\"properties\"][\"perimeter\"] for feature in src]) / len(src)\n\n\ndef mean_width(filename: str) -> float:\n    \"\"\"Calculate mean width of the polygons in a shapefile\"\"\"\n    with fiona.open(filename) as src:\n       ", "1.2_sanitized": "def mean_area(filename: str) -> float:\n    \"\"\"Calculate mean area of the polygons in a shapefile\"\"\"\n    with fiona.open(filename) as src:\n        return sum([feature[\"properties\"][\"area\"] for feature in src]) / len(src)\n\n", "1.3_prompt": "def mean_area(filename: str) -> float:\n    \"\"\"Calculate mean area of the polygons in a geojson file\"\"\"", "1.3_generated": "def mean_area(filename: str) -> float:\n    \"\"\"Calculate mean area of the polygons in a geojson file\"\"\"\n    with open(filename) as f:\n        data = json.load(f)\n    return sum([feature[\"properties\"][\"area\"] for feature in data[\"features\"]]) / len(data[\"features\"])\n\n\ndef mean_area_by_year(filename: str) -> Dict[int, float]:\n    \"\"\"Calculate mean area of the polygons in a geojson file by year\"\"\"\n    with open(filename) as f:\n        data = json.load(f)\n    return {\n        feature[\"properties\"][\"year\"]: feature[\"properties\"][\"area\"]\n        for feature in data[\"features\"]\n    }\n\n\ndef mean_area_by_year_and_country(filename: str) -> Dict[int, Dict[str, float]]:\n    \"\"\"Calculate mean area of the polygons in a geojson file by year and country\"\"\"\n    with open(filename) as f:\n        data = json.load(f)\n    return {\n        feature[\"properties", "1.3_sanitized": "def mean_area(filename: str) -> float:\n    \"\"\"Calculate mean area of the polygons in a geojson file\"\"\"\n    with open(filename) as f:\n        data = json.load(f)\n    return sum([feature[\"properties\"][\"area\"] for feature in data[\"features\"]]) / len(data[\"features\"])\n\n", "1.4_prompt": "import geopandas as gpd\n\ndef buildings_area(building_gdf: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate mean area of the buildings in a geodataframe\"\"\"", "1.4_generated": "import geopandas as gpd\n\ndef buildings_area(building_gdf: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate mean area of the buildings in a geodataframe\"\"\"\n    return building_gdf.area.mean()\n\ndef buildings_count(building_gdf: gpd.GeoDataFrame) -> int:\n    \"\"\"Calculate number of buildings in a geodataframe\"\"\"\n    return building_gdf.shape[0]\n\ndef buildings_height(building_gdf: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate mean height of the buildings in a geodataframe\"\"\"\n    return building_gdf.height.mean()\n\ndef buildings_width(building_gdf: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate mean width of the buildings in a geodataframe\"\"\"\n    return building_gdf.width.mean()\n\ndef buildings_length(building_gdf: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate mean length of the buildings in a geodataframe\"\"\"\n    return building_gdf.length.mean", "1.4_sanitized": "import geopandas as gpd\n\ndef buildings_area(building_gdf: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate mean area of the buildings in a geodataframe\"\"\"\n    return building_gdf.area.mean()\n", "1.5_prompt": "def buildings_area(building_file: str) -> float:\n    \"\"\"Calculate mean area of the buildings in a shapefile\"\"\"", "1.5_generated": "def buildings_area(building_file: str) -> float:\n    \"\"\"Calculate mean area of the buildings in a shapefile\"\"\"\n    with fiona.open(building_file) as src:\n        return np.mean([feature[\"properties\"][\"area\"] for feature in src])\n\n\ndef buildings_height(building_file: str) -> float:\n    \"\"\"Calculate mean height of the buildings in a shapefile\"\"\"\n    with fiona.open(building_file) as src:\n        return np.mean([feature[\"properties\"][\"height\"] for feature in src])\n\n\ndef buildings_volume(building_file: str) -> float:\n    \"\"\"Calculate mean volume of the buildings in a shapefile\"\"\"\n    with fiona.open(building_file) as src:\n        return np.mean([feature[\"properties\"][\"volume\"] for feature in src])\n\n\ndef buildings_area_per_height(building_file: str) -> float:\n    \"\"\"Calculate mean area per height of the buildings in a shapefile\"\"\"\n    with fiona", "1.5_sanitized": "def buildings_area(building_file: str) -> float:\n    \"\"\"Calculate mean area of the buildings in a shapefile\"\"\"\n    with fiona.open(building_file) as src:\n        return np.mean([feature[\"properties\"][\"area\"] for feature in src])\n\n", "1.6_prompt": "def buildings_area(building_file: str) -> float:\n    \"\"\"Calculate mean area of the buildings in a geojson file\"\"\"", "1.6_generated": "def buildings_area(building_file: str) -> float:\n    \"\"\"Calculate mean area of the buildings in a geojson file\"\"\"\n    with open(building_file) as f:\n        buildings = json.load(f)\n    return mean([b['properties']['area'] for b in buildings['features']])\n\n\ndef buildings_area_ratio(building_file: str, area_file: str) -> float:\n    \"\"\"Calculate the ratio of the buildings area to the area of the area file\"\"\"\n    return buildings_area(building_file) / area_area(area_file)\n\n\ndef buildings_area_ratio_mean(building_file: str, area_file: str) -> float:\n    \"\"\"Calculate the mean of the buildings area ratio of all the buildings in a geojson file\"\"\"\n    with open(building_file) as f:\n        buildings = json.load(f)\n    return mean([b['properties']['area'] / area_area(area_file) for b in buildings['features']])\n\n", "1.6_sanitized": "def buildings_area(building_file: str) -> float:\n    \"\"\"Calculate mean area of the buildings in a geojson file\"\"\"\n    with open(building_file) as f:\n        buildings = json.load(f)\n    return mean([b['properties']['area'] for b in buildings['features']])\n\n", "2.1_prompt": "import geopandas as gpd\n\ndef mean_intersection_area(first: gpd.GeoDataFrame, second: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the mean intersection ratio of polygons. Both arguments are geodataframes.\"\"\"", "2.1_generated": "import geopandas as gpd\n\ndef mean_intersection_area(first: gpd.GeoDataFrame, second: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the mean intersection ratio of polygons. Both arguments are geodataframes.\"\"\"\n    return first.intersection(second).area.mean() / (first.area.mean() + second.area.mean())\n\ndef mean_intersection_area_df(df: pd.DataFrame, first_col: str, second_col: str) -> float:\n    \"\"\"Calculate the mean intersection ratio of polygons. Both arguments are geodataframes.\"\"\"\n    return mean_intersection_area(df[first_col], df[second_col])\n\ndef mean_intersection_area_df_list(df_list: List[pd.DataFrame], first_col: str, second_col: str) -> float:\n    \"\"\"Calculate the mean intersection ratio of polygons. Both arguments are geodataframes.\"\"\"\n    return mean_intersection_area(df_list[0][first_col], df_list[1][second_col])\n\ndef mean_intersection_area_df_list_list(df_list_", "2.1_sanitized": "import geopandas as gpd\n\ndef mean_intersection_area(first: gpd.GeoDataFrame, second: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the mean intersection ratio of polygons. Both arguments are geodataframes.\"\"\"\n    return first.intersection(second).area.mean() / (first.area.mean() + second.area.mean())\n", "2.2_prompt": "def mean_intersection_area(first_filename: str, second_filename: str) -> float:\n    \"\"\"Calculate the mean intersection ratio of polygons. Both arguments are shapefiles.\"\"\"", "2.2_generated": "def mean_intersection_area(first_filename: str, second_filename: str) -> float:\n    \"\"\"Calculate the mean intersection ratio of polygons. Both arguments are shapefiles.\"\"\"\n    first_polygons = read_shapefile(first_filename)\n    second_polygons = read_shapefile(second_filename)\n    return mean_intersection_area_of_polygons(first_polygons, second_polygons)\n\n\ndef mean_intersection_area_of_polygons(first_polygons: List[Polygon], second_polygons: List[Polygon]) -> float:\n    \"\"\"Calculate the mean intersection ratio of polygons. Both arguments are lists of polygons.\"\"\"\n    intersection_areas = []\n    for first_polygon in first_polygons:\n        for second_polygon in second_polygons:\n            intersection_area = first_polygon.intersection(second_polygon).area\n            intersection_areas.append(intersection_area)\n    return np.mean(intersection_areas)\n\n\ndef read_shapefile(filename: str) -> List[Polygon]:\n    \"\"\"Read a shapefile and return a list of", "2.2_sanitized": "def mean_intersection_area(first_filename: str, second_filename: str) -> float:\n    \"\"\"Calculate the mean intersection ratio of polygons. Both arguments are shapefiles.\"\"\"\n    first_polygons = read_shapefile(first_filename)\n    second_polygons = read_shapefile(second_filename)\n    return mean_intersection_area_of_polygons(first_polygons, second_polygons)\n\n", "2.3_prompt": "def mean_intersection_area(first_filename: str, second_filename: str) -> float:\n    \"\"\"Calculate the mean intersection ratio of polygons. Both arguments are geojson files.\"\"\"", "2.3_generated": "def mean_intersection_area(first_filename: str, second_filename: str) -> float:\n    \"\"\"Calculate the mean intersection ratio of polygons. Both arguments are geojson files.\"\"\"\n    first_polygons = get_polygons(first_filename)\n    second_polygons = get_polygons(second_filename)\n    return mean_intersection_area_of_polygons(first_polygons, second_polygons)\n\n\ndef mean_intersection_area_of_polygons(first_polygons: List[Polygon], second_polygons: List[Polygon]) -> float:\n    \"\"\"Calculate the mean intersection ratio of polygons.\"\"\"\n    intersection_areas = []\n    for first_polygon in first_polygons:\n        for second_polygon in second_polygons:\n            intersection_area = first_polygon.intersection(second_polygon).area\n            intersection_areas.append(intersection_area)\n    return sum(intersection_areas) / len(intersection_areas)\n\n\ndef get_polygons(filename: str) -> List[Polygon]:\n    \"\"\"Get polygons from geojson file.\"\"\"\n    with open(", "2.3_sanitized": "def mean_intersection_area(first_filename: str, second_filename: str) -> float:\n    \"\"\"Calculate the mean intersection ratio of polygons. Both arguments are geojson files.\"\"\"\n    first_polygons = get_polygons(first_filename)\n    second_polygons = get_polygons(second_filename)\n    return mean_intersection_area_of_polygons(first_polygons, second_polygons)\n\n", "2.4_prompt": "import geopandas as gpd\n\ndef building_to_parcel_ratio(buildings_gdf: gpd.GeoDataFrame, parcels_gdf: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the mean ratio of the buliding area compared to the parcel it stands on. Buildings and parcels are in separate geodataframes.\"\"\"", "2.4_generated": "import geopandas as gpd\n\ndef building_to_parcel_ratio(buildings_gdf: gpd.GeoDataFrame, parcels_gdf: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the mean ratio of the buliding area compared to the parcel it stands on. Buildings and parcels are in separate geodataframes.\"\"\"\n    # Calculate the area of the buildings\n    buildings_gdf['area'] = buildings_gdf.area\n    # Calculate the area of the parcels\n    parcels_gdf['area'] = parcels_gdf.area\n    # Join the buildings and parcels\n    joined_gdf = gpd.sjoin(buildings_gdf, parcels_gdf, how='left', op='within')\n    # Calculate the ratio of the building area to the parcel area\n    joined_gdf['ratio'] = joined_gdf.area / joined_gdf.area_right\n    # Calculate the mean ratio\n    mean_ratio = joined_gdf.ratio.mean()\n    return mean_ratio\n\n# Calculate the mean ratio of the building area compared to the parcel it stands on\nmean_ratio = building_to_parcel_ratio(buildings_gdf, parcels_gdf)\nprint", "2.4_sanitized": "import geopandas as gpd\n\ndef building_to_parcel_ratio(buildings_gdf: gpd.GeoDataFrame, parcels_gdf: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the mean ratio of the buliding area compared to the parcel it stands on. Buildings and parcels are in separate geodataframes.\"\"\"\n    # Calculate the area of the buildings\n    buildings_gdf['area'] = buildings_gdf.area\n    # Calculate the area of the parcels\n    parcels_gdf['area'] = parcels_gdf.area\n    # Join the buildings and parcels\n    joined_gdf = gpd.sjoin(buildings_gdf, parcels_gdf, how='left', op='within')\n    # Calculate the ratio of the building area to the parcel area\n    joined_gdf['ratio'] = joined_gdf.area / joined_gdf.area_right\n    # Calculate the mean ratio\n    mean_ratio = joined_gdf.ratio.mean()", "2.5_prompt": "def building_to_parcel_ratio(buildings_file: str, parcels_file: str) -> float:\n    \"\"\"Calculate the mean ratio of the buliding area compared to the parcel it stands on. Buildings and parcels are in separate shapefiles.\"\"\"", "2.5_generated": "def building_to_parcel_ratio(buildings_file: str, parcels_file: str) -> float:\n    \"\"\"Calculate the mean ratio of the buliding area compared to the parcel it stands on. Buildings and parcels are in separate shapefiles.\"\"\"\n    buildings = gpd.read_file(buildings_file)\n    parcels = gpd.read_file(parcels_file)\n\n    # Calculate the area of the buildings\n    buildings['area'] = buildings.geometry.area\n\n    # Calculate the area of the parcels\n    parcels['area'] = parcels.geometry.area\n\n    # Calculate the area of the buildings that are in the parcels\n    buildings_in_parcels = gpd.sjoin(buildings, parcels, how='inner', op='within')\n    buildings_in_parcels = buildings_in_parcels.groupby('index_right').sum()\n\n    # Calculate the ratio of the area of the buildings in the parcels compared to the area of the parcels\n    ratio = buildings_in_parcels.area / parcels.area\n\n    # Return the mean ratio\n    return ratio.mean()\n\n\n", "2.5_sanitized": "def building_to_parcel_ratio(buildings_file: str, parcels_file: str) -> float:\n    \"\"\"Calculate the mean ratio of the buliding area compared to the parcel it stands on. Buildings and parcels are in separate shapefiles.\"\"\"\n    buildings = gpd.read_file(buildings_file)\n    parcels = gpd.read_file(parcels_file)\n\n    # Calculate the area of the buildings\n    buildings['area'] = buildings.geometry.area\n\n    # Calculate the area of the parcels\n    parcels['area'] = parcels.geometry.area\n\n    # Calculate the area of the buildings that are in the parcels\n    buildings_in_parcels = gpd.sjoin(buildings, parcels, how='inner', op='within')\n    buildings_in_parcels = buildings_in_parcels.groupby('index_right').sum()\n\n    # Calculate the ratio of the area of the buildings in the parcels compared to the area of the parcels\n    ratio = buildings_in_parcels.area / parcels.area\n\n    # Return the mean ratio", "2.6_prompt": "def building_to_parcel_ratio(buildings_file: str, parcels_file: str) -> float:\n    \"\"\"Calculate the mean ratio of the buliding area compared to the parcel it stands on. Buildings and parcels are in separate geojson files.\"\"\"", "2.6_generated": "def building_to_parcel_ratio(buildings_file: str, parcels_file: str) -> float:\n    \"\"\"Calculate the mean ratio of the buliding area compared to the parcel it stands on. Buildings and parcels are in separate geojson files.\"\"\"\n    buildings = gpd.read_file(buildings_file)\n    parcels = gpd.read_file(parcels_file)\n    buildings_parcels = gpd.sjoin(buildings, parcels, how=\"inner\", op=\"within\")\n    buildings_parcels = buildings_parcels.drop(columns=[\"index_right\"])\n    buildings_parcels = buildings_parcels.drop(columns=[\"geometry\"])\n    buildings_parcels = buildings_parcels.drop(columns=[\"parcel_id\"])\n    buildings_parcels = buildings_parcels.drop(columns=[\"parcel_id_1\"])\n    buildings_parcels = buildings_parcels.drop(columns=[\"parcel_id_2\"])\n    buildings_parcels = buildings_parcels.drop(columns=[\"parcel_id_3\"])\n    buildings_parcels = buildings_parcel", "2.6_sanitized": "", "3.1_prompt": "import geopandas as gpd\n\ndef points_in_polygons(points_gdf: gpd.GeoDataFrame, polygons_gdf: gpd.GeoDataFrame) -> int:\n    \"\"\"Calculate the number of points that are inside polygons. Points and polygons are stored in GeoDataFrames.\"\"\"", "3.1_generated": "import geopandas as gpd\n\ndef points_in_polygons(points_gdf: gpd.GeoDataFrame, polygons_gdf: gpd.GeoDataFrame) -> int:\n    \"\"\"Calculate the number of points that are inside polygons. Points and polygons are stored in GeoDataFrames.\"\"\"\n    # Create a GeoDataFrame with points and polygons\n    points_polygons_gdf = gpd.GeoDataFrame(\n        pd.concat([points_gdf, polygons_gdf], axis=1),\n        geometry=gpd.points_from_xy(points_gdf.x, points_gdf.y),\n    )\n\n    # Calculate the number of points that are inside polygons\n    points_in_polygons = points_polygons_gdf.within(polygons_gdf.geometry).sum()\n\n    return points_in_polygons\n\ndef points_in_polygons_parallel(points_gdf: gpd.GeoDataFrame, polygons_gdf: gpd.GeoDataFrame) -> int:\n    \"\"\"Calculate the number of points that are inside polygons. Points and polygons are stored in GeoDataFrames.\n    This function uses parallel processing to speed up the calculation.\n    \"\"\"\n    #", "3.1_sanitized": "import geopandas as gpd\n\ndef points_in_polygons(points_gdf: gpd.GeoDataFrame, polygons_gdf: gpd.GeoDataFrame) -> int:\n    \"\"\"Calculate the number of points that are inside polygons. Points and polygons are stored in GeoDataFrames.\"\"\"\n    # Create a GeoDataFrame with points and polygons\n    points_polygons_gdf = gpd.GeoDataFrame(\n        pd.concat([points_gdf, polygons_gdf], axis=1),\n        geometry=gpd.points_from_xy(points_gdf.x, points_gdf.y),\n    )\n\n    # Calculate the number of points that are inside polygons\n    points_in_polygons = points_polygons_gdf.within(polygons_gdf.geometry).sum()\n\n    return points_in_polygons\n", "3.2_prompt": "def points_in_polygons(points: str, polygons: str) -> int:\n    \"\"\"Calculate the number of points that are inside polygons. Points and polygons are stored in shapefiles.\"\"\"", "3.2_generated": "def points_in_polygons(points: str, polygons: str) -> int:\n    \"\"\"Calculate the number of points that are inside polygons. Points and polygons are stored in shapefiles.\"\"\"\n    # Load points and polygons\n    points_layer = fiona.open(points)\n    polygons_layer = fiona.open(polygons)\n\n    # Create a set of points\n    points_set = set()\n    for point in points_layer:\n        points_set.add(tuple(point[\"geometry\"][\"coordinates\"]))\n\n    # Create a set of polygons\n    polygons_set = set()\n    for polygon in polygons_layer:\n        polygons_set.add(tuple(polygon[\"geometry\"][\"coordinates\"]))\n\n    # Calculate the number of points that are inside polygons\n    points_in_polygons = 0\n    for point in points_set:\n        if point in polygons_set:\n            points_in_polygons += 1\n\n    return points_in_polygons\n\n\nif __name__ == \"__main__\":\n    # Parse command line arguments\n    parser = argparse.ArgumentParser(description=\"Calculate the number of points", "3.2_sanitized": "def points_in_polygons(points: str, polygons: str) -> int:\n    \"\"\"Calculate the number of points that are inside polygons. Points and polygons are stored in shapefiles.\"\"\"\n    # Load points and polygons\n    points_layer = fiona.open(points)\n    polygons_layer = fiona.open(polygons)\n\n    # Create a set of points\n    points_set = set()\n    for point in points_layer:\n        points_set.add(tuple(point[\"geometry\"][\"coordinates\"]))\n\n    # Create a set of polygons\n    polygons_set = set()\n    for polygon in polygons_layer:\n        polygons_set.add(tuple(polygon[\"geometry\"][\"coordinates\"]))\n\n    # Calculate the number of points that are inside polygons\n    points_in_polygons = 0\n    for point in points_set:\n        if point in polygons_set:\n            points_in_polygons += 1\n", "3.3_prompt": "def points_in_polygons(points: str, polygons: str) -> int:\n    \"\"\"Calculate the number of points that are inside polygons. Points and polygons are stored in geojson files.\"\"\"", "3.3_generated": "def points_in_polygons(points: str, polygons: str) -> int:\n    \"\"\"Calculate the number of points that are inside polygons. Points and polygons are stored in geojson files.\"\"\"\n    points_gdf = gpd.read_file(points)\n    polygons_gdf = gpd.read_file(polygons)\n    return points_gdf.within(polygons_gdf).sum()\n\n\ndef points_in_polygons_parallel(points: str, polygons: str) -> int:\n    \"\"\"Calculate the number of points that are inside polygons. Points and polygons are stored in geojson files.\n    This function uses multiprocessing to speed up the process.\n    \"\"\"\n    points_gdf = gpd.read_file(points)\n    polygons_gdf = gpd.read_file(polygons)\n    with multiprocessing.Pool() as pool:\n        return sum(pool.map(lambda point: point.within(polygons_gdf), points_gdf))\n\n\ndef main():\n    \"\"\"Main function.\"\"\"\n    parser = argparse.ArgumentParser(description=\"Calculate the number of", "3.3_sanitized": "def points_in_polygons(points: str, polygons: str) -> int:\n    \"\"\"Calculate the number of points that are inside polygons. Points and polygons are stored in geojson files.\"\"\"\n    points_gdf = gpd.read_file(points)\n    polygons_gdf = gpd.read_file(polygons)\n    return points_gdf.within(polygons_gdf).sum()\n\n", "3.4_prompt": "import geopandas as gpd\ndef mean_stations_count(bus_stops: gpd.GeoDataFrames, districts: gpd.GeoDataFrames) -> float:\n    \"\"\"Calculate the mean number of bus stops in a districs. Stations and districts are stored in GeoDataFrames.\"\"\"", "3.4_generated": "import geopandas as gpd\ndef mean_stations_count(bus_stops: gpd.GeoDataFrames, districts: gpd.GeoDataFrames) -> float:\n    \"\"\"Calculate the mean number of bus stops in a districs. Stations and districts are stored in GeoDataFrames.\"\"\"\n    # Calculate the number of bus stops in each district\n    stations_per_district = bus_stops.groupby(bus_stops.within(districts.geometry)).size()\n    # Calculate the mean number of bus stops in each district\n    return stations_per_district.mean()\n\ndef mean_stations_count_by_district(bus_stops: gpd.GeoDataFrames, districts: gpd.GeoDataFrames) -> float:\n    \"\"\"Calculate the mean number of bus stops in a districs. Stations and districts are stored in GeoDataFrames.\"\"\"\n    # Calculate the number of bus stops in each district\n    stations_per_district = bus_stops.groupby(bus_stops.within(districts.geometry)).size()\n    # Calculate the mean number of bus stops in each district\n    return stations_per_district.mean()\n\ndef mean_stations_count_by_district(bus_stops: g", "3.4_sanitized": "import geopandas as gpd\ndef mean_stations_count(bus_stops: gpd.GeoDataFrames, districts: gpd.GeoDataFrames) -> float:\n    \"\"\"Calculate the mean number of bus stops in a districs. Stations and districts are stored in GeoDataFrames.\"\"\"\n    # Calculate the number of bus stops in each district\n    stations_per_district = bus_stops.groupby(bus_stops.within(districts.geometry)).size()\n    # Calculate the mean number of bus stops in each district\n    return stations_per_district.mean()\n", "3.5_prompt": "def mean_stations_count(bus_stops: str, districts: str) -> float:\n    \"\"\"Calculate the mean number of bus stops in a districs. Stations and districts are stored in shapefiles.\"\"\"", "3.5_generated": "def mean_stations_count(bus_stops: str, districts: str) -> float:\n    \"\"\"Calculate the mean number of bus stops in a districs. Stations and districts are stored in shapefiles.\"\"\"\n    # Load the shapefiles\n    bus_stops_gdf = gpd.read_file(bus_stops)\n    districts_gdf = gpd.read_file(districts)\n\n    # Calculate the number of bus stops in each district\n    bus_stops_count = bus_stops_gdf.groupby(bus_stops_gdf.index).size()\n    bus_stops_count = bus_stops_count.to_frame(name=\"bus_stops_count\")\n\n    # Join the bus stops count to the districts shapefile\n    bus_stops_count_gdf = districts_gdf.merge(bus_stops_count, left_index=True, right_index=True)\n\n    # Calculate the mean number of bus stops in each district\n    mean_stations_count = bus_stops_count_gdf.bus_stops_count.mean()\n\n    return mean_stations_count\n\n\ndef", "3.5_sanitized": "def mean_stations_count(bus_stops: str, districts: str) -> float:\n    \"\"\"Calculate the mean number of bus stops in a districs. Stations and districts are stored in shapefiles.\"\"\"\n    # Load the shapefiles\n    bus_stops_gdf = gpd.read_file(bus_stops)\n    districts_gdf = gpd.read_file(districts)\n\n    # Calculate the number of bus stops in each district\n    bus_stops_count = bus_stops_gdf.groupby(bus_stops_gdf.index).size()\n    bus_stops_count = bus_stops_count.to_frame(name=\"bus_stops_count\")\n\n    # Join the bus stops count to the districts shapefile\n    bus_stops_count_gdf = districts_gdf.merge(bus_stops_count, left_index=True, right_index=True)\n\n    # Calculate the mean number of bus stops in each district\n    mean_stations_count = bus_stops_count_gdf.bus_stops_count.mean()\n", "3.6_prompt": "def mean_stations_count(bus_stops: str, districts: str) -> float:\n    \"\"\"Calculate the mean number of bus stops in a districs. Stations and districts are stored in geojson files.\"\"\"", "3.6_generated": "def mean_stations_count(bus_stops: str, districts: str) -> float:\n    \"\"\"Calculate the mean number of bus stops in a districs. Stations and districts are stored in geojson files.\"\"\"\n    stations_count = []\n    with open(bus_stops, 'r') as f:\n        stations = json.load(f)\n        for station in stations['features']:\n            stations_count.append(station['properties']['count'])\n    with open(districts, 'r') as f:\n        districts = json.load(f)\n        for district in districts['features']:\n            district_stations = 0\n            for station in stations['features']:\n                if station['properties']['district'] == district['properties']['name']:\n                    district_stations += station['properties']['count']\n            district['properties']['stations_count'] = district_stations\n    return np.mean(stations_count)\n\n\ndef mean_stations_count_by_district(bus_stops: str, districts: str) -> float:\n    \"\"\"Calculate the mean number of bus stops in a districs. Stations and districts are stored in geojson files.\"\"\"", "3.6_sanitized": "def mean_stations_count(bus_stops: str, districts: str) -> float:\n    \"\"\"Calculate the mean number of bus stops in a districs. Stations and districts are stored in geojson files.\"\"\"\n    stations_count = []\n    with open(bus_stops, 'r') as f:\n        stations = json.load(f)\n        for station in stations['features']:\n            stations_count.append(station['properties']['count'])\n    with open(districts, 'r') as f:\n        districts = json.load(f)\n        for district in districts['features']:\n            district_stations = 0\n            for station in stations['features']:\n                if station['properties']['district'] == district['properties']['name']:\n                    district_stations += station['properties']['count']\n            district['properties']['stations_count'] = district_stations\n    return np.mean(stations_count)\n\n", "4.1_prompt": "import geopandas as gpd\n\ndef is_point_present(x: float, y: float, points: gpd.GeoDataFrame) -> bool:\n    \"\"\"Check if a point is present in a list of points stored in a geojson file.\"\"\"", "4.1_generated": "import geopandas as gpd\n\ndef is_point_present(x: float, y: float, points: gpd.GeoDataFrame) -> bool:\n    \"\"\"Check if a point is present in a list of points stored in a geojson file.\"\"\"\n    return points.contains(gpd.GeoSeries(gpd.GeoDataFrame({'geometry': gpd.GeoSeries(gpd.points_from_xy([x, y]))}))).any()\n\ndef is_point_present_in_polygon(x: float, y: float, polygon: gpd.GeoDataFrame) -> bool:\n    \"\"\"Check if a point is present in a polygon stored in a geojson file.\"\"\"\n    return polygon.contains(gpd.GeoSeries(gpd.GeoDataFrame({'geometry': gpd.GeoSeries(gpd.points_from_xy([x, y]))}))).any()\n\ndef is_point_present_in_polygons(x: float, y: float, polygons: gpd.GeoDataFrame) -> bool:\n    \"\"\"Check if a point is present in a list of polygons stored in a geojson file.\"\"\"\n    return polygons.contains(gpd", "4.1_sanitized": "import geopandas as gpd\n\ndef is_point_present(x: float, y: float, points: gpd.GeoDataFrame) -> bool:\n    \"\"\"Check if a point is present in a list of points stored in a geojson file.\"\"\"\n    return points.contains(gpd.GeoSeries(gpd.GeoDataFrame({'geometry': gpd.GeoSeries(gpd.points_from_xy([x, y]))}))).any()\n", "4.2_prompt": "import geopandas as gpd\n\ndef is_point_present(x: float, y: float, filename: str) -> bool:\n    \"\"\"Check if a point is present in a list of points stored in a shapefile.\"\"\"", "4.2_generated": "import geopandas as gpd\n\ndef is_point_present(x: float, y: float, filename: str) -> bool:\n    \"\"\"Check if a point is present in a list of points stored in a shapefile.\"\"\"\n    gdf = gpd.read_file(filename)\n    return gdf.contains(shapely.geometry.Point(x, y)).any()\n\ndef is_point_present_in_shapefile(x: float, y: float, filename: str) -> bool:\n    \"\"\"Check if a point is present in a list of points stored in a shapefile.\"\"\"\n    gdf = gpd.read_file(filename)\n    return gdf.contains(shapely.geometry.Point(x, y)).any()\n\ndef is_point_present_in_shapefile_with_buffer(x: float, y: float, filename: str, buffer_size: float) -> bool:\n    \"\"\"Check if a point is present in a list of points stored in a shapefile.\"\"\"\n    gdf = gpd.read_file(filename)\n    gdf['geometry'] = gdf.buffer(buffer", "4.2_sanitized": "import geopandas as gpd\n\ndef is_point_present(x: float, y: float, filename: str) -> bool:\n    \"\"\"Check if a point is present in a list of points stored in a shapefile.\"\"\"\n    gdf = gpd.read_file(filename)\n    return gdf.contains(shapely.geometry.Point(x, y)).any()\n", "4.3_prompt": "import geopandas as gpd\n\ndef is_point_present(x: float, y: float, filename: str) -> bool:\n    \"\"\"Check if a point is present in a list of points stored in a geojson file.\"\"\"", "4.3_generated": "import geopandas as gpd\n\ndef is_point_present(x: float, y: float, filename: str) -> bool:\n    \"\"\"Check if a point is present in a list of points stored in a geojson file.\"\"\"\n    with open(filename) as f:\n        data = json.load(f)\n    for feature in data['features']:\n        if feature['geometry']['type'] == 'Point':\n            if feature['geometry']['coordinates'][0] == x and feature['geometry']['coordinates'][1] == y:\n                return True\n    return False\n\ndef get_points_from_geojson(filename: str) -> List[Tuple[float, float]]:\n    \"\"\"Get a list of points from a geojson file.\"\"\"\n    with open(filename) as f:\n        data = json.load(f)\n    points = []\n    for feature in data['features']:\n        if feature['geometry']['type'] == 'Point':\n            points.append((feature['geometry']['coordinates'][0], feature['geometry']['coordinates'][1]))\n    return points\n\ndef get_points_from_shapefile(filename: str) -> List[Tuple[float, float]]:\n    \"\"\"Get a", "4.3_sanitized": "import geopandas as gpd\n\ndef is_point_present(x: float, y: float, filename: str) -> bool:\n    \"\"\"Check if a point is present in a list of points stored in a geojson file.\"\"\"\n    with open(filename) as f:\n        data = json.load(f)\n    for feature in data['features']:\n        if feature['geometry']['type'] == 'Point':\n            if feature['geometry']['coordinates'][0] == x and feature['geometry']['coordinates'][1] == y:\n                return True\n    return False\n", "4.4_prompt": "import geopandas as gpd\n\ndef is_station(lat: float, lon: float, stations: gpd.GeoDataFrame) -> bool:\n    \"\"\"Check if given coordinates represent a bus station stored in a geodataframe.\"\"\"", "4.4_generated": "import geopandas as gpd\n\ndef is_station(lat: float, lon: float, stations: gpd.GeoDataFrame) -> bool:\n    \"\"\"Check if given coordinates represent a bus station stored in a geodataframe.\"\"\"\n    return stations.contains(gpd.points_from_xy([lon, lat])).any()\n\ndef is_station_id(station_id: str, stations: gpd.GeoDataFrame) -> bool:\n    \"\"\"Check if given station id is stored in a geodataframe.\"\"\"\n    return station_id in stations.index.values\n\ndef get_station_id(lat: float, lon: float, stations: gpd.GeoDataFrame) -> str:\n    \"\"\"Get the station id for a given coordinate.\"\"\"\n    return stations.loc[stations.contains(gpd.points_from_xy([lon, lat]))].index.values[0]\n\ndef get_station_id_from_name(station_name: str, stations: gpd.GeoDataFrame) -> str:\n    \"\"\"Get the station id for a given station name.\"\"\"\n    return stations.loc[stations.name == station_name].index.", "4.4_sanitized": "import geopandas as gpd\n\ndef is_station(lat: float, lon: float, stations: gpd.GeoDataFrame) -> bool:\n    \"\"\"Check if given coordinates represent a bus station stored in a geodataframe.\"\"\"\n    return stations.contains(gpd.points_from_xy([lon, lat])).any()\n", "4.5_prompt": "import geopandas as gpd\n\ndef is_station(lat: float, lon: float, stations: str) -> bool:\n    \"\"\"Check if given coordinates represent a bus station stored in a shapefile.\"\"\"", "4.5_generated": "import geopandas as gpd\n\ndef is_station(lat: float, lon: float, stations: str) -> bool:\n    \"\"\"Check if given coordinates represent a bus station stored in a shapefile.\"\"\"\n    stations = gpd.read_file(stations)\n    return stations.contains(shapely.geometry.Point(lon, lat)).any()\n\ndef is_station_by_name(name: str, stations: str) -> bool:\n    \"\"\"Check if given station name is stored in a shapefile.\"\"\"\n    stations = gpd.read_file(stations)\n    return stations.name.str.contains(name).any()\n\ndef get_station_by_name(name: str, stations: str) -> dict:\n    \"\"\"Get a station by its name.\"\"\"\n    stations = gpd.read_file(stations)\n    return stations[stations.name.str.contains(name)].to_dict(orient='records')[0]\n\ndef get_station_by_id(id: int, stations: str) -> dict:\n    \"\"\"Get a station by its id.\"\"\"\n    stations = gpd.read_", "4.5_sanitized": "import geopandas as gpd\n\ndef is_station(lat: float, lon: float, stations: str) -> bool:\n    \"\"\"Check if given coordinates represent a bus station stored in a shapefile.\"\"\"\n    stations = gpd.read_file(stations)\n    return stations.contains(shapely.geometry.Point(lon, lat)).any()\n", "4.6_prompt": "import geopandas as gpd\n\ndef is_station(lat: float, lon: float, stations: str) -> bool:\n    \"\"\"Check if given coordinates represent a bus station stored in a geojson file.\"\"\"", "4.6_generated": "import geopandas as gpd\n\ndef is_station(lat: float, lon: float, stations: str) -> bool:\n    \"\"\"Check if given coordinates represent a bus station stored in a geojson file.\"\"\"\n    stations = gpd.read_file(stations)\n    return stations.contains(shapely.geometry.Point(lon, lat)).any()\n\ndef is_station_v2(lat: float, lon: float, stations: str) -> bool:\n    \"\"\"Check if given coordinates represent a bus station stored in a geojson file.\"\"\"\n    stations = gpd.read_file(stations)\n    return stations.contains(shapely.geometry.Point(lon, lat)).any()\n\ndef is_station_v3(lat: float, lon: float, stations: str) -> bool:\n    \"\"\"Check if given coordinates represent a bus station stored in a geojson file.\"\"\"\n    stations = gpd.read_file(stations)\n    return stations.contains(shapely.geometry.Point(lon, lat)).any()\n\ndef is_station_v4(lat: float, lon: float, stations:", "4.6_sanitized": "import geopandas as gpd\n\ndef is_station(lat: float, lon: float, stations: str) -> bool:\n    \"\"\"Check if given coordinates represent a bus station stored in a geojson file.\"\"\"\n    stations = gpd.read_file(stations)\n    return stations.contains(shapely.geometry.Point(lon, lat)).any()\n", "5_prompt": "import shapely\n\ndef construct_point(x: float, y: float) -> shapely.geometry.Point:\n    \"\"\"Construct a point from x and y coordinates.\"\"\"", "5_generated": "import shapely\n\ndef construct_point(x: float, y: float) -> shapely.geometry.Point:\n    \"\"\"Construct a point from x and y coordinates.\"\"\"\n    return shapely.geometry.Point(x, y)\n\ndef construct_line(x1: float, y1: float, x2: float, y2: float) -> shapely.geometry.LineString:\n    \"\"\"Construct a line from two points.\"\"\"\n    return shapely.geometry.LineString([(x1, y1), (x2, y2)])\n\ndef construct_polygon(x1: float, y1: float, x2: float, y2: float, x3: float, y3: float, x4: float, y4: float) -> shapely.geometry.Polygon:\n    \"\"\"Construct a polygon from four points.\"\"\"\n    return shapely.geometry.Polygon([(x1, y1), (x2, y2), (x3, y3), (x4, y4)])\n\ndef construct_multipoint(x1: float, y", "5_sanitized": "import shapely\n\ndef construct_point(x: float, y: float) -> shapely.geometry.Point:\n    \"\"\"Construct a point from x and y coordinates.\"\"\"\n    return shapely.geometry.Point(x, y)\n", "6.1_prompt": "import shapely\n\ndef is_point_within_polygon(point: shapely.geometry.Point, polygon: shapely.geometry.Polygon) -> bool:\n    \"\"\"Check if a given point lies within a polygon.\"\"\"", "6.1_generated": "import shapely\n\ndef is_point_within_polygon(point: shapely.geometry.Point, polygon: shapely.geometry.Polygon) -> bool:\n    \"\"\"Check if a given point lies within a polygon.\"\"\"\n    return polygon.contains(point)\n\ndef is_point_within_multipolygon(point: shapely.geometry.Point, multipolygon: shapely.geometry.MultiPolygon) -> bool:\n    \"\"\"Check if a given point lies within a multipolygon.\"\"\"\n    return multipolygon.contains(point)\n\ndef is_point_within_multipolygon_or_polygon(point: shapely.geometry.Point, multipolygon_or_polygon: shapely.geometry.MultiPolygon | shapely.geometry.Polygon) -> bool:\n    \"\"\"Check if a given point lies within a multipolygon or a polygon.\"\"\"\n    return multipolygon_or_polygon.contains(point)\n\ndef is_point_within_multipolygon_or_polygon_or_point(point: shapely.geometry.Point, multipolygon_or_polygon_or_point:", "6.1_sanitized": "import shapely\n\ndef is_point_within_polygon(point: shapely.geometry.Point, polygon: shapely.geometry.Polygon) -> bool:\n    \"\"\"Check if a given point lies within a polygon.\"\"\"\n    return polygon.contains(point)\n", "6.2_prompt": "import shapely\n\ndef is_in_the_city(place: shapely.geometry.Point, city: shapely.geometry.Polygon) -> bool:\n    \"\"\"Check if a given place lies inside the city boundaries.\"\"\"", "6.2_generated": "import shapely\n\ndef is_in_the_city(place: shapely.geometry.Point, city: shapely.geometry.Polygon) -> bool:\n    \"\"\"Check if a given place lies inside the city boundaries.\"\"\"\n    return city.contains(place)\n\ndef is_in_the_city_or_nearby(place: shapely.geometry.Point, city: shapely.geometry.Polygon, distance: float) -> bool:\n    \"\"\"Check if a given place lies inside the city boundaries or is within a given distance from the city.\"\"\"\n    return city.buffer(distance).contains(place)\n\ndef is_in_the_city_or_nearby_or_on_the_border(place: shapely.geometry.Point, city: shapely.geometry.Polygon, distance: float) -> bool:\n    \"\"\"Check if a given place lies inside the city boundaries or is within a given distance from the city or is on the city border.\"\"\"\n    return city.buffer(distance).contains(place) or city.boundary.contains(place)\n\ndef is_in_the_city_or_nearby", "6.2_sanitized": "import shapely\n\ndef is_in_the_city(place: shapely.geometry.Point, city: shapely.geometry.Polygon) -> bool:\n    \"\"\"Check if a given place lies inside the city boundaries.\"\"\"\n    return city.contains(place)\n", "7.1_prompt": "import shapely\n\ndef are_polygons_adjacent(polygon1: shapely.geometry.Polygon, polygon2: shapely.geometry.Polygon) -> bool:\n    \"\"\"Check if two polygons are adjacent.\"\"\"", "7.1_generated": "import shapely\n\ndef are_polygons_adjacent(polygon1: shapely.geometry.Polygon, polygon2: shapely.geometry.Polygon) -> bool:\n    \"\"\"Check if two polygons are adjacent.\"\"\"\n    return polygon1.intersects(polygon2) and polygon1.touches(polygon2)\n\ndef get_adjacent_polygons(polygons: List[shapely.geometry.Polygon]) -> List[Tuple[int, int]]:\n    \"\"\"Get adjacent polygons.\"\"\"\n    adjacent_polygons = []\n    for i, polygon1 in enumerate(polygons):\n        for j, polygon2 in enumerate(polygons):\n            if i == j:\n                continue\n            if are_polygons_adjacent(polygon1, polygon2):\n                adjacent_polygons.append((i, j))\n    return adjacent_polygons\n\ndef get_adjacent_polygons_from_file(filename: str) -> List[Tuple[int, int]]:\n    \"\"\"Get adjacent polygons from file.\"\"\"\n    polygons = []\n    with open(filename, 'r') as f:\n        for line in f:\n            polygons.append(shapely", "7.1_sanitized": "import shapely\n\ndef are_polygons_adjacent(polygon1: shapely.geometry.Polygon, polygon2: shapely.geometry.Polygon) -> bool:\n    \"\"\"Check if two polygons are adjacent.\"\"\"\n    return polygon1.intersects(polygon2) and polygon1.touches(polygon2)\n", "7.2_prompt": "import shapely\n\ndef are_countries_neighbours(country1: shapely.geometry.Polygon, country2: shapely.geometry.Polygon) -> bool:\n    \"\"\"Check if two polygons are adjacent.\"\"\"", "7.2_generated": "import shapely\n\ndef are_countries_neighbours(country1: shapely.geometry.Polygon, country2: shapely.geometry.Polygon) -> bool:\n    \"\"\"Check if two polygons are adjacent.\"\"\"\n    return country1.intersects(country2)\n\ndef get_neighbours(country: shapely.geometry.Polygon, countries: List[shapely.geometry.Polygon]) -> List[shapely.geometry.Polygon]:\n    \"\"\"Get all neighbours of a country.\"\"\"\n    return [country for country in countries if are_countries_neighbours(country, country)]\n\ndef get_neighbours_of_neighbours(country: shapely.geometry.Polygon, countries: List[shapely.geometry.Polygon]) -> List[shapely.geometry.Polygon]:\n    \"\"\"Get all neighbours of neighbours of a country.\"\"\"\n    neighbours = get_neighbours(country, countries)\n    return [neighbour for neighbour in neighbours if get_neighbours(neighbour, countries)]\n\ndef get_countries_with_neighbours(countries: List[shapely.geometry.Polygon]) ->", "7.2_sanitized": "import shapely\n\ndef are_countries_neighbours(country1: shapely.geometry.Polygon, country2: shapely.geometry.Polygon) -> bool:\n    \"\"\"Check if two polygons are adjacent.\"\"\"\n    return country1.intersects(country2)\n", "8.1_prompt": "import shapely\n\ndef polygons_intersection(polygon1: shapely.geometry.Polygon, polygon2: shapely.geometry.Polygon) -> float:\n    \"\"\"Calculate the area of two polygons intersection.\"\"\"", "8.1_generated": "import shapely\n\ndef polygons_intersection(polygon1: shapely.geometry.Polygon, polygon2: shapely.geometry.Polygon) -> float:\n    \"\"\"Calculate the area of two polygons intersection.\"\"\"\n    return polygon1.intersection(polygon2).area\n\ndef polygons_union(polygon1: shapely.geometry.Polygon, polygon2: shapely.geometry.Polygon) -> float:\n    \"\"\"Calculate the area of two polygons union.\"\"\"\n    return polygon1.union(polygon2).area\n\ndef polygons_difference(polygon1: shapely.geometry.Polygon, polygon2: shapely.geometry.Polygon) -> float:\n    \"\"\"Calculate the area of two polygons difference.\"\"\"\n    return polygon1.difference(polygon2).area\n\ndef polygons_symmetric_difference(polygon1: shapely.geometry.Polygon, polygon2: shapely.geometry.Polygon) -> float:\n    \"\"\"Calculate the area of two polygons symmetric difference.\"\"\"\n    return polygon1.symmetric_difference(polygon2).area\n\ndef polygons_equals(polygon1: shapely.geometry.Polygon,", "8.1_sanitized": "import shapely\n\ndef polygons_intersection(polygon1: shapely.geometry.Polygon, polygon2: shapely.geometry.Polygon) -> float:\n    \"\"\"Calculate the area of two polygons intersection.\"\"\"\n    return polygon1.intersection(polygon2).area\n", "8.2_prompt": "import shapely\n\ndef forest_area(city: shapely.geometry.Polygon, forset: shapely.geometry.Polygon) -> float:\n    \"\"\"Calculate how much of the forest is inside the city.\"\"\"", "8.2_generated": "import shapely\n\ndef forest_area(city: shapely.geometry.Polygon, forset: shapely.geometry.Polygon) -> float:\n    \"\"\"Calculate how much of the forest is inside the city.\"\"\"\n    return forset.intersection(city).area / forset.area\n\ndef forest_area_ratio(city: shapely.geometry.Polygon, forset: shapely.geometry.Polygon) -> float:\n    \"\"\"Calculate how much of the forest is inside the city.\"\"\"\n    return forset.intersection(city).area / forset.area\n\ndef forest_area_ratio_2(city: shapely.geometry.Polygon, forset: shapely.geometry.Polygon) -> float:\n    \"\"\"Calculate how much of the forest is inside the city.\"\"\"\n    return forset.intersection(city).area / forset.area\n\ndef forest_area_ratio_3(city: shapely.geometry.Polygon, forset: shapely.geometry.Polygon) -> float:\n    \"\"\"Calculate how much of the forest is inside the city.\"\"\"\n    return forset.intersection(city).area / forset", "8.2_sanitized": "import shapely\n\ndef forest_area(city: shapely.geometry.Polygon, forset: shapely.geometry.Polygon) -> float:\n    \"\"\"Calculate how much of the forest is inside the city.\"\"\"\n    return forset.intersection(city).area / forset.area\n", "9.1_prompt": "import h3\n\ndef lat_lon_to_h3(lat: float, lon: float, resolution: int) -> str:\n    \"\"\"Convert a lat lon pair to an h3 cell.\"\"\"", "9.1_generated": "import h3\n\ndef lat_lon_to_h3(lat: float, lon: float, resolution: int) -> str:\n    \"\"\"Convert a lat lon pair to an h3 cell.\"\"\"\n    return h3.geo_to_h3(lat, lon, resolution)\n\ndef h3_to_lat_lon(h3_cell: str) -> Tuple[float, float]:\n    \"\"\"Convert an h3 cell to a lat lon pair.\"\"\"\n    return h3.h3_to_geo(h3_cell)\n\ndef h3_to_lat_lon_array(h3_cells: List[str]) -> List[Tuple[float, float]]:\n    \"\"\"Convert an array of h3 cells to an array of lat lon pairs.\"\"\"\n    return [h3_to_lat_lon(h3_cell) for h3_cell in h3_cells]\n\ndef lat_lon_to_h3_array(lats: List[float], lons: List[float], resolution: int) -> List[str]:\n    \"\"\"Convert an array of lat lon pairs to an array", "9.1_sanitized": "import h3\n\ndef lat_lon_to_h3(lat: float, lon: float, resolution: int) -> str:\n    \"\"\"Convert a lat lon pair to an h3 cell.\"\"\"\n    return h3.geo_to_h3(lat, lon, resolution)\n", "9.2_prompt": "import h3\nimport shapely\n\ndef point_to_h3(point: shapely.geometry.Point, resolution: int) -> str:\n    \"\"\"Convert a point to an h3 cell.\"\"\"", "9.2_generated": "import h3\nimport shapely\n\ndef point_to_h3(point: shapely.geometry.Point, resolution: int) -> str:\n    \"\"\"Convert a point to an h3 cell.\"\"\"\n    return h3.geo_to_h3(point.y, point.x, resolution)\n\ndef h3_to_point(h3_cell: str) -> shapely.geometry.Point:\n    \"\"\"Convert an h3 cell to a point.\"\"\"\n    return shapely.geometry.Point(h3.h3_to_geo(*h3.h3_to_geo_boundary(h3_cell)))\n\ndef h3_to_polygon(h3_cell: str) -> shapely.geometry.Polygon:\n    \"\"\"Convert an h3 cell to a polygon.\"\"\"\n    return shapely.geometry.Polygon(h3.h3_to_geo_boundary(h3_cell))\n\ndef h3_to_multipolygon(h3_cell: str) -> shapely.geometry.MultiPolygon:\n    \"\"\"Convert an h3 cell to a multipoly", "9.2_sanitized": "import h3\nimport shapely\n\ndef point_to_h3(point: shapely.geometry.Point, resolution: int) -> str:\n    \"\"\"Convert a point to an h3 cell.\"\"\"\n    return h3.geo_to_h3(point.y, point.x, resolution)\n", "10_prompt": "import h3\nimport shapely\n\ndef h3_to_polygon(h3_cell: str) -> shapely.geometry.Polygon:\n    \"\"\"Convert an h3 cell to a polygon.\"\"\"", "10_generated": "import h3\nimport shapely\n\ndef h3_to_polygon(h3_cell: str) -> shapely.geometry.Polygon:\n    \"\"\"Convert an h3 cell to a polygon.\"\"\"\n    return shapely.geometry.Polygon(h3.h3_to_geo_boundary(h3_cell, geo_json=True))\n\ndef polygon_to_h3(polygon: shapely.geometry.Polygon) -> str:\n    \"\"\"Convert a polygon to an h3 cell.\"\"\"\n    return h3.geo_to_h3(polygon.exterior.xy[0], polygon.exterior.xy[1], 9)\n\ndef h3_to_polygon_list(h3_cells: List[str]) -> List[shapely.geometry.Polygon]:\n    \"\"\"Convert a list of h3 cells to a list of polygons.\"\"\"\n    return [h3_to_polygon(h3_cell) for h3_cell in h3_cells]\n\ndef polygon_to_h3_list(polygons: List[shapely.geometry.Polygon]) -> List[", "10_sanitized": "import h3\nimport shapely\n\ndef h3_to_polygon(h3_cell: str) -> shapely.geometry.Polygon:\n    \"\"\"Convert an h3 cell to a polygon.\"\"\"\n    return shapely.geometry.Polygon(h3.h3_to_geo_boundary(h3_cell, geo_json=True))\n", "11_prompt": "import h3\n\ndef count_h3_cells_within_polygon(polygon: shapely.geometry.Polygon, resolution: int) -> int:\n    \"\"\"Count the number of h3 cells that are within a polygon.\"\"\"", "11_generated": "import h3\n\ndef count_h3_cells_within_polygon(polygon: shapely.geometry.Polygon, resolution: int) -> int:\n    \"\"\"Count the number of h3 cells that are within a polygon.\"\"\"\n    # Get the h3 cells that are within the polygon\n    cells = h3.polyfill(polygon, resolution)\n\n    # Count the number of cells\n    return len(cells)\n\ndef count_h3_cells_within_polygon_by_resolution(polygon: shapely.geometry.Polygon, resolutions: List[int]) -> List[int]:\n    \"\"\"Count the number of h3 cells that are within a polygon for a list of resolutions.\"\"\"\n    return [count_h3_cells_within_polygon(polygon, resolution) for resolution in resolutions]\n\ndef count_h3_cells_within_polygon_by_resolution_and_polygon(polygons: List[shapely.geometry.Polygon], resolutions: List[int]) -> List[List[int]]:\n    \"\"\"Count the number of h3 cells that are within a polygon for a list of resolutions.\"\"\"\n    return [count_h3_", "11_sanitized": "import h3\n\ndef count_h3_cells_within_polygon(polygon: shapely.geometry.Polygon, resolution: int) -> int:\n    \"\"\"Count the number of h3 cells that are within a polygon.\"\"\"\n    # Get the h3 cells that are within the polygon\n    cells = h3.polyfill(polygon, resolution)\n\n    # Count the number of cells\n    return len(cells)\n", "12.1.1_prompt": "import geopandas as gpd\n\ndef check_point(lat: float, lon: float, name: str, polygons: gpd.GeoDataFrame) -> bool:\n    \"\"\"Check if a point is in the polygon with the given name. The polygons GeoDataFrame contains the polygons boundaries and names in the `name` column.\"\"\"", "12.1.1_generated": "import geopandas as gpd\n\ndef check_point(lat: float, lon: float, name: str, polygons: gpd.GeoDataFrame) -> bool:\n    \"\"\"Check if a point is in the polygon with the given name. The polygons GeoDataFrame contains the polygons boundaries and names in the `name` column.\"\"\"\n    point = gpd.GeoDataFrame(pd.DataFrame({'name': [name], 'geometry': [Point(lon, lat)]}))\n    return point.within(polygons[polygons['name'] == name].iloc[0, 0]).values[0]\n\ndef check_points(points: pd.DataFrame, polygons: gpd.GeoDataFrame) -> pd.DataFrame:\n    \"\"\"Check if the points are in the polygons. The polygons GeoDataFrame contains the polygons boundaries and names in the `name` column.\"\"\"\n    return points.apply(lambda row: check_point(row['lat'], row['lon'], row['name'], polygons), axis=1)\n\ndef check_points_in_polygons(points: pd.DataFrame, polygons: gpd.GeoDataFrame) -> pd.DataFrame:\n    \"\"\"Check if the points are in the polygons. The polygons GeoDataFrame contains the polygons", "12.1.1_sanitized": "import geopandas as gpd\n\ndef check_point(lat: float, lon: float, name: str, polygons: gpd.GeoDataFrame) -> bool:\n    \"\"\"Check if a point is in the polygon with the given name. The polygons GeoDataFrame contains the polygons boundaries and names in the `name` column.\"\"\"\n    point = gpd.GeoDataFrame(pd.DataFrame({'name': [name], 'geometry': [Point(lon, lat)]}))\n    return point.within(polygons[polygons['name'] == name].iloc[0, 0]).values[0]\n", "12.1.2_prompt": "def check_point(lat: float, lon: float, name: str, polygons: str) -> bool:\n    \"\"\"Check if a point is in the polygon with the given name. The polygons is the path to the shapefile with polygons boundaries with `name` feature.\"\"\"", "12.1.2_generated": "def check_point(lat: float, lon: float, name: str, polygons: str) -> bool:\n    \"\"\"Check if a point is in the polygon with the given name. The polygons is the path to the shapefile with polygons boundaries with `name` feature.\"\"\"\n    # Load the shapefile\n    shapefile = fiona.open(polygons)\n    # Get the polygon with the given name\n    polygon = next(filter(lambda x: x['properties']['name'] == name, shapefile))\n    # Check if the point is in the polygon\n    return point_in_polygon(lat, lon, polygon['geometry']['coordinates'][0])\n\n\ndef point_in_polygon(lat: float, lon: float, polygon: list) -> bool:\n    \"\"\"Check if a point is in the polygon. The polygon is a list of points.\"\"\"\n    # Get the number of points in the polygon\n    n = len(polygon)\n    # Initialize the boolean variable\n    inside = False\n    # Check if the point is inside the polygon\n    for i in range(n):\n        j = i + 1\n        if j == n:\n            j = 0\n        if (polygon[i][1] > lat)!= (", "12.1.2_sanitized": "def check_point(lat: float, lon: float, name: str, polygons: str) -> bool:\n    \"\"\"Check if a point is in the polygon with the given name. The polygons is the path to the shapefile with polygons boundaries with `name` feature.\"\"\"\n    # Load the shapefile\n    shapefile = fiona.open(polygons)\n    # Get the polygon with the given name\n    polygon = next(filter(lambda x: x['properties']['name'] == name, shapefile))\n    # Check if the point is in the polygon", "12.1.3_prompt": "def check_point(lat: float, lon: float, name: str, polygons: str) -> bool:\n    \"\"\"Check if a point is in the polygon with the given name. The polygons is the path to the geojson with polygons boundaries with `name` feature.\"\"\"", "12.1.3_generated": "def check_point(lat: float, lon: float, name: str, polygons: str) -> bool:\n    \"\"\"Check if a point is in the polygon with the given name. The polygons is the path to the geojson with polygons boundaries with `name` feature.\"\"\"\n    with open(polygons, \"r\") as f:\n        polygons = json.load(f)\n    for feature in polygons[\"features\"]:\n        if feature[\"properties\"][\"name\"] == name:\n            polygon = feature[\"geometry\"]\n            return point_in_polygon(lat, lon, polygon)\n    return False\n\n\ndef point_in_polygon(lat: float, lon: float, polygon: dict) -> bool:\n    \"\"\"Check if a point is in the polygon. The polygon is a dict with the following structure:\n    {\n        \"type\": \"Polygon\",\n        \"coordinates\": [\n            [\n                [100.0, 0.0],\n                [101.0, 0.0],\n                [101.0, 1.0],\n                [100.0, 1.0],\n                [100.0, 0.0]\n            ]\n        ]\n    }\n   ", "12.1.3_sanitized": "def check_point(lat: float, lon: float, name: str, polygons: str) -> bool:\n    \"\"\"Check if a point is in the polygon with the given name. The polygons is the path to the geojson with polygons boundaries with `name` feature.\"\"\"\n    with open(polygons, \"r\") as f:\n        polygons = json.load(f)\n    for feature in polygons[\"features\"]:\n        if feature[\"properties\"][\"name\"] == name:\n            polygon = feature[\"geometry\"]\n            return point_in_polygon(lat, lon, polygon)", "12.1.4_prompt": "import geopandas as gpd\nimport shapely\n\ndef check_point(point: shapely.geometry.Point, name: str, polygons: gpd.GeoDataFrame) -> bool:\n    \"\"\"Check if a point is in the polygon with the given name. The polygons GeoDataFrame contains the polygon boundaries and names in the `name` column.\"\"\"", "12.1.4_generated": "import geopandas as gpd\nimport shapely\n\ndef check_point(point: shapely.geometry.Point, name: str, polygons: gpd.GeoDataFrame) -> bool:\n    \"\"\"Check if a point is in the polygon with the given name. The polygons GeoDataFrame contains the polygon boundaries and names in the `name` column.\"\"\"\n    for index, row in polygons.iterrows():\n        if row['name'] == name:\n            return row['geometry'].contains(point)\n    return False\n\ndef check_points(points: gpd.GeoDataFrame, polygons: gpd.GeoDataFrame) -> gpd.GeoDataFrame:\n    \"\"\"Check if the points are in the polygons. The polygons GeoDataFrame contains the polygon boundaries and names in the `name` column.\"\"\"\n    points['in_polygon'] = points.apply(lambda row: check_point(row['geometry'], row['name'], polygons), axis=1)\n    return points\n\ndef check_points_in_polygons(points: gpd.GeoDataFrame, polygons: gpd.GeoDataFrame) -> gpd.GeoDataFrame:\n    \"\"\"Check if the points are in the polygons. The polygons GeoDataFrame contains the polygon boundaries and names in the `name` column.\"\"\"\n    points", "12.1.4_sanitized": "import geopandas as gpd\nimport shapely\n\ndef check_point(point: shapely.geometry.Point, name: str, polygons: gpd.GeoDataFrame) -> bool:\n    \"\"\"Check if a point is in the polygon with the given name. The polygons GeoDataFrame contains the polygon boundaries and names in the `name` column.\"\"\"\n    for index, row in polygons.iterrows():\n        if row['name'] == name:\n            return row['geometry'].contains(point)\n    return False\n", "12.1.5_prompt": "import shapely\n\ndef check_point(point: shapely.geometry.Point, name: str, polygons: str) -> bool:\n    \"\"\"Check if a point is in the polygon with the given name. The polygons is the path to the shapefile with polygons boundaries with `name` feature.\"\"\"", "12.1.5_generated": "import shapely\n\ndef check_point(point: shapely.geometry.Point, name: str, polygons: str) -> bool:\n    \"\"\"Check if a point is in the polygon with the given name. The polygons is the path to the shapefile with polygons boundaries with `name` feature.\"\"\"\n    polygons = gpd.read_file(polygons)\n    polygons = polygons[polygons['name'] == name]\n    return polygons.contains(point).any()\n\ndef check_polygon(polygon: shapely.geometry.Polygon, name: str, polygons: str) -> bool:\n    \"\"\"Check if a polygon is in the polygon with the given name. The polygons is the path to the shapefile with polygons boundaries with `name` feature.\"\"\"\n    polygons = gpd.read_file(polygons)\n    polygons = polygons[polygons['name'] == name]\n    return polygons.contains(polygon).any()\n\ndef check_multipolygon(multipolygon: shapely.geometry.MultiPolygon, name: str, polygons: str) -> bool:\n    \"\"\"Check if a multipolygon is in the polygon with the given name. The polygons is the", "12.1.5_sanitized": "import shapely\n\ndef check_point(point: shapely.geometry.Point, name: str, polygons: str) -> bool:\n    \"\"\"Check if a point is in the polygon with the given name. The polygons is the path to the shapefile with polygons boundaries with `name` feature.\"\"\"\n    polygons = gpd.read_file(polygons)\n    polygons = polygons[polygons['name'] == name]\n    return polygons.contains(point).any()\n", "12.1.6_prompt": "import shapely\n\ndef check_point(point: shapely.geometry.Point, name: str, polygons: str) -> bool:\n    \"\"\"Check if a point is in the polygon with the given name. The polygons is the path to the geojson with polygons boundaries with `name` feature.\"\"\"", "12.1.6_generated": "import shapely\n\ndef check_point(point: shapely.geometry.Point, name: str, polygons: str) -> bool:\n    \"\"\"Check if a point is in the polygon with the given name. The polygons is the path to the geojson with polygons boundaries with `name` feature.\"\"\"\n    with open(polygons, 'r') as f:\n        polygons = json.load(f)\n    for polygon in polygons['features']:\n        if polygon['properties']['name'] == name:\n            polygon = shapely.geometry.shape(polygon['geometry'])\n            return polygon.contains(point)\n    return False\n\ndef check_points(points: List[shapely.geometry.Point], polygons: str) -> List[bool]:\n    \"\"\"Check if a list of points are in the polygon with the given name. The polygons is the path to the geojson with polygons boundaries with `name` feature.\"\"\"\n    with open(polygons, 'r') as f:\n        polygons = json.load(f)\n    for polygon in polygons['features']:\n        polygon = shapely.geometry.shape(polygon['geometry'])\n        points_in_polygon = [polygon.contains(point) for point in points", "12.1.6_sanitized": "import shapely\n\ndef check_point(point: shapely.geometry.Point, name: str, polygons: str) -> bool:\n    \"\"\"Check if a point is in the polygon with the given name. The polygons is the path to the geojson with polygons boundaries with `name` feature.\"\"\"\n    with open(polygons, 'r') as f:\n        polygons = json.load(f)\n    for polygon in polygons['features']:\n        if polygon['properties']['name'] == name:\n            polygon = shapely.geometry.shape(polygon['geometry'])\n            return polygon.contains(point)", "12.2.1_prompt": "import geopandas as gpd\n\ndef check_point(lat: float, lon: float, city: str, cities: gpd.GeoDataFrame) -> bool:\n    \"\"\"Check if a point is in the given city. The cities GeoDataFrame contains the cities boundaries and names in the `name` column.\"\"\"", "12.2.1_generated": "import geopandas as gpd\n\ndef check_point(lat: float, lon: float, city: str, cities: gpd.GeoDataFrame) -> bool:\n    \"\"\"Check if a point is in the given city. The cities GeoDataFrame contains the cities boundaries and names in the `name` column.\"\"\"\n    point = gpd.GeoDataFrame(pd.DataFrame({'geometry': [Point(lon, lat)]}))\n    point.crs = cities.crs\n    point = gpd.sjoin(point, cities, how='inner', op='intersects')\n    return point['name'].values[0] == city\n\ndef check_points(points: pd.DataFrame, city: str, cities: gpd.GeoDataFrame) -> pd.DataFrame:\n    \"\"\"Check if a list of points are in the given city. The cities GeoDataFrame contains the cities boundaries and names in the `name` column.\"\"\"\n    points = gpd.GeoDataFrame(points, geometry=gpd.points_from_xy(points.lon, points.lat))\n    points.crs = cities.crs\n    points = gpd.sjoin(points, cities, how='inner', op='intersects')\n    return points[points['name'] == city]\n\ndef", "12.2.1_sanitized": "import geopandas as gpd\n\ndef check_point(lat: float, lon: float, city: str, cities: gpd.GeoDataFrame) -> bool:\n    \"\"\"Check if a point is in the given city. The cities GeoDataFrame contains the cities boundaries and names in the `name` column.\"\"\"\n    point = gpd.GeoDataFrame(pd.DataFrame({'geometry': [Point(lon, lat)]}))\n    point.crs = cities.crs\n    point = gpd.sjoin(point, cities, how='inner', op='intersects')\n    return point['name'].values[0] == city\n", "12.2.2_prompt": "def check_point(lat: float, lon: float, city: str, cities: str) -> bool:\n    \"\"\"Check if a point is in the given city. The cities is the path to the shapefile with cities boundaries with `name` feature.\"\"\"", "12.2.2_generated": "def check_point(lat: float, lon: float, city: str, cities: str) -> bool:\n    \"\"\"Check if a point is in the given city. The cities is the path to the shapefile with cities boundaries with `name` feature.\"\"\"\n    # Load the shapefile\n    cities = gpd.read_file(cities)\n    # Create a point\n    point = gpd.GeoDataFrame(\n        {'geometry': [Point(lon, lat)]},\n        crs={'init': 'epsg:4326'}\n    )\n    # Reproject the point to the same projection as the shapefile\n    point = point.to_crs(cities.crs)\n    # Check if the point is in the city\n    return point.within(cities[cities['name'] == city].geometry.values[0])\n\n\ndef get_closest_city(lat: float, lon: float, cities: str) -> str:\n    \"\"\"Get the closest city to the given point. The cities is the path to the shapefile with cities boundaries with `name` feature.\"\"\"\n    # Load the shapefile\n    cities = gpd.read_file(cities)\n    # Create a point\n    point = gpd", "12.2.2_sanitized": "def check_point(lat: float, lon: float, city: str, cities: str) -> bool:\n    \"\"\"Check if a point is in the given city. The cities is the path to the shapefile with cities boundaries with `name` feature.\"\"\"\n    # Load the shapefile\n    cities = gpd.read_file(cities)\n    # Create a point\n    point = gpd.GeoDataFrame(\n        {'geometry': [Point(lon, lat)]},\n        crs={'init': 'epsg:4326'}\n    )\n    # Reproject the point to the same projection as the shapefile\n    point = point.to_crs(cities.crs)\n    # Check if the point is in the city\n    return point.within(cities[cities['name'] == city].geometry.values[0])\n\n", "12.2.3_prompt": "def check_point(lat: float, lon: float, city: str, cities: str) -> bool:\n    \"\"\"Check if a point is in the given city. The cities is the path to the geojson with cities boundaries with `name` feature.\"\"\"", "12.2.3_generated": "def check_point(lat: float, lon: float, city: str, cities: str) -> bool:\n    \"\"\"Check if a point is in the given city. The cities is the path to the geojson with cities boundaries with `name` feature.\"\"\"\n    with open(cities, \"r\") as f:\n        cities = json.load(f)\n    for city in cities[\"features\"]:\n        if city[\"properties\"][\"name\"] == city_name:\n            city_boundary = city[\"geometry\"]\n            if point_in_polygon(lat, lon, city_boundary):\n                return True\n    return False\n\n\ndef get_city_name(lat: float, lon: float, cities: str) -> str:\n    \"\"\"Get the name of the city where the point is.\"\"\"\n    with open(cities, \"r\") as f:\n        cities = json.load(f)\n    for city in cities[\"features\"]:\n        if point_in_polygon(lat, lon, city[\"geometry\"]):\n            return city[\"properties\"][\"name\"]\n    return \"\"\n\n\ndef get_city_name_from_point(lat: float, lon: float, cities: str) -> str:\n    \"\"\"Get the name", "12.2.3_sanitized": "def check_point(lat: float, lon: float, city: str, cities: str) -> bool:\n    \"\"\"Check if a point is in the given city. The cities is the path to the geojson with cities boundaries with `name` feature.\"\"\"\n    with open(cities, \"r\") as f:\n        cities = json.load(f)\n    for city in cities[\"features\"]:\n        if city[\"properties\"][\"name\"] == city_name:\n            city_boundary = city[\"geometry\"]\n            if point_in_polygon(lat, lon, city_boundary):\n                return True\n    return False\n\n", "12.2.4_prompt": "import geopandas as gpd\nimport shapely\n\ndef check_point(point: shapely.geometry.Point, city: str, cities: gpd.GeoDataFrame) -> bool:\n    \"\"\"Check if a point is in the given city. The cities GeoDataFrame contains the cities boundaries and names in the `name` column.\"\"\"", "12.2.4_generated": "import geopandas as gpd\nimport shapely\n\ndef check_point(point: shapely.geometry.Point, city: str, cities: gpd.GeoDataFrame) -> bool:\n    \"\"\"Check if a point is in the given city. The cities GeoDataFrame contains the cities boundaries and names in the `name` column.\"\"\"\n    return cities[cities['name'] == city].contains(point).any()\n\ndef check_polygon(polygon: shapely.geometry.Polygon, city: str, cities: gpd.GeoDataFrame) -> bool:\n    \"\"\"Check if a polygon is in the given city. The cities GeoDataFrame contains the cities boundaries and names in the `name` column.\"\"\"\n    return cities[cities['name'] == city].contains(polygon).any()\n\ndef check_multipolygon(multipolygon: shapely.geometry.MultiPolygon, city: str, cities: gpd.GeoDataFrame) -> bool:\n    \"\"\"Check if a multipolygon is in the given city. The cities GeoDataFrame contains the cities boundaries and names in the `name` column.\"\"\"\n    return cities[cities['name'] == city].contains(multipolygon).any()\n\ndef check_linestring(linestring: shapely.geometry", "12.2.4_sanitized": "import geopandas as gpd\nimport shapely\n\ndef check_point(point: shapely.geometry.Point, city: str, cities: gpd.GeoDataFrame) -> bool:\n    \"\"\"Check if a point is in the given city. The cities GeoDataFrame contains the cities boundaries and names in the `name` column.\"\"\"\n    return cities[cities['name'] == city].contains(point).any()\n", "12.2.5_prompt": "import shapely\n\ndef check_point(point: shapely.geometry.Point, city: str, cities: str) -> bool:\n    \"\"\"Check if a point is in the given city. The cities is the path to the shapefile with cities boundaries with `name` feature.\"\"\"", "12.2.5_generated": "import shapely\n\ndef check_point(point: shapely.geometry.Point, city: str, cities: str) -> bool:\n    \"\"\"Check if a point is in the given city. The cities is the path to the shapefile with cities boundaries with `name` feature.\"\"\"\n    if city == 'all':\n        return True\n    else:\n        with fiona.open(cities) as cities:\n            for city in cities:\n                if city['properties']['name'] == city:\n                    return point.within(shapely.geometry.shape(city['geometry']))\n        return False\n\ndef check_polygon(polygon: shapely.geometry.Polygon, city: str, cities: str) -> bool:\n    \"\"\"Check if a polygon is in the given city. The cities is the path to the shapefile with cities boundaries with `name` feature.\"\"\"\n    if city == 'all':\n        return True\n    else:\n        with fiona.open(cities) as cities:\n            for city in cities:\n                if city['properties']['name'] == city:\n                    return polygon.within(shapely.geometry.shape(city['geometry']))\n        return False\n\ndef check_multipolygon(multipolygon: sh", "12.2.5_sanitized": "import shapely\n\ndef check_point(point: shapely.geometry.Point, city: str, cities: str) -> bool:\n    \"\"\"Check if a point is in the given city. The cities is the path to the shapefile with cities boundaries with `name` feature.\"\"\"\n    if city == 'all':\n        return True\n    else:\n        with fiona.open(cities) as cities:\n            for city in cities:\n                if city['properties']['name'] == city:\n                    return point.within(shapely.geometry.shape(city['geometry']))\n        return False\n", "12.2.6_prompt": "import shapely\n\ndef check_point(point: shapely.geometry.Point, city: str, cities: str) -> bool:\n    \"\"\"Check if a point is in the given city. The cities is the path to the geojson with cities boundaries with `name` feature.\"\"\"", "12.2.6_generated": "import shapely\n\ndef check_point(point: shapely.geometry.Point, city: str, cities: str) -> bool:\n    \"\"\"Check if a point is in the given city. The cities is the path to the geojson with cities boundaries with `name` feature.\"\"\"\n    with fiona.open(cities) as cities:\n        for city in cities:\n            if city['properties']['name'] == city:\n                city_geom = shapely.geometry.shape(city['geometry'])\n                if city_geom.contains(point):\n                    return True\n    return False\n\ndef check_point_in_city(point: shapely.geometry.Point, city: str, cities: str) -> bool:\n    \"\"\"Check if a point is in the given city. The cities is the path to the geojson with cities boundaries with `name` feature.\"\"\"\n    with fiona.open(cities) as cities:\n        for city in cities:\n            if city['properties']['name'] == city:\n                city_geom = shapely.geometry.shape(city['geometry'])\n                if city_geom.contains(point):\n                    return True\n    return False\n\ndef check_point_in_city_or", "12.2.6_sanitized": "import shapely\n\ndef check_point(point: shapely.geometry.Point, city: str, cities: str) -> bool:\n    \"\"\"Check if a point is in the given city. The cities is the path to the geojson with cities boundaries with `name` feature.\"\"\"\n    with fiona.open(cities) as cities:\n        for city in cities:\n            if city['properties']['name'] == city:\n                city_geom = shapely.geometry.shape(city['geometry'])\n                if city_geom.contains(point):\n                    return True\n    return False\n", "13.1.1_prompt": "import geopandas as gpd\n\ndef get_polygon_name(lat: float, lon: float, polygons: gpd.GeoDataFrame) -> str:\n    \"\"\"Get the name of a polygon in which a point is. The polygons GeoDataFrame contains the polygons boundaries and names in the `name` column.\"\"\"", "13.1.1_generated": "import geopandas as gpd\n\ndef get_polygon_name(lat: float, lon: float, polygons: gpd.GeoDataFrame) -> str:\n    \"\"\"Get the name of a polygon in which a point is. The polygons GeoDataFrame contains the polygons boundaries and names in the `name` column.\"\"\"\n    point = gpd.GeoDataFrame(geometry=[Point(lon, lat)])\n    return point.within(polygons).values[0]\n\ndef get_polygon_name_from_point(point: Point, polygons: gpd.GeoDataFrame) -> str:\n    \"\"\"Get the name of a polygon in which a point is. The polygons GeoDataFrame contains the polygons boundaries and names in the `name` column.\"\"\"\n    return point.within(polygons).values[0]\n\ndef get_polygon_name_from_point_df(point_df: gpd.GeoDataFrame, polygons: gpd.GeoDataFrame) -> str:\n    \"\"\"Get the name of a polygon in which a point is. The polygons GeoDataFrame contains the polygons boundaries and names in the `name` column.\"\"\"\n    return point_df.within(polygons).values[0]\n\ndef get_polygon_name_from", "13.1.1_sanitized": "import geopandas as gpd\n\ndef get_polygon_name(lat: float, lon: float, polygons: gpd.GeoDataFrame) -> str:\n    \"\"\"Get the name of a polygon in which a point is. The polygons GeoDataFrame contains the polygons boundaries and names in the `name` column.\"\"\"\n    point = gpd.GeoDataFrame(geometry=[Point(lon, lat)])\n    return point.within(polygons).values[0]\n", "13.1.2_prompt": "def check_country(lat: float, lon: float, polygons: str) -> str:\n    \"\"\"Get the name of a polygon in which a point is. The polygons is the path to the shapefile with polygons boundaries with `name` feature.\"\"\"", "13.1.2_generated": "def check_country(lat: float, lon: float, polygons: str) -> str:\n    \"\"\"Get the name of a polygon in which a point is. The polygons is the path to the shapefile with polygons boundaries with `name` feature.\"\"\"\n    polygons = fiona.open(polygons)\n    for polygon in polygons:\n        if point_in_polygon(lat, lon, polygon['geometry']['coordinates'][0]):\n            return polygon['properties']['name']\n    return None\n\n\ndef check_country_by_ip(ip: str, polygons: str) -> str:\n    \"\"\"Get the name of a polygon in which a point is. The polygons is the path to the shapefile with polygons boundaries with `name` feature.\"\"\"\n    country = None\n    try:\n        country = pycountry.countries.get(alpha_2=ip)\n    except LookupError:\n        pass\n    if country is None:\n        try:\n            country = pycountry.countries.get(alpha_3=ip)\n        except LookupError:\n            pass\n    if country is None:\n        try:\n            country = pycountry.countries.get(name=ip)\n        except LookupError:\n            pass", "13.1.2_sanitized": "def check_country(lat: float, lon: float, polygons: str) -> str:\n    \"\"\"Get the name of a polygon in which a point is. The polygons is the path to the shapefile with polygons boundaries with `name` feature.\"\"\"\n    polygons = fiona.open(polygons)\n    for polygon in polygons:\n        if point_in_polygon(lat, lon, polygon['geometry']['coordinates'][0]):\n            return polygon['properties']['name']\n    return None\n\n", "13.1.3_prompt": "def check_country(lat: float, lon: float, polygons: str) -> str:\n    \"\"\"Get the name of a polygon in which a point is. The polygons is the path to the geojson with polygons boundaries with `name` feature.\"\"\"", "13.1.3_generated": "def check_country(lat: float, lon: float, polygons: str) -> str:\n    \"\"\"Get the name of a polygon in which a point is. The polygons is the path to the geojson with polygons boundaries with `name` feature.\"\"\"\n    with open(polygons) as f:\n        polygons = json.load(f)\n    for feature in polygons[\"features\"]:\n        polygon = feature[\"geometry\"]\n        if point_in_polygon(lat, lon, polygon):\n            return feature[\"properties\"][\"name\"]\n    return None\n\n\ndef point_in_polygon(lat: float, lon: float, polygon: dict) -> bool:\n    \"\"\"Check if a point is in a polygon.\"\"\"\n    if polygon[\"type\"] == \"Polygon\":\n        return point_in_polygon_polygon(lat, lon, polygon)\n    elif polygon[\"type\"] == \"MultiPolygon\":\n        return any(point_in_polygon_polygon(lat, lon, p) for p in polygon[\"coordinates\"])\n    else:\n        raise ValueError(f\"Unknown polygon type: {polygon['type']}\")\n\n\ndef point_in_polygon_polygon(lat: float, lon: float, polygon: dict)", "13.1.3_sanitized": "def check_country(lat: float, lon: float, polygons: str) -> str:\n    \"\"\"Get the name of a polygon in which a point is. The polygons is the path to the geojson with polygons boundaries with `name` feature.\"\"\"\n    with open(polygons) as f:\n        polygons = json.load(f)\n    for feature in polygons[\"features\"]:\n        polygon = feature[\"geometry\"]\n        if point_in_polygon(lat, lon, polygon):\n            return feature[\"properties\"][\"name\"]\n    return None\n\n", "13.1.4_prompt": "import geopandas as gpd\nimport shapely\n\ndef check_country(point: shapely.geometry.Point, polygons: gpd.GeoDataFrame) -> str:\n    \"\"\"Get the name of a polygon in which a point is. The polygons GeoDataFrame contains the polygons boundaries and names in the `name` column.\"\"\"", "13.1.4_generated": "import geopandas as gpd\nimport shapely\n\ndef check_country(point: shapely.geometry.Point, polygons: gpd.GeoDataFrame) -> str:\n    \"\"\"Get the name of a polygon in which a point is. The polygons GeoDataFrame contains the polygons boundaries and names in the `name` column.\"\"\"\n    for polygon in polygons.itertuples():\n        if polygon.geometry.contains(point):\n            return polygon.name\n    return None\n\ndef get_country_from_point(point: shapely.geometry.Point, polygons: gpd.GeoDataFrame) -> str:\n    \"\"\"Get the name of a polygon in which a point is. The polygons GeoDataFrame contains the polygons boundaries and names in the `name` column.\"\"\"\n    for polygon in polygons.itertuples():\n        if polygon.geometry.contains(point):\n            return polygon.name\n    return None\n\ndef get_country_from_point_df(df: pd.DataFrame, polygons: gpd.GeoDataFrame) -> pd.DataFrame:\n    \"\"\"Get the name of a polygon in which a point is. The polygons GeoDataFrame contains the polygons boundaries and names in the `name` column.\"\"\"\n    df['country'] = df.apply(", "13.1.4_sanitized": "import geopandas as gpd\nimport shapely\n\ndef check_country(point: shapely.geometry.Point, polygons: gpd.GeoDataFrame) -> str:\n    \"\"\"Get the name of a polygon in which a point is. The polygons GeoDataFrame contains the polygons boundaries and names in the `name` column.\"\"\"\n    for polygon in polygons.itertuples():\n        if polygon.geometry.contains(point):\n            return polygon.name\n    return None\n", "13.1.5_prompt": "import shapely\n\ndef check_country(point: shapely.geometry.Point, polygons: str) -> str:\n    \"\"\"Get the name of a polygon in which a point is. The polygons is the path to the shapefile with polygons boundaries with `name` feature.\"\"\"", "13.1.5_generated": "import shapely\n\ndef check_country(point: shapely.geometry.Point, polygons: str) -> str:\n    \"\"\"Get the name of a polygon in which a point is. The polygons is the path to the shapefile with polygons boundaries with `name` feature.\"\"\"\n    with fiona.open(polygons) as src:\n        for feature in src:\n            polygon = shapely.geometry.shape(feature['geometry'])\n            if polygon.contains(point):\n                return feature['properties']['name']\n    return None\n\ndef check_country_in_polygons(df: pd.DataFrame, polygons: str) -> pd.DataFrame:\n    \"\"\"Add a column with the name of the polygon in which a point is.\"\"\"\n    df['country'] = df.apply(lambda row: check_country(shapely.geometry.Point(row['lon'], row['lat']), polygons), axis=1)\n    return df\n\ndef check_country_in_polygons_from_file(df: pd.DataFrame, polygons: str) -> pd.DataFrame:\n    \"\"\"Add a column with the name of the polygon in which a point is. The polygons is the path to the shape", "13.1.5_sanitized": "import shapely\n\ndef check_country(point: shapely.geometry.Point, polygons: str) -> str:\n    \"\"\"Get the name of a polygon in which a point is. The polygons is the path to the shapefile with polygons boundaries with `name` feature.\"\"\"\n    with fiona.open(polygons) as src:\n        for feature in src:\n            polygon = shapely.geometry.shape(feature['geometry'])\n            if polygon.contains(point):\n                return feature['properties']['name']\n    return None\n", "13.1.6_prompt": "import shapely\n\ndef check_country(point: shapely.geometry.Point, polygons: str) -> str:\n    \"\"\"Get the name of a polygon in which a point is. The polygons is the path to the geojson with polygons boundaries with `name` feature.\"\"\"", "13.1.6_generated": "import shapely\n\ndef check_country(point: shapely.geometry.Point, polygons: str) -> str:\n    \"\"\"Get the name of a polygon in which a point is. The polygons is the path to the geojson with polygons boundaries with `name` feature.\"\"\"\n    with fiona.open(polygons) as src:\n        for feature in src:\n            polygon = shapely.geometry.shape(feature['geometry'])\n            if polygon.contains(point):\n                return feature['properties']['name']\n    return None\n\ndef check_country_from_lat_lon(lat: float, lon: float, polygons: str) -> str:\n    \"\"\"Get the name of a polygon in which a point is. The polygons is the path to the geojson with polygons boundaries with `name` feature.\"\"\"\n    return check_country(shapely.geometry.Point(lon, lat), polygons)\n\ndef check_country_from_lat_lon_df(df: pd.DataFrame, polygons: str) -> pd.DataFrame:\n    \"\"\"Get the name of a polygon in which a point is. The polygons is the path to the geojson with polygons boundaries with `name", "13.1.6_sanitized": "import shapely\n\ndef check_country(point: shapely.geometry.Point, polygons: str) -> str:\n    \"\"\"Get the name of a polygon in which a point is. The polygons is the path to the geojson with polygons boundaries with `name` feature.\"\"\"\n    with fiona.open(polygons) as src:\n        for feature in src:\n            polygon = shapely.geometry.shape(feature['geometry'])\n            if polygon.contains(point):\n                return feature['properties']['name']\n    return None\n", "13.2.1_prompt": "import geopandas as gpd\n\ndef check_country(lat: float, lon: float, countries: gpd.GeoDataFrame) -> str:\n    \"\"\"Check in which country a point is. The countries GeoDataFrame contains the countries boundaries and names in the `name` column.\"\"\"", "13.2.1_generated": "import geopandas as gpd\n\ndef check_country(lat: float, lon: float, countries: gpd.GeoDataFrame) -> str:\n    \"\"\"Check in which country a point is. The countries GeoDataFrame contains the countries boundaries and names in the `name` column.\"\"\"\n    point = gpd.GeoDataFrame(pd.DataFrame({'geometry': [Point(lon, lat)]}))\n    point.crs = {'init': 'epsg:4326'}\n    point = gpd.sjoin(point, countries, how='left', op='within')\n    return point['name'].values[0]\n\ncountries = gpd.read_file(gpd.datasets.get_path('naturalearth_lowres'))\ncountries = countries[countries['name']!= 'Antarctica']\ncountries = countries.to_crs({'init': 'epsg:4326'})\n\n# +\n# %%time\n\n# Check in which country each point is\ndf['country'] = df.apply(lambda row: check_country(row['latitude'], row['longitude'], countries), axis=1)\n# -\n\n# ## 3.2. Check the number of tweets", "13.2.1_sanitized": "import geopandas as gpd\n\ndef check_country(lat: float, lon: float, countries: gpd.GeoDataFrame) -> str:\n    \"\"\"Check in which country a point is. The countries GeoDataFrame contains the countries boundaries and names in the `name` column.\"\"\"\n    point = gpd.GeoDataFrame(pd.DataFrame({'geometry': [Point(lon, lat)]}))\n    point.crs = {'init': 'epsg:4326'}\n    point = gpd.sjoin(point, countries, how='left', op='within')", "13.2.2_prompt": "def check_country(lat: float, lon: float, countries: str) -> str:\n    \"\"\"Check in which country a point is. The countries is the path to the shapefile with countries boundaries with `name` feature.\"\"\"", "13.2.2_generated": "def check_country(lat: float, lon: float, countries: str) -> str:\n    \"\"\"Check in which country a point is. The countries is the path to the shapefile with countries boundaries with `name` feature.\"\"\"\n    countries = gpd.read_file(countries)\n    point = gpd.GeoDataFrame(\n        pd.DataFrame(\n            {\n                \"id\": [0],\n                \"geometry\": [Point(lon, lat)],\n            }\n        ),\n        geometry=\"geometry\",\n    )\n    point.crs = countries.crs\n    countries = countries.to_crs(point.crs)\n    point = gpd.sjoin(point, countries, how=\"left\", op=\"within\")\n    return point[\"name\"].values[0]\n\n\ndef check_country_in_list(lat: float, lon: float, countries: str) -> bool:\n    \"\"\"Check if a point is in a list of countries.\"\"\"\n    countries = gpd.read_file(countries)\n    point = gpd.GeoDataFrame(\n        pd.DataFrame(\n            {\n                \"id\": [0],\n                \"geometry\": [Point(lon, lat)],\n            }\n        ),\n        geometry", "13.2.2_sanitized": "def check_country(lat: float, lon: float, countries: str) -> str:\n    \"\"\"Check in which country a point is. The countries is the path to the shapefile with countries boundaries with `name` feature.\"\"\"\n    countries = gpd.read_file(countries)\n    point = gpd.GeoDataFrame(\n        pd.DataFrame(\n            {\n                \"id\": [0],\n                \"geometry\": [Point(lon, lat)],\n            }\n        ),\n        geometry=\"geometry\",\n    )\n    point.crs = countries.crs\n    countries = countries.to_crs(point.crs)\n    point = gpd.sjoin(point, countries, how=\"left\", op=\"within\")", "13.2.3_prompt": "def check_country(lat: float, lon: float, countries: str) -> str:\n    \"\"\"Check in which country a point is. The countries is the path to the geojson with countries boundaries with `name` feature.\"\"\"", "13.2.3_generated": "def check_country(lat: float, lon: float, countries: str) -> str:\n    \"\"\"Check in which country a point is. The countries is the path to the geojson with countries boundaries with `name` feature.\"\"\"\n    with open(countries, \"r\") as f:\n        countries = json.load(f)\n    for feature in countries[\"features\"]:\n        if point_in_polygon(lat, lon, feature[\"geometry\"][\"coordinates\"][0]):\n            return feature[\"properties\"][\"name\"]\n    return None\n\n\ndef check_country_in_file(file: str, countries: str) -> str:\n    \"\"\"Check in which country a file is. The countries is the path to the geojson with countries boundaries with `name` feature.\"\"\"\n    with open(file, \"r\") as f:\n        data = json.load(f)\n    for feature in data[\"features\"]:\n        if point_in_polygon(feature[\"geometry\"][\"coordinates\"][1], feature[\"geometry\"][\"coordinates\"][0], countries):\n            return feature[\"properties\"][\"name\"]\n    return None\n\n\ndef check_country_in_file_by_name(file: str, countries: str) ->", "13.2.3_sanitized": "def check_country(lat: float, lon: float, countries: str) -> str:\n    \"\"\"Check in which country a point is. The countries is the path to the geojson with countries boundaries with `name` feature.\"\"\"\n    with open(countries, \"r\") as f:\n        countries = json.load(f)\n    for feature in countries[\"features\"]:\n        if point_in_polygon(lat, lon, feature[\"geometry\"][\"coordinates\"][0]):\n            return feature[\"properties\"][\"name\"]\n    return None\n\n", "13.2.4_prompt": "import geopandas as gpd\nimport shapely\n\ndef check_country(point: shapely.geometry.Point, countries: gpd.GeoDataFrame) -> str:\n    \"\"\"Check in which country a point is. The countries GeoDataFrame contains the countries boundaries and names in the `name` column.\"\"\"", "13.2.4_generated": "import geopandas as gpd\nimport shapely\n\ndef check_country(point: shapely.geometry.Point, countries: gpd.GeoDataFrame) -> str:\n    \"\"\"Check in which country a point is. The countries GeoDataFrame contains the countries boundaries and names in the `name` column.\"\"\"\n    for country in countries.itertuples():\n        if point.within(country.geometry):\n            return country.name\n    return None\n\ndef check_country_in_df(df: pd.DataFrame, countries: gpd.GeoDataFrame) -> pd.DataFrame:\n    \"\"\"Check in which country each point in a DataFrame is. The countries GeoDataFrame contains the countries boundaries and names in the `name` column.\"\"\"\n    df['country'] = df.apply(lambda row: check_country(shapely.geometry.Point(row.lon, row.lat), countries), axis=1)\n    return df\n\ndef check_country_in_df_parallel(df: pd.DataFrame, countries: gpd.GeoDataFrame) -> pd.DataFrame:\n    \"\"\"Check in which country each point in a DataFrame is. The countries GeoDataFrame contains the countries boundaries and names in the `name` column.\n    This function is a parallel version of", "13.2.4_sanitized": "import geopandas as gpd\nimport shapely\n\ndef check_country(point: shapely.geometry.Point, countries: gpd.GeoDataFrame) -> str:\n    \"\"\"Check in which country a point is. The countries GeoDataFrame contains the countries boundaries and names in the `name` column.\"\"\"\n    for country in countries.itertuples():\n        if point.within(country.geometry):\n            return country.name\n    return None\n", "13.2.5_prompt": "import shapely\n\ndef check_country(point: shapely.geometry.Point, countries: str) -> str:\n    \"\"\"Check in which country a point is. The countries is the path to the shapefile with countries boundaries with `name` feature.\"\"\"", "13.2.5_generated": "import shapely\n\ndef check_country(point: shapely.geometry.Point, countries: str) -> str:\n    \"\"\"Check in which country a point is. The countries is the path to the shapefile with countries boundaries with `name` feature.\"\"\"\n    countries = gpd.read_file(countries)\n    countries = countries.to_crs(epsg=4326)\n    countries = countries.to_crs(epsg=3857)\n    countries = countries.to_crs(epsg=3857)\n    countries = countries.to_crs(epsg=3857)\n    countries = countries.to_crs(epsg=3857)\n    countries = countries.to_crs(epsg=3857)\n    countries = countries.to_crs(epsg=3857)\n    countries = countries.to_crs(epsg=3857)\n    countries = countries.to_crs(epsg=3857)\n    countries = countries.to_crs(epsg=3857)\n    countries = countries.to_crs(epsg=3857)\n   ", "13.2.5_sanitized": "", "13.2.6_prompt": "import shapely\n\ndef check_country(point: shapely.geometry.Point, countries: str) -> str:\n    \"\"\"Check in which country a point is. The countries is the path to the geojson with countries boundaries with `name` feature.\"\"\"", "13.2.6_generated": "import shapely\n\ndef check_country(point: shapely.geometry.Point, countries: str) -> str:\n    \"\"\"Check in which country a point is. The countries is the path to the geojson with countries boundaries with `name` feature.\"\"\"\n    with fiona.open(countries) as countries:\n        for country in countries:\n            if point.within(shapely.geometry.shape(country['geometry'])):\n                return country['properties']['name']\n    return None\n\ndef check_country_in_df(df: pd.DataFrame, countries: str) -> pd.DataFrame:\n    \"\"\"Check in which country each point is. The countries is the path to the geojson with countries boundaries with `name` feature.\"\"\"\n    df['country'] = df.apply(lambda row: check_country(shapely.geometry.Point(row['lon'], row['lat']), countries), axis=1)\n    return df\n\ndef check_country_in_df_parallel(df: pd.DataFrame, countries: str) -> pd.DataFrame:\n    \"\"\"Check in which country each point is. The countries is the path to the geojson with countries boundaries with `name` feature", "13.2.6_sanitized": "import shapely\n\ndef check_country(point: shapely.geometry.Point, countries: str) -> str:\n    \"\"\"Check in which country a point is. The countries is the path to the geojson with countries boundaries with `name` feature.\"\"\"\n    with fiona.open(countries) as countries:\n        for country in countries:\n            if point.within(shapely.geometry.shape(country['geometry'])):\n                return country['properties']['name']\n    return None\n", "14.1_prompt": "def check_country(lat: float, lon: float) -> str:\n    \"\"\"Check in which country a point is. Use the osmnx to perform geocoding to find country name.\"\"\"", "14.1_generated": "def check_country(lat: float, lon: float) -> str:\n    \"\"\"Check in which country a point is. Use the osmnx to perform geocoding to find country name.\"\"\"\n    country = ox.geocoder.geocode_to_gdf(\n        [(lat, lon)],\n        provider=\"nominatim\",\n        user_agent=\"osmnx\",\n        timeout=10,\n    )\n    return country.iloc[0][\"name\"]\n\n\ndef check_country_from_address(address: str) -> str:\n    \"\"\"Check in which country a point is. Use the osmnx to perform geocoding to find country name.\"\"\"\n    country = ox.geocoder.geocode_to_gdf(\n        [address],\n        provider=\"nominatim\",\n        user_agent=\"osmnx\",\n        timeout=10,\n    )\n    return country.iloc[0][\"name\"]\n\n\ndef check_country_from_address_and_country(address: str, country: str) -> str:\n    \"\"\"Check in which country a point is. Use the osmnx to perform geocoding to", "14.1_sanitized": "def check_country(lat: float, lon: float) -> str:\n    \"\"\"Check in which country a point is. Use the osmnx to perform geocoding to find country name.\"\"\"\n    country = ox.geocoder.geocode_to_gdf(\n        [(lat, lon)],\n        provider=\"nominatim\",\n        user_agent=\"osmnx\",\n        timeout=10,\n    )\n    return country.iloc[0][\"name\"]\n\n", "14.2_prompt": "import shapely\n\ndef check_country(point: shapely.geometry.Point) -> str:\n    \"\"\"Check in which country a point is. Use the osmnx to perform geocoding to find country name.\"\"\"", "14.2_generated": "import shapely\n\ndef check_country(point: shapely.geometry.Point) -> str:\n    \"\"\"Check in which country a point is. Use the osmnx to perform geocoding to find country name.\"\"\"\n    country = ox.geocoder.geocode_to_gdf(point)\n    return country.iloc[0]['name']\n\ndef check_country_from_lat_lon(lat: float, lon: float) -> str:\n    \"\"\"Check in which country a point is. Use the osmnx to perform geocoding to find country name.\"\"\"\n    point = shapely.geometry.Point(lon, lat)\n    return check_country(point)\n\ndef check_country_from_lat_lon_df(df: pd.DataFrame) -> pd.DataFrame:\n    \"\"\"Check in which country a point is. Use the osmnx to perform geocoding to find country name.\"\"\"\n    df['country'] = df.apply(lambda row: check_country_from_lat_lon(row['lat'], row['lon']), axis=1)\n    return df\n\ndef check_country_from_lat_lon_", "14.2_sanitized": "import shapely\n\ndef check_country(point: shapely.geometry.Point) -> str:\n    \"\"\"Check in which country a point is. Use the osmnx to perform geocoding to find country name.\"\"\"\n    country = ox.geocoder.geocode_to_gdf(point)\n    return country.iloc[0]['name']\n", "15.1_prompt": "def check_country(lat: float, lon: float, country: str) -> bool:\n    \"\"\"Check if a point lies within the given country. Use the osmnx to perform geocoding.\"\"\"", "15.1_generated": "def check_country(lat: float, lon: float, country: str) -> bool:\n    \"\"\"Check if a point lies within the given country. Use the osmnx to perform geocoding.\"\"\"\n    # Get the country's polygon\n    country_polygon = ox.geocoder.geocode_to_gdf(country)\n    # Get the point's polygon\n    point_polygon = ox.geocoder.geocode_to_gdf([lat, lon])\n    # Check if the point lies within the country\n    return point_polygon.within(country_polygon).iloc[0]\n\n\ndef check_country_osm(lat: float, lon: float, country: str) -> bool:\n    \"\"\"Check if a point lies within the given country. Use the osmnx to perform geocoding.\"\"\"\n    # Get the country's polygon\n    country_polygon = ox.geocoder.geocode_to_gdf(country)\n    # Get the point's polygon\n    point_polygon = ox.geocoder.geocode_to_gdf([lat, lon])\n    # Check if the point lies within the country\n    return point_polygon.", "15.1_sanitized": "def check_country(lat: float, lon: float, country: str) -> bool:\n    \"\"\"Check if a point lies within the given country. Use the osmnx to perform geocoding.\"\"\"\n    # Get the country's polygon\n    country_polygon = ox.geocoder.geocode_to_gdf(country)\n    # Get the point's polygon\n    point_polygon = ox.geocoder.geocode_to_gdf([lat, lon])\n    # Check if the point lies within the country", "15.2_prompt": "import shapely\n\ndef check_country(point: shapely.geometry.Point, country: str) -> bool:\n    \"\"\"Check if a point lies within the given country. Use the osmnx to perform geocoding.\"\"\"", "15.2_generated": "import shapely\n\ndef check_country(point: shapely.geometry.Point, country: str) -> bool:\n    \"\"\"Check if a point lies within the given country. Use the osmnx to perform geocoding.\"\"\"\n    # Get the country's polygon\n    country_polygon = ox.geocoder.geocode_to_gdf(country)\n    # Check if the point lies within the country\n    return country_polygon.contains(point).iloc[0]\n\ndef check_country_from_name(name: str, country: str) -> bool:\n    \"\"\"Check if a point lies within the given country. Use the osmnx to perform geocoding.\"\"\"\n    # Get the country's polygon\n    country_polygon = ox.geocoder.geocode_to_gdf(country)\n    # Check if the point lies within the country\n    return country_polygon.contains(name).iloc[0]\n\ndef check_country_from_name_and_country(name: str, country: str) -> bool:\n    \"\"\"Check if a point lies within the given country. Use the osmnx to perform geocoding.\"\"\"\n    # Get the country's", "15.2_sanitized": "import shapely\n\ndef check_country(point: shapely.geometry.Point, country: str) -> bool:\n    \"\"\"Check if a point lies within the given country. Use the osmnx to perform geocoding.\"\"\"\n    # Get the country's polygon\n    country_polygon = ox.geocoder.geocode_to_gdf(country)\n    # Check if the point lies within the country\n    return country_polygon.contains(point).iloc[0]\n", "16.1_prompt": "import geopandas as gpd\n\ndef trajectory_length(trajectory: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the length of a trajectory. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"", "16.1_generated": "import geopandas as gpd\n\ndef trajectory_length(trajectory: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the length of a trajectory. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    return trajectory.length().sum()\n\ndef trajectory_length_2(trajectory: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the length of a trajectory. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `shapely` library.\"\"\"\n    return sum(line.length for line in trajectory.geometry)\n\ndef trajectory_length_3(trajectory: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the length of a trajectory. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `geopandas` library.\"\"\"\n    return trajectory.length.sum()\n\ndef trajectory_length_4(trajectory: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the length of a trajectory. It is saved in a geodataframe as a collection of points", "16.1_sanitized": "import geopandas as gpd\n\ndef trajectory_length(trajectory: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the length of a trajectory. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    return trajectory.length().sum()\n", "16.3_prompt": "def trajectory_length(trajectory: str) -> float:\n    \"\"\"Calculate the length of a trajectory. It is saved in a geojson as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"", "16.3_generated": "def trajectory_length(trajectory: str) -> float:\n    \"\"\"Calculate the length of a trajectory. It is saved in a geojson as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    gdf = gpd.GeoDataFrame.from_file(trajectory)\n    return gdf.length.sum()\n\n\ndef trajectory_length_from_csv(trajectory: str) -> float:\n    \"\"\"Calculate the length of a trajectory. It is saved in a csv as a collection of points and timestamps in the `geometry` and `t` columns. Use the `pandas` library.\"\"\"\n    df = pd.read_csv(trajectory)\n    return df.geometry.apply(lambda x: x.split(' ')).apply(lambda x: [float(i) for i in x]).apply(lambda x: np.diff(x)).sum()\n\n\ndef trajectory_length_from_csv_with_timestamps(trajectory: str) -> float:\n    \"\"\"Calculate the length of a trajectory. It is saved in a csv as a collection of points and timestamps in the `geometry` and `t` columns. Use the `pandas` library", "16.3_sanitized": "def trajectory_length(trajectory: str) -> float:\n    \"\"\"Calculate the length of a trajectory. It is saved in a geojson as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    gdf = gpd.GeoDataFrame.from_file(trajectory)\n    return gdf.length.sum()\n\n", "16.4_prompt": "import geopandas as gpd\n\ndef walk_length(trip: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the length of a walk. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"", "16.4_generated": "import geopandas as gpd\n\ndef walk_length(trip: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the length of a walk. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    return trip.length().sum()\n\ndef trip_length(trip: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the length of a trip. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    return trip.length().sum()\n\ndef trip_duration(trip: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the duration of a trip. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    return trip.duration().sum()\n\ndef trip_speed(trip: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the speed of a trip. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use", "16.4_sanitized": "import geopandas as gpd\n\ndef walk_length(trip: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the length of a walk. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    return trip.length().sum()\n", "16.6_prompt": "def walk_length(trip: str) -> float:\n    \"\"\"Calculate the length of a walk. It is saved in a geojson as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"", "16.6_generated": "def walk_length(trip: str) -> float:\n    \"\"\"Calculate the length of a walk. It is saved in a geojson as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    # TODO: implement this function\n    return 0.0\n\n\ndef walk_speed(trip: str) -> float:\n    \"\"\"Calculate the average speed of a walk. It is saved in a geojson as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    # TODO: implement this function\n    return 0.0\n\n\ndef walk_duration(trip: str) -> float:\n    \"\"\"Calculate the duration of a walk. It is saved in a geojson as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    # TODO: implement this function\n    return 0.0\n\n\ndef walk_distance(trip: str) -> float:\n    \"\"\"Calculate the distance of a walk. It is saved in a geojson as a collection of points and timestamps in the `geometry` and `t` columns.", "16.6_sanitized": "def walk_length(trip: str) -> float:\n    \"\"\"Calculate the length of a walk. It is saved in a geojson as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    # TODO: implement this function\n    return 0.0\n\n", "17.1_prompt": "import geopandas as gpd\n\ndef trajectory_duration(trajectory: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the duration of a trajectory in seconds. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"", "17.1_generated": "import geopandas as gpd\n\ndef trajectory_duration(trajectory: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the duration of a trajectory in seconds. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    return trajectory.t.max() - trajectory.t.min()\n\ndef trajectory_length(trajectory: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the length of a trajectory in meters. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    return trajectory.length().iloc[0]\n\ndef trajectory_speed(trajectory: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the speed of a trajectory in meters per second. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    return trajectory.length().iloc[0] / trajectory.t.max() - trajectory.t.min()\n\ndef trajectory_acceleration(trajectory: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the acceleration", "17.1_sanitized": "import geopandas as gpd\n\ndef trajectory_duration(trajectory: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the duration of a trajectory in seconds. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    return trajectory.t.max() - trajectory.t.min()\n", "17.3_prompt": "def trajectory_duration(trajectory: str) -> float:\n    \"\"\"Calculate the duration of a trajectory in seconds. It is saved in a geojson as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"", "17.3_generated": "def trajectory_duration(trajectory: str) -> float:\n    \"\"\"Calculate the duration of a trajectory in seconds. It is saved in a geojson as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    gdf = gpd.read_file(trajectory)\n    return gdf.t.max() - gdf.t.min()\n\n\ndef trajectory_length(trajectory: str) -> float:\n    \"\"\"Calculate the length of a trajectory in meters. It is saved in a geojson as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    gdf = gpd.read_file(trajectory)\n    return gdf.length.sum()\n\n\ndef trajectory_speed(trajectory: str) -> float:\n    \"\"\"Calculate the speed of a trajectory in meters per second. It is saved in a geojson as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    gdf = gpd.read_file(trajectory)\n    return gdf.length.sum() / (gdf.t.max", "17.3_sanitized": "def trajectory_duration(trajectory: str) -> float:\n    \"\"\"Calculate the duration of a trajectory in seconds. It is saved in a geojson as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    gdf = gpd.read_file(trajectory)\n    return gdf.t.max() - gdf.t.min()\n\n", "17.4_prompt": "import geopandas as gpd\n\ndef walk_duration(trip: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the duration of a walk in seconds. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"", "17.4_generated": "import geopandas as gpd\n\ndef walk_duration(trip: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the duration of a walk in seconds. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    # TODO: implement this function\n    return 0.0\n\ndef walk_distance(trip: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the distance of a walk in meters. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    # TODO: implement this function\n    return 0.0\n\ndef walk_speed(trip: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the speed of a walk in meters per second. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    # TODO: implement this function\n    return 0.0\n\ndef walk_speed_kmh(trip: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the speed of a walk in kilometers", "17.4_sanitized": "import geopandas as gpd\n\ndef walk_duration(trip: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the duration of a walk in seconds. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    # TODO: implement this function\n    return 0.0\n", "17.6_prompt": "def walk_duration(trip: str) -> float:\n    \"\"\"Calculate the duration of a walk in seconds. It is saved in a geojson as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"", "17.6_generated": "def walk_duration(trip: str) -> float:\n    \"\"\"Calculate the duration of a walk in seconds. It is saved in a geojson as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    # TODO: implement this function\n    return 0.0\n\n\ndef walk_distance(trip: str) -> float:\n    \"\"\"Calculate the distance of a walk in meters. It is saved in a geojson as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    # TODO: implement this function\n    return 0.0\n\n\ndef walk_speed(trip: str) -> float:\n    \"\"\"Calculate the speed of a walk in meters per second. It is saved in a geojson as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    # TODO: implement this function\n    return 0.0\n\n\ndef walk_speed_max(trip: str) -> float:\n    \"\"\"Calculate the maximum speed of a walk in meters per second. It is saved in a geojson as a collection of points and", "17.6_sanitized": "def walk_duration(trip: str) -> float:\n    \"\"\"Calculate the duration of a walk in seconds. It is saved in a geojson as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    # TODO: implement this function\n    return 0.0\n\n", "18.1_prompt": "import geopandas as gpd\n\ndef average_speed(trajectory: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the average speed of a trajectory in meters per second. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"", "18.1_generated": "import geopandas as gpd\n\ndef average_speed(trajectory: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the average speed of a trajectory in meters per second. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    # YOUR CODE HERE\n    raise NotImplementedError()\n\ndef average_speed_2(trajectory: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the average speed of a trajectory in meters per second. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `shapely` library.\"\"\"\n    # YOUR CODE HERE\n    raise NotImplementedError()\n\ndef average_speed_3(trajectory: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the average speed of a trajectory in meters per second. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `pyproj` library.\"\"\"\n    # YOUR CODE HERE\n    raise NotImplementedError()\n\ndef average_speed_4(trajectory: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the average speed of a trajectory in meters per second. It is", "18.1_sanitized": "", "18.3_prompt": "def average_speed(trajectory: str) -> float:\n    \"\"\"Calculate the average speed of a trajectory in meters per second. It is saved in a geojson as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"", "18.3_generated": "def average_speed(trajectory: str) -> float:\n    \"\"\"Calculate the average speed of a trajectory in meters per second. It is saved in a geojson as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    # TODO: implement this function\n    pass\n\n\ndef average_speed_2(trajectory: str) -> float:\n    \"\"\"Calculate the average speed of a trajectory in meters per second. It is saved in a geojson as a collection of points and timestamps in the `geometry` and `t` columns. Use the `pandas` library.\"\"\"\n    # TODO: implement this function\n    pass\n\n\ndef average_speed_3(trajectory: str) -> float:\n    \"\"\"Calculate the average speed of a trajectory in meters per second. It is saved in a geojson as a collection of points and timestamps in the `geometry` and `t` columns. Use the `numpy` library.\"\"\"\n    # TODO: implement this function\n    pass\n\n\ndef average_speed_4(trajectory: str) -> float:\n    \"\"\"Calculate the average speed of a trajectory in meters per second. It is saved in a geojson as a collection of points and timestamps in the `geometry`", "18.3_sanitized": "", "18.4_prompt": "import geopandas as gpd\n\ndef average_walk_speed(trip: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the average speed of a walk in meters per second. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"", "18.4_generated": "import geopandas as gpd\n\ndef average_walk_speed(trip: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the average speed of a walk in meters per second. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    # YOUR CODE HERE\n    raise NotImplementedError()\n\ndef average_walk_speed_2(trip: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the average speed of a walk in meters per second. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `pandas` library.\"\"\"\n    # YOUR CODE HERE\n    raise NotImplementedError()\n\ndef average_walk_speed_3(trip: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the average speed of a walk in meters per second. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `numpy` library.\"\"\"\n    # YOUR CODE HERE\n    raise NotImplementedError()\n\ndef average_walk_speed_4(trip: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the average speed of a walk in meters per second", "18.4_sanitized": "", "18.6_prompt": "def average_walk_speed(trip: str) -> float:\n    \"\"\"Calculate the average speed of a walk in meters per second. It is saved in a geojson as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"", "18.6_generated": "def average_walk_speed(trip: str) -> float:\n    \"\"\"Calculate the average speed of a walk in meters per second. It is saved in a geojson as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    # TODO: implement this function\n    return 0.0\n\n\ndef average_walk_speed_2(trip: str) -> float:\n    \"\"\"Calculate the average speed of a walk in meters per second. It is saved in a geojson as a collection of points and timestamps in the `geometry` and `t` columns. Use the `pandas` library.\"\"\"\n    # TODO: implement this function\n    return 0.0\n\n\ndef average_walk_speed_3(trip: str) -> float:\n    \"\"\"Calculate the average speed of a walk in meters per second. It is saved in a geojson as a collection of points and timestamps in the `geometry` and `t` columns. Use the `numpy` library.\"\"\"\n    # TODO: implement this function\n    return 0.0\n\n\ndef average_walk_speed_4(trip: str) -> float:\n    \"\"\"Calculate the average speed of a walk in meters per second. It", "18.6_sanitized": "def average_walk_speed(trip: str) -> float:\n    \"\"\"Calculate the average speed of a walk in meters per second. It is saved in a geojson as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    # TODO: implement this function\n    return 0.0\n\n", "19.1_prompt": "def geocode_city(city: str) -> Polygon:\n    \"\"\"Geocode a city to get its boundaries. Use the osmnx to perform geocoding.\"\"\"", "19.1_generated": "def geocode_city(city: str) -> Polygon:\n    \"\"\"Geocode a city to get its boundaries. Use the osmnx to perform geocoding.\"\"\"\n    # Geocode the city\n    gdf = ox.geocode_to_gdf(city)\n    # Get the first polygon\n    poly = gdf.iloc[0].geometry\n    return poly\n\n\ndef get_city_boundaries(city: str) -> Polygon:\n    \"\"\"Get the boundaries of a city.\n\n    Args:\n        city: The name of the city.\n\n    Returns:\n        The boundaries of the city.\n    \"\"\"\n    # Get the boundaries of the city\n    poly = geocode_city(city)\n    # Convert the polygon to a GeoDataFrame\n    gdf = gpd.GeoDataFrame(index=[0], crs=poly.crs, geometry=[poly])\n    # Rename the column\n    gdf = gdf.rename(columns={0: \"geometry\"})\n    return gdf\n\n\ndef get_city_boundaries_from_file(city: str) -> Polygon:\n    \"\"\"Get the boundaries of a city from a", "19.1_sanitized": "def geocode_city(city: str) -> Polygon:\n    \"\"\"Geocode a city to get its boundaries. Use the osmnx to perform geocoding.\"\"\"\n    # Geocode the city\n    gdf = ox.geocode_to_gdf(city)\n    # Get the first polygon\n    poly = gdf.iloc[0].geometry\n    return poly\n\n", "20.1_prompt": "def geocode_city(city: str) -> Point:\n    \"\"\"Geocode a city ant get its center point. Use the osmnx to perform geocoding.\"\"\"", "20.1_generated": "def geocode_city(city: str) -> Point:\n    \"\"\"Geocode a city ant get its center point. Use the osmnx to perform geocoding.\"\"\"\n    # Geocode the city\n    gdf = ox.geocode_to_gdf(city)\n    # Get the center point of the city\n    center_point = gdf.geometry.centroid[0]\n    return center_point\n\n\ndef get_center_point(city: str) -> Point:\n    \"\"\"Get the center point of a city.\n\n    Args:\n        city: The city to get the center point of.\n\n    Returns:\n        The center point of the city.\n    \"\"\"\n    # Get the center point of the city\n    center_point = geocode_city(city)\n    return center_point\n\n\ndef get_center_point_from_address(address: str) -> Point:\n    \"\"\"Get the center point of a city from an address.\n\n    Args:\n        address: The address to get the center point of.\n\n    Returns:\n        The center point of the city.\n    \"\"\"\n    # Geocode the city\n    gdf", "20.1_sanitized": "def geocode_city(city: str) -> Point:\n    \"\"\"Geocode a city ant get its center point. Use the osmnx to perform geocoding.\"\"\"\n    # Geocode the city\n    gdf = ox.geocode_to_gdf(city)\n    # Get the center point of the city\n    center_point = gdf.geometry.centroid[0]\n    return center_point\n\n"}