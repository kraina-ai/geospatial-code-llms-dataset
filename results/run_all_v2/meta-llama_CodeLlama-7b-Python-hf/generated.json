{"1.1_prompt": "import geopandas as gpd\n\ndef mean_area(polygons: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate mean area of the polygons in a geodataframe\"\"\"", "1.1_generated": "import geopandas as gpd\n\ndef mean_area(polygons: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate mean area of the polygons in a geodataframe\"\"\"\n    return polygons.geometry.area.mean()\n\ndef mean_perimeter(polygons: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate mean perimeter of the polygons in a geodataframe\"\"\"\n    return polygons.geometry.length.mean()\n\ndef mean_width(polygons: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate mean width of the polygons in a geodataframe\"\"\"\n    return polygons.geometry.exterior.length.mean()\n\ndef mean_height(polygons: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate mean height of the polygons in a geodataframe\"\"\"\n    return polygons.geometry.interpolate(0.5).distance(polygons.geometry.interpolate(0.5,", "1.1_sanitized": "import geopandas as gpd\n\ndef mean_area(polygons: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate mean area of the polygons in a geodataframe\"\"\"\n    return polygons.geometry.area.mean()\n", "1.2_prompt": "def mean_area(filename: str) -> float:\n    \"\"\"Calculate mean area of the polygons in a shapefile\"\"\"", "1.2_generated": "def mean_area(filename: str) -> float:\n    \"\"\"Calculate mean area of the polygons in a shapefile\"\"\"\n    import fiona\n    import pyproj\n    import rasterstats\n    from shapely.geometry import shape\n\n    # read in the shapefile\n    with fiona.open(filename) as source:\n        # get the projection\n        inSpatialRef = pyproj.CRS(source.crs)\n        # define the spatial reference\n        outSpatialRef = pyproj.CRS(\n            {'init': 'epsg:4326'}\n        )\n\n        # create a transform object\n        transform = pyproj.Transformer.from_crs(\n            inSpatialRef, outSpatialRef, always_xy=True).transform\n\n        # create a list for area values\n        area_list = []\n\n        # loop through features\n        for f in source:\n            # get the geometry in the spatial reference system\n            feature", "1.2_sanitized": "", "1.3_prompt": "def mean_area(filename: str) -> float:\n    \"\"\"Calculate mean area of the polygons in a geojson file\"\"\"", "1.3_generated": "def mean_area(filename: str) -> float:\n    \"\"\"Calculate mean area of the polygons in a geojson file\"\"\"\n    import fiona\n    import rasterstats\n    import pyproj\n    import numpy as np\n\n    with fiona.open(filename) as src:\n        # get the CRS\n        crs = src.crs\n        # get the geometries\n        geoms = [feature[\"geometry\"] for feature in src]\n\n    # get the area of each polygon\n    areas = [rasterstats.area(geom, crs=crs) for geom in geoms]\n\n    # calculate the mean area\n    mean_area = np.mean(areas)\n\n    return mean_area\n\n\ndef mean_perimeter(filename: str) -> float:\n    \"\"\"Calculate mean perimeter of the polygons in a geojson file\"\"\"\n    import fiona\n    import rasterstats\n    import pyproj\n    import numpy as np\n\n   ", "1.3_sanitized": "def mean_area(filename: str) -> float:\n    \"\"\"Calculate mean area of the polygons in a geojson file\"\"\"\n    import fiona\n    import rasterstats\n    import pyproj\n    import numpy as np\n\n    with fiona.open(filename) as src:\n        # get the CRS\n        crs = src.crs\n        # get the geometries\n        geoms = [feature[\"geometry\"] for feature in src]\n\n    # get the area of each polygon\n    areas = [rasterstats.area(geom, crs=crs) for geom in geoms]\n\n    # calculate the mean area\n    mean_area = np.mean(areas)\n\n    return mean_area\n\n", "1.4_prompt": "import geopandas as gpd\n\ndef buildings_area(building_gdf: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate mean area of the buildings in a geodataframe\"\"\"", "1.4_generated": "import geopandas as gpd\n\ndef buildings_area(building_gdf: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate mean area of the buildings in a geodataframe\"\"\"\n    return building_gdf.area.mean()\n\ndef buildings_count(building_gdf: gpd.GeoDataFrame) -> int:\n    \"\"\"Calculate mean area of the buildings in a geodataframe\"\"\"\n    return building_gdf.shape[0]\n\ndef buildings_per_hectare(building_gdf: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate mean area of the buildings in a geodataframe\"\"\"\n    return building_gdf.shape[0] / building_gdf.area.sum() * 10000\n\ndef buildings_per_square_meter(building_gdf: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate mean area of the buildings in a geodataframe\"\"\"\n    return building_gdf.shape[0] / building_gdf.area", "1.4_sanitized": "import geopandas as gpd\n\ndef buildings_area(building_gdf: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate mean area of the buildings in a geodataframe\"\"\"\n    return building_gdf.area.mean()\n", "1.5_prompt": "def buildings_area(building_file: str) -> float:\n    \"\"\"Calculate mean area of the buildings in a shapefile\"\"\"", "1.5_generated": "def buildings_area(building_file: str) -> float:\n    \"\"\"Calculate mean area of the buildings in a shapefile\"\"\"\n    import fiona\n    import statistics\n    import shapely.geometry\n\n    with fiona.open(building_file) as buildings:\n        areas = [shapely.geometry.shape(feature['geometry']).area for feature in buildings]\n\n    return statistics.mean(areas)\n\n\nif __name__ == '__main__':\n    building_file = 'data/buildings.shp'\n    area = buildings_area(building_file)\n    print(f'Mean area of buildings: {area:,.2f}')\n", "1.5_sanitized": "def buildings_area(building_file: str) -> float:\n    \"\"\"Calculate mean area of the buildings in a shapefile\"\"\"\n    import fiona\n    import statistics\n    import shapely.geometry\n\n    with fiona.open(building_file) as buildings:\n        areas = [shapely.geometry.shape(feature['geometry']).area for feature in buildings]\n", "1.6_prompt": "def buildings_area(building_file: str) -> float:\n    \"\"\"Calculate mean area of the buildings in a geojson file\"\"\"", "1.6_generated": "def buildings_area(building_file: str) -> float:\n    \"\"\"Calculate mean area of the buildings in a geojson file\"\"\"\n    import fiona\n    import statistics\n    import shapely.geometry\n\n    with fiona.open(building_file) as buildings:\n        areas = [shapely.geometry.shape(feature['geometry']).area for feature in buildings]\n\n    return statistics.mean(areas)\n\n\nif __name__ == '__main__':\n    import argparse\n    parser = argparse.ArgumentParser()\n    parser.add_argument('building_file', type=str)\n    args = parser.parse_args()\n\n    print(buildings_area(args.building_file))\n", "1.6_sanitized": "def buildings_area(building_file: str) -> float:\n    \"\"\"Calculate mean area of the buildings in a geojson file\"\"\"\n    import fiona\n    import statistics\n    import shapely.geometry\n\n    with fiona.open(building_file) as buildings:\n        areas = [shapely.geometry.shape(feature['geometry']).area for feature in buildings]\n", "2.1_prompt": "import geopandas as gpd\n\ndef mean_intersection_area(first: gpd.GeoDataFrame, second: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the mean intersection ratio of polygons. Both arguments are geodataframes.\"\"\"", "2.1_generated": "import geopandas as gpd\n\ndef mean_intersection_area(first: gpd.GeoDataFrame, second: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the mean intersection ratio of polygons. Both arguments are geodataframes.\"\"\"\n    assert first.crs == second.crs, \"CRS must be the same\"\n    assert first.shape[0] == second.shape[0], \"Number of rows must be the same\"\n    assert first.shape[1] == second.shape[1], \"Number of columns must be the same\"\n    assert first.columns.equals(second.columns), \"Columns must be the same\"\n    assert first.geometry.name == second.geometry.name, \"Geometry column names must be the same\"\n\n    intersection_areas = first.geometry.intersection(second.geometry).area\n    return intersection_areas.mean()\n\ndef mean_intersection_ratio(first: gpd.GeoDataFrame, second: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the mean intersection ratio of polygons. Both arguments are geodataframes.\"", "2.1_sanitized": "import geopandas as gpd\n\ndef mean_intersection_area(first: gpd.GeoDataFrame, second: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the mean intersection ratio of polygons. Both arguments are geodataframes.\"\"\"\n    assert first.crs == second.crs, \"CRS must be the same\"\n    assert first.shape[0] == second.shape[0], \"Number of rows must be the same\"\n    assert first.shape[1] == second.shape[1], \"Number of columns must be the same\"\n    assert first.columns.equals(second.columns), \"Columns must be the same\"\n    assert first.geometry.name == second.geometry.name, \"Geometry column names must be the same\"\n\n    intersection_areas = first.geometry.intersection(second.geometry).area", "2.2_prompt": "def mean_intersection_area(first_filename: str, second_filename: str) -> float:\n    \"\"\"Calculate the mean intersection ratio of polygons. Both arguments are shapefiles.\"\"\"", "2.2_generated": "def mean_intersection_area(first_filename: str, second_filename: str) -> float:\n    \"\"\"Calculate the mean intersection ratio of polygons. Both arguments are shapefiles.\"\"\"\n    import fiona\n    import shapely.geometry\n    import numpy as np\n\n    with fiona.open(first_filename) as first_file, fiona.open(second_filename) as second_file:\n        first_polygons = [shapely.geometry.shape(feature['geometry']) for feature in first_file]\n        second_polygons = [shapely.geometry.shape(feature['geometry']) for feature in second_file]\n\n    intersection_areas = [first_polygon.intersection(second_polygon).area for first_polygon, second_polygon in zip(first_polygons, second_polygons)]\n    return np.mean(intersection_areas)\n\n\nif __name__ == '__main__':\n    import argparse\n    parser = argparse.ArgumentParser(description='Calculate", "2.2_sanitized": "def mean_intersection_area(first_filename: str, second_filename: str) -> float:\n    \"\"\"Calculate the mean intersection ratio of polygons. Both arguments are shapefiles.\"\"\"\n    import fiona\n    import shapely.geometry\n    import numpy as np\n\n    with fiona.open(first_filename) as first_file, fiona.open(second_filename) as second_file:\n        first_polygons = [shapely.geometry.shape(feature['geometry']) for feature in first_file]\n        second_polygons = [shapely.geometry.shape(feature['geometry']) for feature in second_file]\n\n    intersection_areas = [first_polygon.intersection(second_polygon).area for first_polygon, second_polygon in zip(first_polygons, second_polygons)]", "2.3_prompt": "def mean_intersection_area(first_filename: str, second_filename: str) -> float:\n    \"\"\"Calculate the mean intersection ratio of polygons. Both arguments are geojson files.\"\"\"", "2.3_generated": "def mean_intersection_area(first_filename: str, second_filename: str) -> float:\n    \"\"\"Calculate the mean intersection ratio of polygons. Both arguments are geojson files.\"\"\"\n    import geopandas as gpd\n    import shapely\n    import numpy as np\n\n    first_gdf = gpd.read_file(first_filename)\n    second_gdf = gpd.read_file(second_filename)\n\n    first_polygons = first_gdf.geometry.values\n    second_polygons = second_gdf.geometry.values\n\n    intersection_areas = []\n    for first_polygon in first_polygons:\n        for second_polygon in second_polygons:\n            intersection = first_polygon.intersection(second_polygon)\n            intersection_areas.append(intersection.area)\n\n    return np.mean(intersection_areas)\n\n\nif __name__ == '__main__':\n    import argparse\n    parser = argparse.ArgumentParser", "2.3_sanitized": "def mean_intersection_area(first_filename: str, second_filename: str) -> float:\n    \"\"\"Calculate the mean intersection ratio of polygons. Both arguments are geojson files.\"\"\"\n    import geopandas as gpd\n    import shapely\n    import numpy as np\n\n    first_gdf = gpd.read_file(first_filename)\n    second_gdf = gpd.read_file(second_filename)\n\n    first_polygons = first_gdf.geometry.values\n    second_polygons = second_gdf.geometry.values\n\n    intersection_areas = []\n    for first_polygon in first_polygons:\n        for second_polygon in second_polygons:\n            intersection = first_polygon.intersection(second_polygon)\n            intersection_areas.append(intersection.area)\n", "2.4_prompt": "import geopandas as gpd\n\ndef building_to_parcel_ratio(buildings_gdf: gpd.GeoDataFrame, parcels_gdf: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the mean ratio of the buliding area compared to the parcel it stands on. Buildings and parcels are in separate geodataframes.\"\"\"", "2.4_generated": "import geopandas as gpd\n\ndef building_to_parcel_ratio(buildings_gdf: gpd.GeoDataFrame, parcels_gdf: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the mean ratio of the buliding area compared to the parcel it stands on. Buildings and parcels are in separate geodataframes.\"\"\"\n    buildings_area = buildings_gdf.area.sum()\n    parcels_area = parcels_gdf.area.sum()\n    return buildings_area / parcels_area\n\ndef building_to_parcel_ratio_within(buildings_gdf: gpd.GeoDataFrame, parcels_gdf: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the mean ratio of the buliding area compared to the parcel it stands on. Buildings and parcels are in separate geodataframes. Only buildings within parcels are considered.\"\"\"\n    buildings_area = buildings_gdf[buildings_gdf.within(parcels_gdf.geometry.iloc[0])].area.sum()\n    parcels_area = parcels_gdf.area.sum()\n    return buildings_area / parcels_area\n", "2.4_sanitized": "import geopandas as gpd\n\ndef building_to_parcel_ratio(buildings_gdf: gpd.GeoDataFrame, parcels_gdf: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the mean ratio of the buliding area compared to the parcel it stands on. Buildings and parcels are in separate geodataframes.\"\"\"\n    buildings_area = buildings_gdf.area.sum()\n    parcels_area = parcels_gdf.area.sum()\n    return buildings_area / parcels_area\n", "2.5_prompt": "def building_to_parcel_ratio(buildings_file: str, parcels_file: str) -> float:\n    \"\"\"Calculate the mean ratio of the buliding area compared to the parcel it stands on. Buildings and parcels are in separate shapefiles.\"\"\"", "2.5_generated": "def building_to_parcel_ratio(buildings_file: str, parcels_file: str) -> float:\n    \"\"\"Calculate the mean ratio of the buliding area compared to the parcel it stands on. Buildings and parcels are in separate shapefiles.\"\"\"\n    import geopandas as gpd\n    import numpy as np\n\n    buildings = gpd.read_file(buildings_file)\n    parcels = gpd.read_file(parcels_file)\n\n    buildings_area = buildings.area.sum()\n    parcels_area = parcels.area.sum()\n\n    ratio = buildings_area / parcels_area\n\n    return ratio\n\n\nif __name__ == \"__main__\":\n    building_to_parcel_ratio(\n        buildings_file=\"data/buildings.shp\", parcels_file=\"data/parcels.shp\"\n    )\n", "2.5_sanitized": "def building_to_parcel_ratio(buildings_file: str, parcels_file: str) -> float:\n    \"\"\"Calculate the mean ratio of the buliding area compared to the parcel it stands on. Buildings and parcels are in separate shapefiles.\"\"\"\n    import geopandas as gpd\n    import numpy as np\n\n    buildings = gpd.read_file(buildings_file)\n    parcels = gpd.read_file(parcels_file)\n\n    buildings_area = buildings.area.sum()\n    parcels_area = parcels.area.sum()\n\n    ratio = buildings_area / parcels_area\n", "2.6_prompt": "def building_to_parcel_ratio(buildings_file: str, parcels_file: str) -> float:\n    \"\"\"Calculate the mean ratio of the buliding area compared to the parcel it stands on. Buildings and parcels are in separate geojson files.\"\"\"", "2.6_generated": "def building_to_parcel_ratio(buildings_file: str, parcels_file: str) -> float:\n    \"\"\"Calculate the mean ratio of the buliding area compared to the parcel it stands on. Buildings and parcels are in separate geojson files.\"\"\"\n    import geopandas as gpd\n    import numpy as np\n    buildings = gpd.read_file(buildings_file)\n    parcels = gpd.read_file(parcels_file)\n    buildings_parcels = gpd.sjoin(buildings, parcels, how='inner', op='intersects')\n    buildings_parcels['ratio'] = buildings_parcels.area / buildings_parcels.geometry_right.area\n    return np.mean(buildings_parcels['ratio'])\n\n\nif __name__ == '__main__':\n    import argparse\n    parser = argparse.ArgumentParser(description='Calculate the mean ratio of the buliding area compared to the parcel it stands on. Buildings and parcels are in separate geojson files.')\n    parser.add_argument('buildings", "2.6_sanitized": "def building_to_parcel_ratio(buildings_file: str, parcels_file: str) -> float:\n    \"\"\"Calculate the mean ratio of the buliding area compared to the parcel it stands on. Buildings and parcels are in separate geojson files.\"\"\"\n    import geopandas as gpd\n    import numpy as np\n    buildings = gpd.read_file(buildings_file)\n    parcels = gpd.read_file(parcels_file)\n    buildings_parcels = gpd.sjoin(buildings, parcels, how='inner', op='intersects')\n    buildings_parcels['ratio'] = buildings_parcels.area / buildings_parcels.geometry_right.area", "3.1_prompt": "import geopandas as gpd\n\ndef points_in_polygons(points_gdf: gpd.GeoDataFrame, polygons_gdf: gpd.GeoDataFrame) -> int:\n    \"\"\"Calculate the number of points that are inside polygons. Points and polygons are stored in GeoDataFrames.\"\"\"", "3.1_generated": "import geopandas as gpd\n\ndef points_in_polygons(points_gdf: gpd.GeoDataFrame, polygons_gdf: gpd.GeoDataFrame) -> int:\n    \"\"\"Calculate the number of points that are inside polygons. Points and polygons are stored in GeoDataFrames.\"\"\"\n    points_gdf.geometry = points_gdf.geometry.buffer(0)\n    points_gdf = points_gdf.loc[points_gdf.geometry.notnull()]\n    points_gdf = points_gdf.loc[points_gdf.geometry.is_valid]\n    points_gdf = points_gdf.loc[points_gdf.geometry.is_empty == False]\n    points_gdf = points_gdf.loc[points_gdf.geometry.has_z == False]\n    points_gdf = points_gdf.loc[points_gdf.geometry.geom_type.isin(['Point'])]\n    polygons_gdf = polygons_gdf.loc[polygons_gdf.geometry.notnull()]\n    polygons_gdf = polygons_", "3.1_sanitized": "", "3.2_prompt": "def points_in_polygons(points: str, polygons: str) -> int:\n    \"\"\"Calculate the number of points that are inside polygons. Points and polygons are stored in shapefiles.\"\"\"", "3.2_generated": "def points_in_polygons(points: str, polygons: str) -> int:\n    \"\"\"Calculate the number of points that are inside polygons. Points and polygons are stored in shapefiles.\"\"\"\n    import fiona\n    import pygeos\n\n    with fiona.open(points) as points_src, fiona.open(polygons) as polygons_src:\n        points = list(points_src)\n        polygons = list(polygons_src)\n\n    points = pygeos.points(points)\n    polygons = pygeos.polygons(polygons)\n\n    return pygeos.count_contains(polygons, points)\n", "3.2_sanitized": "def points_in_polygons(points: str, polygons: str) -> int:\n    \"\"\"Calculate the number of points that are inside polygons. Points and polygons are stored in shapefiles.\"\"\"\n    import fiona\n    import pygeos\n\n    with fiona.open(points) as points_src, fiona.open(polygons) as polygons_src:\n        points = list(points_src)\n        polygons = list(polygons_src)\n\n    points = pygeos.points(points)\n    polygons = pygeos.polygons(polygons)\n", "3.3_prompt": "def points_in_polygons(points: str, polygons: str) -> int:\n    \"\"\"Calculate the number of points that are inside polygons. Points and polygons are stored in geojson files.\"\"\"", "3.3_generated": "def points_in_polygons(points: str, polygons: str) -> int:\n    \"\"\"Calculate the number of points that are inside polygons. Points and polygons are stored in geojson files.\"\"\"\n    import geopandas as gpd\n    import pandas as pd\n    from shapely.geometry import Point, Polygon\n\n    points_df = gpd.read_file(points)\n    polygons_df = gpd.read_file(polygons)\n\n    points_df[\"in_polygon\"] = points_df.apply(lambda row: _point_in_polygon(row, polygons_df), axis=1)\n    return points_df[points_df[\"in_polygon\"]].shape[0]\n\n\ndef _point_in_polygon(row: pd.Series, polygons_df: gpd.GeoDataFrame) -> bool:\n    point = Point(row[\"geometry\"])\n    for polygon in polygons_df[\"geometry\"]:\n        if point.within(polygon):\n            return True\n", "3.3_sanitized": "def points_in_polygons(points: str, polygons: str) -> int:\n    \"\"\"Calculate the number of points that are inside polygons. Points and polygons are stored in geojson files.\"\"\"\n    import geopandas as gpd\n    import pandas as pd\n    from shapely.geometry import Point, Polygon\n\n    points_df = gpd.read_file(points)\n    polygons_df = gpd.read_file(polygons)\n\n    points_df[\"in_polygon\"] = points_df.apply(lambda row: _point_in_polygon(row, polygons_df), axis=1)\n    return points_df[points_df[\"in_polygon\"]].shape[0]\n\n", "3.4_prompt": "import geopandas as gpd\ndef mean_stations_count(bus_stops: gpd.GeoDataFrames, districts: gpd.GeoDataFrames) -> float:\n    \"\"\"Calculate the mean number of bus stops in a districs. Stations and districts are stored in GeoDataFrames.\"\"\"", "3.4_generated": "import geopandas as gpd\ndef mean_stations_count(bus_stops: gpd.GeoDataFrames, districts: gpd.GeoDataFrames) -> float:\n    \"\"\"Calculate the mean number of bus stops in a districs. Stations and districts are stored in GeoDataFrames.\"\"\"\n    # Your code goes here\n    #raise NotImplementedError()\n    #print(bus_stops)\n    #print(districts)\n    #print(bus_stops.geometry.values)\n    #print(districts.geometry.values)\n    #print(bus_stops.geometry.values.intersects(districts.geometry.values))\n    #print(bus_stops.geometry.values.intersects(districts.geometry.values).sum())\n    #print(bus_stops.geometry.values.intersects(districts.geometry.values).sum()/len(bus_stops.geometry.values))\n    return bus_stops.geometry.values.intersects(districts.geometry.values).sum()/len(bus_stops.geometry.values)\n\n\ndef mean", "3.4_sanitized": "import geopandas as gpd\ndef mean_stations_count(bus_stops: gpd.GeoDataFrames, districts: gpd.GeoDataFrames) -> float:\n    \"\"\"Calculate the mean number of bus stops in a districs. Stations and districts are stored in GeoDataFrames.\"\"\"\n    # Your code goes here\n    #raise NotImplementedError()\n    #print(bus_stops)\n    #print(districts)\n    #print(bus_stops.geometry.values)\n    #print(districts.geometry.values)\n    #print(bus_stops.geometry.values.intersects(districts.geometry.values))\n    #print(bus_stops.geometry.values.intersects(districts.geometry.values).sum())\n    #print(bus_stops.geometry.values.intersects(districts.geometry.values).sum()/len(bus_stops.geometry.values))", "3.5_prompt": "def mean_stations_count(bus_stops: str, districts: str) -> float:\n    \"\"\"Calculate the mean number of bus stops in a districs. Stations and districts are stored in shapefiles.\"\"\"", "3.5_generated": "def mean_stations_count(bus_stops: str, districts: str) -> float:\n    \"\"\"Calculate the mean number of bus stops in a districs. Stations and districts are stored in shapefiles.\"\"\"\n    import pandas as pd\n    import geopandas as gpd\n    import numpy as np\n    from shapely.geometry import Point\n\n    # read shapefiles\n    bus_stops = gpd.read_file(bus_stops)\n    districts = gpd.read_file(districts)\n\n    # calculate mean number of bus stops in each district\n    mean_stations = []\n    for i in range(len(districts)):\n        # get district geometry\n        district = districts.iloc[i]\n        district_geometry = district.geometry\n\n        # get stations in district\n        district_stations = bus_stops[bus_stops.geometry.within(district_geometry)]\n\n        # calculate mean number of stations in district\n        mean_stations.append(np.mean(district_stations.count))\n", "3.5_sanitized": "", "3.6_prompt": "def mean_stations_count(bus_stops: str, districts: str) -> float:\n    \"\"\"Calculate the mean number of bus stops in a districs. Stations and districts are stored in geojson files.\"\"\"", "3.6_generated": "def mean_stations_count(bus_stops: str, districts: str) -> float:\n    \"\"\"Calculate the mean number of bus stops in a districs. Stations and districts are stored in geojson files.\"\"\"\n    import json\n    import statistics\n    import geopandas as gpd\n    import shapely\n    from shapely.geometry import Point\n\n    # read the files\n    with open(bus_stops) as f:\n        bus_stops_data = json.load(f)\n    with open(districts) as f:\n        districts_data = json.load(f)\n\n    # create a list of bus stops\n    bus_stops_list = []\n    for feature in bus_stops_data['features']:\n        bus_stops_list.append(Point(feature['geometry']['coordinates']))\n\n    # create a list of districts\n    districts_list = []\n    for feature in districts_data['features']:\n        districts_list.append(shapely.geometry.shape(feature['geometry']))\n\n    # calculate", "3.6_sanitized": "", "4.1_prompt": "import geopandas as gpd\n\ndef is_point_present(x: float, y: float, points: gpd.GeoDataFrame) -> bool:\n    \"\"\"Check if a point is present in a list of points stored in a geojson file.\"\"\"", "4.1_generated": "import geopandas as gpd\n\ndef is_point_present(x: float, y: float, points: gpd.GeoDataFrame) -> bool:\n    \"\"\"Check if a point is present in a list of points stored in a geojson file.\"\"\"\n    return (points.geometry.x == x).any() and (points.geometry.y == y).any()\n\ndef get_point_index(x: float, y: float, points: gpd.GeoDataFrame) -> int:\n    \"\"\"Get the index of a point in a list of points stored in a geojson file.\"\"\"\n    return (points.geometry.x == x).argmax() * points.shape[0] + (points.geometry.y == y).argmax()\n\ndef get_point_coords(x: float, y: float, points: gpd.GeoDataFrame) -> tuple:\n    \"\"\"Get the coordinates of a point in a list of points stored in a geojson file.\"\"\"\n    return (points.geometry.x.iloc[get_point_index(x, y, points)], points.geometry.y.iloc", "4.1_sanitized": "import geopandas as gpd\n\ndef is_point_present(x: float, y: float, points: gpd.GeoDataFrame) -> bool:\n    \"\"\"Check if a point is present in a list of points stored in a geojson file.\"\"\"\n    return (points.geometry.x == x).any() and (points.geometry.y == y).any()\n", "4.2_prompt": "import geopandas as gpd\n\ndef is_point_present(x: float, y: float, filename: str) -> bool:\n    \"\"\"Check if a point is present in a list of points stored in a shapefile.\"\"\"", "4.2_generated": "import geopandas as gpd\n\ndef is_point_present(x: float, y: float, filename: str) -> bool:\n    \"\"\"Check if a point is present in a list of points stored in a shapefile.\"\"\"\n    gdf = gpd.read_file(filename)\n    return (gdf.loc[(gdf['geometry'].x == x) & (gdf['geometry'].y == y)].shape[0] > 0)\n\ndef is_point_in_polygon(x: float, y: float, filename: str) -> bool:\n    \"\"\"Check if a point is present in a list of polygons stored in a shapefile.\"\"\"\n    gdf = gpd.read_file(filename)\n    return (gdf.loc[(gdf['geometry'].contains(Point(x, y))).shape[0] > 0)\n\ndef is_point_in_polygon(x: float, y: float, filename: str) -> bool:\n    \"\"\"Check if a point is present in a list of polygons stored in a shapefile.\"\"\"\n    g", "4.2_sanitized": "import geopandas as gpd\n\ndef is_point_present(x: float, y: float, filename: str) -> bool:\n    \"\"\"Check if a point is present in a list of points stored in a shapefile.\"\"\"\n    gdf = gpd.read_file(filename)\n    return (gdf.loc[(gdf['geometry'].x == x) & (gdf['geometry'].y == y)].shape[0] > 0)\n", "4.3_prompt": "import geopandas as gpd\n\ndef is_point_present(x: float, y: float, filename: str) -> bool:\n    \"\"\"Check if a point is present in a list of points stored in a geojson file.\"\"\"", "4.3_generated": "import geopandas as gpd\n\ndef is_point_present(x: float, y: float, filename: str) -> bool:\n    \"\"\"Check if a point is present in a list of points stored in a geojson file.\"\"\"\n    gdf = gpd.read_file(filename)\n    return (gdf.loc[(gdf['geometry'].x == x) & (gdf['geometry'].y == y)].shape[0] > 0)\n\ndef is_point_in_polygon(x: float, y: float, filename: str) -> bool:\n    \"\"\"Check if a point is present in a list of polygons stored in a geojson file.\"\"\"\n    gdf = gpd.read_file(filename)\n    return (gdf.loc[(gdf['geometry'].contains(Point(x, y))).shape[0] > 0)\n\ndef is_point_in_polygon(x: float, y: float, filename: str) -> bool:\n    \"\"\"Check if a point is present in a list of polygons stored in a geojson file.\"", "4.3_sanitized": "import geopandas as gpd\n\ndef is_point_present(x: float, y: float, filename: str) -> bool:\n    \"\"\"Check if a point is present in a list of points stored in a geojson file.\"\"\"\n    gdf = gpd.read_file(filename)", "4.4_prompt": "import geopandas as gpd\n\ndef is_station(lat: float, lon: float, stations: gpd.GeoDataFrame) -> bool:\n    \"\"\"Check if given coordinates represent a bus station stored in a geodataframe.\"\"\"", "4.4_generated": "import geopandas as gpd\n\ndef is_station(lat: float, lon: float, stations: gpd.GeoDataFrame) -> bool:\n    \"\"\"Check if given coordinates represent a bus station stored in a geodataframe.\"\"\"\n    return stations.loc[stations.geometry.intersects(Point(lon, lat)), 'geometry'].size > 0\n\ndef get_station_name(lat: float, lon: float, stations: gpd.GeoDataFrame) -> str:\n    \"\"\"Return the name of the bus station at given coordinates.\"\"\"\n    return stations.loc[stations.geometry.intersects(Point(lon, lat)), 'name'].values[0]\n\ndef get_station_coords(name: str, stations: gpd.GeoDataFrame) -> tuple:\n    \"\"\"Return the coordinates of the bus station with given name.\"\"\"\n    return stations.loc[stations.name == name, 'geometry'].values[0].coords[0]\n\ndef get_station_id(name: str, stations: gpd.GeoDataFrame) -> int:\n    \"\"\"Return the id", "4.4_sanitized": "import geopandas as gpd\n\ndef is_station(lat: float, lon: float, stations: gpd.GeoDataFrame) -> bool:\n    \"\"\"Check if given coordinates represent a bus station stored in a geodataframe.\"\"\"\n    return stations.loc[stations.geometry.intersects(Point(lon, lat)), 'geometry'].size > 0\n", "4.5_prompt": "import geopandas as gpd\n\ndef is_station(lat: float, lon: float, stations: str) -> bool:\n    \"\"\"Check if given coordinates represent a bus station stored in a shapefile.\"\"\"", "4.5_generated": "import geopandas as gpd\n\ndef is_station(lat: float, lon: float, stations: str) -> bool:\n    \"\"\"Check if given coordinates represent a bus station stored in a shapefile.\"\"\"\n    gdf = gpd.read_file(stations)\n    gdf = gdf.to_crs(epsg=4326)\n    point = gpd.GeoSeries(\n        [gpd.points_from_xy(lon, lat)]\n    )\n    point = point.to_crs(epsg=4326)\n    return gdf.loc[gdf.geometry.contains(point.iloc[0])].empty\n\ndef get_station_name(lat: float, lon: float, stations: str) -> str:\n    \"\"\"Return the name of the bus station at given coordinates.\"\"\"\n    gdf = gpd.read_file(stations)\n    gdf = gdf.to_crs(epsg=4326)\n    point = gpd.GeoSeries(\n        [gpd", "4.5_sanitized": "import geopandas as gpd\n\ndef is_station(lat: float, lon: float, stations: str) -> bool:\n    \"\"\"Check if given coordinates represent a bus station stored in a shapefile.\"\"\"\n    gdf = gpd.read_file(stations)\n    gdf = gdf.to_crs(epsg=4326)\n    point = gpd.GeoSeries(\n        [gpd.points_from_xy(lon, lat)]\n    )\n    point = point.to_crs(epsg=4326)", "4.6_prompt": "import geopandas as gpd\n\ndef is_station(lat: float, lon: float, stations: str) -> bool:\n    \"\"\"Check if given coordinates represent a bus station stored in a geojson file.\"\"\"", "4.6_generated": "import geopandas as gpd\n\ndef is_station(lat: float, lon: float, stations: str) -> bool:\n    \"\"\"Check if given coordinates represent a bus station stored in a geojson file.\"\"\"\n    gdf = gpd.read_file(stations)\n    return gdf.loc[gdf['geometry'].centroid.within(Point(lon, lat))].empty\n\ndef is_station_with_name(lat: float, lon: float, stations: str, name: str) -> bool:\n    \"\"\"Check if given coordinates represent a bus station stored in a geojson file.\"\"\"\n    gdf = gpd.read_file(stations)\n    return gdf.loc[gdf['geometry'].centroid.within(Point(lon, lat))].empty and gdf.loc[gdf['name'] == name].empty\n\ndef is_station_with_name_and_line(lat: float, lon: float, stations: str, name: str, line: str) -> bool:\n    \"\"\"Check if given coordinates represent a bus station stored in", "4.6_sanitized": "import geopandas as gpd\n\ndef is_station(lat: float, lon: float, stations: str) -> bool:\n    \"\"\"Check if given coordinates represent a bus station stored in a geojson file.\"\"\"\n    gdf = gpd.read_file(stations)\n    return gdf.loc[gdf['geometry'].centroid.within(Point(lon, lat))].empty\n", "5_prompt": "import shapely\n\ndef construct_point(x: float, y: float) -> shapely.geometry.Point:\n    \"\"\"Construct a point from x and y coordinates.\"\"\"", "5_generated": "import shapely\n\ndef construct_point(x: float, y: float) -> shapely.geometry.Point:\n    \"\"\"Construct a point from x and y coordinates.\"\"\"\n    return shapely.geometry.Point(x, y)\n\ndef construct_line(points: list[shapely.geometry.Point]) -> shapely.geometry.LineString:\n    \"\"\"Construct a line from a list of points.\"\"\"\n    return shapely.geometry.LineString(points)\n\ndef construct_polygon(points: list[shapely.geometry.Point]) -> shapely.geometry.Polygon:\n    \"\"\"Construct a polygon from a list of points.\"\"\"\n    return shapely.geometry.Polygon(points)\n\ndef construct_circle(center: shapely.geometry.Point, radius: float) -> shapely.geometry.Point:\n    \"\"\"Construct a circle from a center point and a radius.\"\"\"\n    return shapely.geometry.Point(center.x, center.y).buffer(radius)\n", "5_sanitized": "import shapely\n\ndef construct_point(x: float, y: float) -> shapely.geometry.Point:\n    \"\"\"Construct a point from x and y coordinates.\"\"\"\n    return shapely.geometry.Point(x, y)\n", "6.1_prompt": "import shapely\n\ndef is_point_within_polygon(point: shapely.geometry.Point, polygon: shapely.geometry.Polygon) -> bool:\n    \"\"\"Check if a given point lies within a polygon.\"\"\"", "6.1_generated": "import shapely\n\ndef is_point_within_polygon(point: shapely.geometry.Point, polygon: shapely.geometry.Polygon) -> bool:\n    \"\"\"Check if a given point lies within a polygon.\"\"\"\n    return polygon.contains(point)\n\ndef is_point_on_border(point: shapely.geometry.Point, polygon: shapely.geometry.Polygon) -> bool:\n    \"\"\"Check if a given point lies on the border of a polygon.\"\"\"\n    return polygon.touches(point)\n\ndef is_point_outside_polygon(point: shapely.geometry.Point, polygon: shapely.geometry.Polygon) -> bool:\n    \"\"\"Check if a given point lies outside of a polygon.\"\"\"\n    return not polygon.contains(point) and not polygon.touches(point)\n\ndef is_point_on_line(point: shapely.geometry.Point, line: shapely.geometry.LineString) -> bool:\n    \"\"\"Check if a given point lies on a line.\"\"\"\n    return line.touches(point", "6.1_sanitized": "import shapely\n\ndef is_point_within_polygon(point: shapely.geometry.Point, polygon: shapely.geometry.Polygon) -> bool:\n    \"\"\"Check if a given point lies within a polygon.\"\"\"\n    return polygon.contains(point)\n", "6.2_prompt": "import shapely\n\ndef is_in_the_city(place: shapely.geometry.Point, city: shapely.geometry.Polygon) -> bool:\n    \"\"\"Check if a given place lies inside the city boundaries.\"\"\"", "6.2_generated": "import shapely\n\ndef is_in_the_city(place: shapely.geometry.Point, city: shapely.geometry.Polygon) -> bool:\n    \"\"\"Check if a given place lies inside the city boundaries.\"\"\"\n    return city.contains(place)\n\ndef is_in_the_country(place: shapely.geometry.Point, country: shapely.geometry.MultiPolygon) -> bool:\n    \"\"\"Check if a given place lies inside the country boundaries.\"\"\"\n    return country.contains(place)\n\ndef is_in_the_world(place: shapely.geometry.Point, world: shapely.geometry.MultiPolygon) -> bool:\n    \"\"\"Check if a given place lies inside the world boundaries.\"\"\"\n    return world.contains(place)\n\ndef is_in_the_continent(place: shapely.geometry.Point, continent: shapely.geometry.Polygon) -> bool:\n    \"\"\"Check if a given place lies inside the continent boundaries.\"\"\"\n    return continent.contains(place)\n\ndef is_in_the_ocean", "6.2_sanitized": "import shapely\n\ndef is_in_the_city(place: shapely.geometry.Point, city: shapely.geometry.Polygon) -> bool:\n    \"\"\"Check if a given place lies inside the city boundaries.\"\"\"\n    return city.contains(place)\n", "7.1_prompt": "import shapely\n\ndef are_polygons_adjacent(polygon1: shapely.geometry.Polygon, polygon2: shapely.geometry.Polygon) -> bool:\n    \"\"\"Check if two polygons are adjacent.\"\"\"", "7.1_generated": "import shapely\n\ndef are_polygons_adjacent(polygon1: shapely.geometry.Polygon, polygon2: shapely.geometry.Polygon) -> bool:\n    \"\"\"Check if two polygons are adjacent.\"\"\"\n    return polygon1.touches(polygon2)\n\ndef are_polygons_disjoint(polygon1: shapely.geometry.Polygon, polygon2: shapely.geometry.Polygon) -> bool:\n    \"\"\"Check if two polygons are disjoint.\"\"\"\n    return polygon1.disjoint(polygon2)\n\ndef are_polygons_intersect(polygon1: shapely.geometry.Polygon, polygon2: shapely.geometry.Polygon) -> bool:\n    \"\"\"Check if two polygons intersect.\"\"\"\n    return polygon1.intersects(polygon2)\n\ndef are_polygons_overlap(polygon1: shapely.geometry.Polygon, polygon2: shapely.geometry.Polygon) -> bool:\n    \"\"\"Check if two polygons overlap.\"\"\"\n   ", "7.1_sanitized": "import shapely\n\ndef are_polygons_adjacent(polygon1: shapely.geometry.Polygon, polygon2: shapely.geometry.Polygon) -> bool:\n    \"\"\"Check if two polygons are adjacent.\"\"\"\n    return polygon1.touches(polygon2)\n", "7.2_prompt": "import shapely\n\ndef are_countries_neighbours(country1: shapely.geometry.Polygon, country2: shapely.geometry.Polygon) -> bool:\n    \"\"\"Check if two polygons are adjacent.\"\"\"", "7.2_generated": "import shapely\n\ndef are_countries_neighbours(country1: shapely.geometry.Polygon, country2: shapely.geometry.Polygon) -> bool:\n    \"\"\"Check if two polygons are adjacent.\"\"\"\n    return country1.touches(country2)\n\ndef get_neighbours(country: shapely.geometry.Polygon, countries: list) -> list:\n    \"\"\"Get neighbours of a country.\"\"\"\n    neighbours = []\n    for country_ in countries:\n        if are_countries_neighbours(country, country_):\n            neighbours.append(country_)\n    return neighbours\n\ndef get_neighbours_names(country: shapely.geometry.Polygon, countries: list, names: list) -> list:\n    \"\"\"Get neighbours of a country.\"\"\"\n    neighbours = []\n    for country_ in countries:\n        if are_countries_neighbours(country, country_):\n            neighbours.append(names[countries.index(country_)])\n    return neighbours\n\ndef get", "7.2_sanitized": "import shapely\n\ndef are_countries_neighbours(country1: shapely.geometry.Polygon, country2: shapely.geometry.Polygon) -> bool:\n    \"\"\"Check if two polygons are adjacent.\"\"\"\n    return country1.touches(country2)\n", "8.1_prompt": "import shapely\n\ndef polygons_intersection(polygon1: shapely.geometry.Polygon, polygon2: shapely.geometry.Polygon) -> float:\n    \"\"\"Calculate the area of two polygons intersection.\"\"\"", "8.1_generated": "import shapely\n\ndef polygons_intersection(polygon1: shapely.geometry.Polygon, polygon2: shapely.geometry.Polygon) -> float:\n    \"\"\"Calculate the area of two polygons intersection.\"\"\"\n    intersection = polygon1.intersection(polygon2)\n    return intersection.area\n\ndef polygons_union(polygon1: shapely.geometry.Polygon, polygon2: shapely.geometry.Polygon) -> float:\n    \"\"\"Calculate the area of two polygons union.\"\"\"\n    union = polygon1.union(polygon2)\n    return union.area\n\ndef polygons_iou(polygon1: shapely.geometry.Polygon, polygon2: shapely.geometry.Polygon) -> float:\n    \"\"\"Calculate the intersection over union of two polygons.\"\"\"\n    return polygons_intersection(polygon1, polygon2) / polygons_union(polygon1, polygon2)\n\ndef polygons_iou_score(polygon1: shapely.geometry.Polygon", "8.1_sanitized": "import shapely\n\ndef polygons_intersection(polygon1: shapely.geometry.Polygon, polygon2: shapely.geometry.Polygon) -> float:\n    \"\"\"Calculate the area of two polygons intersection.\"\"\"\n    intersection = polygon1.intersection(polygon2)\n    return intersection.area\n", "8.2_prompt": "import shapely\n\ndef forest_area(city: shapely.geometry.Polygon, forset: shapely.geometry.Polygon) -> float:\n    \"\"\"Calculate how much of the forest is inside the city.\"\"\"", "8.2_generated": "import shapely\n\ndef forest_area(city: shapely.geometry.Polygon, forset: shapely.geometry.Polygon) -> float:\n    \"\"\"Calculate how much of the forest is inside the city.\"\"\"\n    return city.intersection(forset).area / forset.area\n\ndef forest_area_all(cities: list[shapely.geometry.Polygon], forests: list[shapely.geometry.Polygon]) -> list[float]:\n    \"\"\"Calculate how much of each forest is inside each city.\"\"\"\n    return [forest_area(city, forset) for city in cities for forset in forests]\n\ndef forest_area_all_matrix(cities: list[shapely.geometry.Polygon], forests: list[shapely.geometry.Polygon]) -> list[list[float]]:\n    \"\"\"Calculate how much of each forest is inside each city.\"\"\"\n    return [[forest_area(city, forset) for city in cities] for forset in forests]\n\ndef forest_area_all_matrix_", "8.2_sanitized": "import shapely\n\ndef forest_area(city: shapely.geometry.Polygon, forset: shapely.geometry.Polygon) -> float:\n    \"\"\"Calculate how much of the forest is inside the city.\"\"\"\n    return city.intersection(forset).area / forset.area\n", "9.1_prompt": "import h3\n\ndef lat_lon_to_h3(lat: float, lon: float, resolution: int) -> str:\n    \"\"\"Convert a lat lon pair to an h3 cell.\"\"\"", "9.1_generated": "import h3\n\ndef lat_lon_to_h3(lat: float, lon: float, resolution: int) -> str:\n    \"\"\"Convert a lat lon pair to an h3 cell.\"\"\"\n    return h3.geo_to_h3(lat, lon, resolution)\n\ndef h3_to_lat_lon(h3_cell: str) -> (float, float):\n    \"\"\"Convert an h3 cell to a lat lon pair.\"\"\"\n    return h3.h3_to_geo(h3_cell)\n\ndef h3_to_region(h3_cell: str) -> str:\n    \"\"\"Convert an h3 cell to a region.\"\"\"\n    return h3.h3_to_region(h3_cell)\n\ndef h3_to_parent(h3_cell: str, resolution: int) -> str:\n    \"\"\"Convert an h3 cell to a parent cell.\"\"\"\n    return h3.h3_to_parent(h3_cell, resolution)\n\ndef h3_to_children(h3_cell", "9.1_sanitized": "import h3\n\ndef lat_lon_to_h3(lat: float, lon: float, resolution: int) -> str:\n    \"\"\"Convert a lat lon pair to an h3 cell.\"\"\"\n    return h3.geo_to_h3(lat, lon, resolution)\n", "9.2_prompt": "import h3\nimport shapely\n\ndef point_to_h3(point: shapely.geometry.Point, resolution: int) -> str:\n    \"\"\"Convert a point to an h3 cell.\"\"\"", "9.2_generated": "import h3\nimport shapely\n\ndef point_to_h3(point: shapely.geometry.Point, resolution: int) -> str:\n    \"\"\"Convert a point to an h3 cell.\"\"\"\n    return h3.geo_to_h3(point.x, point.y, resolution)\n\ndef polygon_to_h3(polygon: shapely.geometry.Polygon, resolution: int) -> str:\n    \"\"\"Convert a polygon to an h3 cell.\"\"\"\n    return h3.geo_to_h3(polygon.centroid, resolution)\n\ndef multipolygon_to_h3(multipolygon: shapely.geometry.MultiPolygon, resolution: int) -> str:\n    \"\"\"Convert a multipolygon to an h3 cell.\"\"\"\n    return h3.geo_to_h3(multipolygon.centroid, resolution)\n\ndef geometry_to_h3(geometry: shapely.geometry.base.BaseGeometry, resolution: int) -> str:\n    \"\"\"Convert a geometry to an h3 cell.\"\"\"", "9.2_sanitized": "import h3\nimport shapely\n\ndef point_to_h3(point: shapely.geometry.Point, resolution: int) -> str:\n    \"\"\"Convert a point to an h3 cell.\"\"\"\n    return h3.geo_to_h3(point.x, point.y, resolution)\n", "10_prompt": "import h3\nimport shapely\n\ndef h3_to_polygon(h3_cell: str) -> shapely.geometry.Polygon:\n    \"\"\"Convert an h3 cell to a polygon.\"\"\"", "10_generated": "import h3\nimport shapely\n\ndef h3_to_polygon(h3_cell: str) -> shapely.geometry.Polygon:\n    \"\"\"Convert an h3 cell to a polygon.\"\"\"\n    return shapely.geometry.Polygon(h3.h3_to_geo(h3_cell))\n\ndef h3_to_multipolygon(h3_cell: str) -> shapely.geometry.MultiPolygon:\n    \"\"\"Convert an h3 cell to a multipolygon.\"\"\"\n    return shapely.geometry.MultiPolygon(h3.h3_to_geo(h3_cell))\n\ndef h3_to_geometry(h3_cell: str) -> shapely.geometry.base.BaseGeometry:\n    \"\"\"Convert an h3 cell to a geometry.\"\"\"\n    return shapely.geometry.base.BaseGeometry(h3.h3_to_geo(h3_cell))\n\ndef h3_to_centroid(h3_cell: str) -> shapely.geometry.Point:", "10_sanitized": "import h3\nimport shapely\n\ndef h3_to_polygon(h3_cell: str) -> shapely.geometry.Polygon:\n    \"\"\"Convert an h3 cell to a polygon.\"\"\"\n    return shapely.geometry.Polygon(h3.h3_to_geo(h3_cell))\n", "11_prompt": "import h3\n\ndef count_h3_cells_within_polygon(polygon: shapely.geometry.Polygon, resolution: int) -> int:\n    \"\"\"Count the number of h3 cells that are within a polygon.\"\"\"", "11_generated": "import h3\n\ndef count_h3_cells_within_polygon(polygon: shapely.geometry.Polygon, resolution: int) -> int:\n    \"\"\"Count the number of h3 cells that are within a polygon.\"\"\"\n    # TODO: This is a very naive implementation.\n    # We should use the h3 library to do this.\n    # https://uber.github.io/h3/#/h3lib/h3lib_API_h3numCells\n    # https://github.com/uber/h3/blob/master/src/h3lib/src/h3NumCells.c\n    # https://github.com/uber/h3/blob/master/src/h3lib/src/h3IndexToZRange.c\n    # https://github.com/uber/h3/blob/master/src/h3lib/src/h3IndexToZRange.h\n    # https://github.com/uber/h3/blob/master/src/h3lib/src/h3IndexToZRange.h\n    # https://github.com/uber", "11_sanitized": "", "12.1.1_prompt": "import geopandas as gpd\n\ndef check_point(lat: float, lon: float, name: str, polygons: gpd.GeoDataFrame) -> bool:\n    \"\"\"Check if a point is in the polygon with the given name. The polygons GeoDataFrame contains the polygons boundaries and names in the `name` column.\"\"\"", "12.1.1_generated": "import geopandas as gpd\n\ndef check_point(lat: float, lon: float, name: str, polygons: gpd.GeoDataFrame) -> bool:\n    \"\"\"Check if a point is in the polygon with the given name. The polygons GeoDataFrame contains the polygons boundaries and names in the `name` column.\"\"\"\n    point = gpd.points_from_xy([lon], [lat])[0]\n    return polygons.loc[polygons['name'] == name, 'geometry'].iloc[0].contains(point)\n\ndef check_points(points: list[tuple[float, float]], name: str, polygons: gpd.GeoDataFrame) -> list[bool]:\n    \"\"\"Check if a list of points is in the polygon with the given name. The polygons GeoDataFrame contains the polygons boundaries and names in the `name` column.\"\"\"\n    return [check_point(lat, lon, name, polygons) for (lon, lat) in points]\n\ndef check_points_in_polygons(points: list[tuple[float, float]], polygons: gpd.GeoDataFrame) -> list[bool]:\n    \"\"\"Check if", "12.1.1_sanitized": "import geopandas as gpd\n\ndef check_point(lat: float, lon: float, name: str, polygons: gpd.GeoDataFrame) -> bool:\n    \"\"\"Check if a point is in the polygon with the given name. The polygons GeoDataFrame contains the polygons boundaries and names in the `name` column.\"\"\"\n    point = gpd.points_from_xy([lon], [lat])[0]\n    return polygons.loc[polygons['name'] == name, 'geometry'].iloc[0].contains(point)\n", "12.1.2_prompt": "def check_point(lat: float, lon: float, name: str, polygons: str) -> bool:\n    \"\"\"Check if a point is in the polygon with the given name. The polygons is the path to the shapefile with polygons boundaries with `name` feature.\"\"\"", "12.1.2_generated": "def check_point(lat: float, lon: float, name: str, polygons: str) -> bool:\n    \"\"\"Check if a point is in the polygon with the given name. The polygons is the path to the shapefile with polygons boundaries with `name` feature.\"\"\"\n    from shapely.geometry import Point, Polygon\n    from shapely.ops import cascaded_union\n    from fiona import collection\n\n    polygons = collection(polygons, \"r\")\n    for polygon in polygons:\n        if polygon[\"properties\"][\"NAME\"] == name:\n            break\n    else:\n        raise ValueError(f\"No polygon with name {name} found in {polygons.path}\")\n\n    return Polygon(polygon[\"geometry\"][\"coordinates\"][0]).contains(Point(lon, lat))\n\n\ndef check_point_in_polygons(lat: float, lon: float, polygons: str) -> bool:\n    \"\"\"Check if a point is in the polygon with the given name. The polygons is the path to the shapefile with polygons boundaries with `name` feature.\"\"\"", "12.1.2_sanitized": "def check_point(lat: float, lon: float, name: str, polygons: str) -> bool:\n    \"\"\"Check if a point is in the polygon with the given name. The polygons is the path to the shapefile with polygons boundaries with `name` feature.\"\"\"\n    from shapely.geometry import Point, Polygon\n    from shapely.ops import cascaded_union\n    from fiona import collection\n\n    polygons = collection(polygons, \"r\")\n    for polygon in polygons:\n        if polygon[\"properties\"][\"NAME\"] == name:\n            break\n    else:\n        raise ValueError(f\"No polygon with name {name} found in {polygons.path}\")\n\n    return Polygon(polygon[\"geometry\"][\"coordinates\"][0]).contains(Point(lon, lat))\n\n", "12.1.3_prompt": "def check_point(lat: float, lon: float, name: str, polygons: str) -> bool:\n    \"\"\"Check if a point is in the polygon with the given name. The polygons is the path to the geojson with polygons boundaries with `name` feature.\"\"\"", "12.1.3_generated": "def check_point(lat: float, lon: float, name: str, polygons: str) -> bool:\n    \"\"\"Check if a point is in the polygon with the given name. The polygons is the path to the geojson with polygons boundaries with `name` feature.\"\"\"\n    import geopandas as gpd\n    import shapely\n    import shapely.geometry\n    import shapely.ops\n    import shapely.prepared\n    import shapely.vectorized\n    import shapely.wkt\n    import shapely.affinity\n    import pyproj\n    import json\n    import os\n    import numpy as np\n    import pandas as pd\n    import geopandas as gpd\n    import shapely\n    import shapely.geometry\n    import shapely.ops\n    import shapely.prepared\n    import shapely.vectorized\n    import shapely.wkt\n    import shapely.affinity\n    import pyproj\n    import json\n    import os\n    import numpy as np\n    import pandas as pd\n    import geopandas as gpd\n    import shapely\n", "12.1.3_sanitized": "", "12.1.4_prompt": "import geopandas as gpd\nimport shapely\n\ndef check_point(point: shapely.geometry.Point, name: str, polygons: gpd.GeoDataFrame) -> bool:\n    \"\"\"Check if a point is in the polygon with the given name. The polygons GeoDataFrame contains the polygon boundaries and names in the `name` column.\"\"\"", "12.1.4_generated": "import geopandas as gpd\nimport shapely\n\ndef check_point(point: shapely.geometry.Point, name: str, polygons: gpd.GeoDataFrame) -> bool:\n    \"\"\"Check if a point is in the polygon with the given name. The polygons GeoDataFrame contains the polygon boundaries and names in the `name` column.\"\"\"\n    for i, polygon in polygons.iterrows():\n        if polygon['name'] == name:\n            if point.within(polygon['geometry']):\n                return True\n    return False\n\ndef check_points(points: gpd.GeoDataFrame, polygons: gpd.GeoDataFrame) -> gpd.GeoDataFrame:\n    \"\"\"Check if the points are in the polygons. The polygons GeoDataFrame contains the polygon boundaries and names in the `name` column.\"\"\"\n    points['in_polygon'] = points.apply(lambda row: check_point(row['geometry'], row['name'], polygons), axis=1)\n    return points\n\ndef check_polygons(polygons: gpd.GeoDataFrame) -> gpd.GeoDataFrame:\n    \"\"\"Check if the polygons are in the polygons", "12.1.4_sanitized": "import geopandas as gpd\nimport shapely\n\ndef check_point(point: shapely.geometry.Point, name: str, polygons: gpd.GeoDataFrame) -> bool:\n    \"\"\"Check if a point is in the polygon with the given name. The polygons GeoDataFrame contains the polygon boundaries and names in the `name` column.\"\"\"\n    for i, polygon in polygons.iterrows():\n        if polygon['name'] == name:\n            if point.within(polygon['geometry']):\n                return True\n    return False\n", "12.1.5_prompt": "import shapely\n\ndef check_point(point: shapely.geometry.Point, name: str, polygons: str) -> bool:\n    \"\"\"Check if a point is in the polygon with the given name. The polygons is the path to the shapefile with polygons boundaries with `name` feature.\"\"\"", "12.1.5_generated": "import shapely\n\ndef check_point(point: shapely.geometry.Point, name: str, polygons: str) -> bool:\n    \"\"\"Check if a point is in the polygon with the given name. The polygons is the path to the shapefile with polygons boundaries with `name` feature.\"\"\"\n    from shapely.geometry import Point, Polygon\n    from shapely.ops import unary_union\n    from fiona import collection\n    from os.path import join\n    from shapely.geometry import shape\n    from shapely.ops import transform\n    from shapely.affinity import rotate\n    from shapely.geometry import Point\n    from shapely.geometry import Polygon\n    from shapely.geometry import MultiPolygon\n    from shapely.geometry import mapping\n    from shapely.geometry import MultiPolygon\n    from shapely.geometry import Polygon\n    from shapely.geometry import MultiPolygon\n    from shapely.geometry import mapping\n    from shapely.geometry import Polygon\n    from shapely.geometry import MultiPolygon\n    from shapely.geometry import mapping\n    from shapely.", "12.1.5_sanitized": "", "12.1.6_prompt": "import shapely\n\ndef check_point(point: shapely.geometry.Point, name: str, polygons: str) -> bool:\n    \"\"\"Check if a point is in the polygon with the given name. The polygons is the path to the geojson with polygons boundaries with `name` feature.\"\"\"", "12.1.6_generated": "import shapely\n\ndef check_point(point: shapely.geometry.Point, name: str, polygons: str) -> bool:\n    \"\"\"Check if a point is in the polygon with the given name. The polygons is the path to the geojson with polygons boundaries with `name` feature.\"\"\"\n    from shapely.geometry import Point, Polygon\n    from shapely.ops import unary_union\n    from geopandas import GeoDataFrame, GeoSeries\n    import geopandas as gpd\n    import json\n    import os\n\n    with open(polygons, 'r') as f:\n        data = json.load(f)\n\n    gdf = GeoDataFrame({'geometry': GeoSeries(data['features'])})\n    gdf = gdf.set_index('name')\n    gdf = gdf.loc[name]\n    gdf = gdf.reset_index()\n    gdf = gdf.set_geometry('geometry')\n    gdf = gdf.drop(columns=['id', 'properties', 'type'])\n    gdf = gdf.rename(columns={'name': 'index'})\n   ", "12.1.6_sanitized": "", "12.2.1_prompt": "import geopandas as gpd\n\ndef check_point(lat: float, lon: float, city: str, cities: gpd.GeoDataFrame) -> bool:\n    \"\"\"Check if a point is in the given city. The cities GeoDataFrame contains the cities boundaries and names in the `name` column.\"\"\"", "12.2.1_generated": "import geopandas as gpd\n\ndef check_point(lat: float, lon: float, city: str, cities: gpd.GeoDataFrame) -> bool:\n    \"\"\"Check if a point is in the given city. The cities GeoDataFrame contains the cities boundaries and names in the `name` column.\"\"\"\n    return cities.loc[cities.geometry.contains(gpd.points_from_xy([lon], [lat]))].name.values[0] == city\n\ndef check_point_list(lat: float, lon: float, city: str, cities: gpd.GeoDataFrame) -> bool:\n    \"\"\"Check if a point is in the given city. The cities GeoDataFrame contains the cities boundaries and names in the `name` column.\"\"\"\n    return cities.loc[cities.geometry.contains(gpd.points_from_xy([lon], [lat]))].name.values[0] == city\n\ndef check_point_list_with_name(lat: float, lon: float, city: str, cities: gpd.GeoDataFrame) -> bool:\n    \"\"\"Check if a point is in the given city. The cities GeoDataFrame contains the cities boundaries and names", "12.2.1_sanitized": "import geopandas as gpd\n\ndef check_point(lat: float, lon: float, city: str, cities: gpd.GeoDataFrame) -> bool:\n    \"\"\"Check if a point is in the given city. The cities GeoDataFrame contains the cities boundaries and names in the `name` column.\"\"\"\n    return cities.loc[cities.geometry.contains(gpd.points_from_xy([lon], [lat]))].name.values[0] == city\n", "12.2.2_prompt": "def check_point(lat: float, lon: float, city: str, cities: str) -> bool:\n    \"\"\"Check if a point is in the given city. The cities is the path to the shapefile with cities boundaries with `name` feature.\"\"\"", "12.2.2_generated": "def check_point(lat: float, lon: float, city: str, cities: str) -> bool:\n    \"\"\"Check if a point is in the given city. The cities is the path to the shapefile with cities boundaries with `name` feature.\"\"\"\n    import fiona\n    from shapely.geometry import shape\n    from shapely.geometry import Point\n\n    with fiona.open(cities, \"r\") as source:\n        for city in source:\n            if city[\"properties\"][\"name\"] == city:\n                city_shape = shape(city[\"geometry\"])\n                break\n\n    return city_shape.contains(Point(lon, lat))\n\n\ndef check_point_in_cities(lat: float, lon: float, cities: str) -> bool:\n    \"\"\"Check if a point is in the given city. The cities is the path to the shapefile with cities boundaries with `name` feature.\"\"\"\n    import fiona\n    from shapely.geometry import shape\n    from shapely.geometry import Point\n\n    with fiona.open(cities, \"r\") as source:\n        for", "12.2.2_sanitized": "def check_point(lat: float, lon: float, city: str, cities: str) -> bool:\n    \"\"\"Check if a point is in the given city. The cities is the path to the shapefile with cities boundaries with `name` feature.\"\"\"\n    import fiona\n    from shapely.geometry import shape\n    from shapely.geometry import Point\n\n    with fiona.open(cities, \"r\") as source:\n        for city in source:\n            if city[\"properties\"][\"name\"] == city:\n                city_shape = shape(city[\"geometry\"])\n                break\n", "12.2.3_prompt": "def check_point(lat: float, lon: float, city: str, cities: str) -> bool:\n    \"\"\"Check if a point is in the given city. The cities is the path to the geojson with cities boundaries with `name` feature.\"\"\"", "12.2.3_generated": "def check_point(lat: float, lon: float, city: str, cities: str) -> bool:\n    \"\"\"Check if a point is in the given city. The cities is the path to the geojson with cities boundaries with `name` feature.\"\"\"\n    import json\n    import geojson\n    import shapely.geometry\n    import shapely.ops\n    import shapely.prepared\n    import shapely.strtree\n    import shapely.wkt\n    import shapely.affinity\n    import shapely.geometry\n    import shapely.geometry.base\n    import shapely.geometry.polygon\n    import shapely.geometry.point\n    import shapely.geometry.linestring\n    import shapely.geometry.multilinestring\n    import shapely.geometry.multilinestring\n    import shapely.geometry.multilinestring\n    import shapely.geometry.multilinestring\n    import shapely.geometry.multilinestring\n    import shapely.geometry.multilinestring\n    import", "12.2.3_sanitized": "", "12.2.4_prompt": "import geopandas as gpd\nimport shapely\n\ndef check_point(point: shapely.geometry.Point, city: str, cities: gpd.GeoDataFrame) -> bool:\n    \"\"\"Check if a point is in the given city. The cities GeoDataFrame contains the cities boundaries and names in the `name` column.\"\"\"", "12.2.4_generated": "import geopandas as gpd\nimport shapely\n\ndef check_point(point: shapely.geometry.Point, city: str, cities: gpd.GeoDataFrame) -> bool:\n    \"\"\"Check if a point is in the given city. The cities GeoDataFrame contains the cities boundaries and names in the `name` column.\"\"\"\n    return cities.loc[cities.geometry.contains(point), 'name'].values[0] == city\n\ndef check_polygon(polygon: shapely.geometry.Polygon, city: str, cities: gpd.GeoDataFrame) -> bool:\n    \"\"\"Check if a polygon is in the given city. The cities GeoDataFrame contains the cities boundaries and names in the `name` column.\"\"\"\n    return cities.loc[cities.geometry.contains(polygon), 'name'].values[0] == city\n\ndef check_multipolygon(multipolygon: shapely.geometry.MultiPolygon, city: str, cities: gpd.GeoDataFrame) -> bool:\n    \"\"\"Check if a multipolygon is in the given city. The cities GeoDataFrame contains the cities boundaries and names in the `name` column.\"\"\"\n    return cities.loc[c", "12.2.4_sanitized": "import geopandas as gpd\nimport shapely\n\ndef check_point(point: shapely.geometry.Point, city: str, cities: gpd.GeoDataFrame) -> bool:\n    \"\"\"Check if a point is in the given city. The cities GeoDataFrame contains the cities boundaries and names in the `name` column.\"\"\"\n    return cities.loc[cities.geometry.contains(point), 'name'].values[0] == city\n", "12.2.5_prompt": "import shapely\n\ndef check_point(point: shapely.geometry.Point, city: str, cities: str) -> bool:\n    \"\"\"Check if a point is in the given city. The cities is the path to the shapefile with cities boundaries with `name` feature.\"\"\"", "12.2.5_generated": "import shapely\n\ndef check_point(point: shapely.geometry.Point, city: str, cities: str) -> bool:\n    \"\"\"Check if a point is in the given city. The cities is the path to the shapefile with cities boundaries with `name` feature.\"\"\"\n    city_shape = shapely.geometry.shape(next(filter(lambda f: f['name'] == city, cities.records())))\n    return city_shape.contains(point)\n\ndef check_points(points: list[shapely.geometry.Point], city: str, cities: str) -> list[bool]:\n    \"\"\"Check if a list of points is in the given city. The cities is the path to the shapefile with cities boundaries with `name` feature.\"\"\"\n    city_shape = shapely.geometry.shape(next(filter(lambda f: f['name'] == city, cities.records())))\n    return list(map(city_shape.contains, points))\n\ndef check_polygon(polygon: shapely.geometry.Polygon, city: str, cities: str) -> bool:\n    \"\"\"Check if a polygon is in", "12.2.5_sanitized": "import shapely\n\ndef check_point(point: shapely.geometry.Point, city: str, cities: str) -> bool:\n    \"\"\"Check if a point is in the given city. The cities is the path to the shapefile with cities boundaries with `name` feature.\"\"\"\n    city_shape = shapely.geometry.shape(next(filter(lambda f: f['name'] == city, cities.records())))\n    return city_shape.contains(point)\n", "12.2.6_prompt": "import shapely\n\ndef check_point(point: shapely.geometry.Point, city: str, cities: str) -> bool:\n    \"\"\"Check if a point is in the given city. The cities is the path to the geojson with cities boundaries with `name` feature.\"\"\"", "12.2.6_generated": "import shapely\n\ndef check_point(point: shapely.geometry.Point, city: str, cities: str) -> bool:\n    \"\"\"Check if a point is in the given city. The cities is the path to the geojson with cities boundaries with `name` feature.\"\"\"\n    city_boundary = shapely.geometry.shape(cities[city])\n    return city_boundary.contains(point)\n\ndef check_points(points: list[shapely.geometry.Point], city: str, cities: str) -> list[bool]:\n    \"\"\"Check if a list of points is in the given city. The cities is the path to the geojson with cities boundaries with `name` feature.\"\"\"\n    city_boundary = shapely.geometry.shape(cities[city])\n    return [city_boundary.contains(point) for point in points]\n\ndef check_polygon(polygon: shapely.geometry.Polygon, city: str, cities: str) -> bool:\n    \"\"\"Check if a polygon is in the given city. The cities is the path to the geojson with cities boundaries with `name` feature.\"", "12.2.6_sanitized": "import shapely\n\ndef check_point(point: shapely.geometry.Point, city: str, cities: str) -> bool:\n    \"\"\"Check if a point is in the given city. The cities is the path to the geojson with cities boundaries with `name` feature.\"\"\"\n    city_boundary = shapely.geometry.shape(cities[city])\n    return city_boundary.contains(point)\n", "13.1.1_prompt": "import geopandas as gpd\n\ndef get_polygon_name(lat: float, lon: float, polygons: gpd.GeoDataFrame) -> str:\n    \"\"\"Get the name of a polygon in which a point is. The polygons GeoDataFrame contains the polygons boundaries and names in the `name` column.\"\"\"", "13.1.1_generated": "import geopandas as gpd\n\ndef get_polygon_name(lat: float, lon: float, polygons: gpd.GeoDataFrame) -> str:\n    \"\"\"Get the name of a polygon in which a point is. The polygons GeoDataFrame contains the polygons boundaries and names in the `name` column.\"\"\"\n    point = gpd.points_from_xy([lon], [lat])\n    point_gdf = gpd.GeoDataFrame(geometry=point, crs=\"EPSG:4326\")\n    point_gdf.set_crs(polygons.crs, inplace=True)\n    point_gdf.to_crs(polygons.crs, inplace=True)\n    point_gdf.geometry = point_gdf.geometry.buffer(0.000001)\n    point_gdf.set_crs(polygons.crs, inplace=True)\n    point_gdf.to_crs(\"EPSG:4326\", inplace=True)\n    point_gdf.geometry = point_gdf.geometry.buffer(-0.000001)", "13.1.1_sanitized": "import geopandas as gpd\n\ndef get_polygon_name(lat: float, lon: float, polygons: gpd.GeoDataFrame) -> str:\n    \"\"\"Get the name of a polygon in which a point is. The polygons GeoDataFrame contains the polygons boundaries and names in the `name` column.\"\"\"\n    point = gpd.points_from_xy([lon], [lat])\n    point_gdf = gpd.GeoDataFrame(geometry=point, crs=\"EPSG:4326\")\n    point_gdf.set_crs(polygons.crs, inplace=True)\n    point_gdf.to_crs(polygons.crs, inplace=True)\n    point_gdf.geometry = point_gdf.geometry.buffer(0.000001)\n    point_gdf.set_crs(polygons.crs, inplace=True)\n    point_gdf.to_crs(\"EPSG:4326\", inplace=True)", "13.1.2_prompt": "def check_country(lat: float, lon: float, polygons: str) -> str:\n    \"\"\"Get the name of a polygon in which a point is. The polygons is the path to the shapefile with polygons boundaries with `name` feature.\"\"\"", "13.1.2_generated": "def check_country(lat: float, lon: float, polygons: str) -> str:\n    \"\"\"Get the name of a polygon in which a point is. The polygons is the path to the shapefile with polygons boundaries with `name` feature.\"\"\"\n    from shapely.geometry import Point, Polygon\n    from shapely.ops import cascaded_union\n    from fiona import collection\n    from os import path\n    from shapely.geometry import shape\n    from shapely.ops import transform\n    from shapely.affinity import rotate\n    from functools import partial\n    from pyproj import Proj\n    from pyproj.transformer import Transformer\n    from pyproj import CRS\n    from shapely.geometry import mapping\n    from shapely.geometry import shape\n    from shapely.ops import transform\n    from shapely.affinity import rotate\n    from functools import partial\n    from pyproj import Proj\n    from pyproj.transformer import Transformer\n    from pyproj import CRS\n    from shapely.geometry import mapping\n    from shapely.geometry", "13.1.2_sanitized": "", "13.1.3_prompt": "def check_country(lat: float, lon: float, polygons: str) -> str:\n    \"\"\"Get the name of a polygon in which a point is. The polygons is the path to the geojson with polygons boundaries with `name` feature.\"\"\"", "13.1.3_generated": "def check_country(lat: float, lon: float, polygons: str) -> str:\n    \"\"\"Get the name of a polygon in which a point is. The polygons is the path to the geojson with polygons boundaries with `name` feature.\"\"\"\n    from shapely.geometry import Point, Polygon\n    from shapely.ops import unary_union\n    import geopandas as gpd\n    import json\n\n    gdf = gpd.read_file(polygons)\n    gdf[\"name\"] = gdf[\"name\"].astype(str)\n    gdf[\"geometry\"] = gdf.geometry.map(json.loads)\n    gdf = gdf.set_geometry(\"geometry\")\n    gdf = gdf.set_crs(epsg=4326)\n\n    point = Point(lon, lat)\n    for name, polygon in gdf.set_index(\"name\").geometry.to_dict().items():\n        if polygon.contains(point):\n            return name\n    return \"\"\n\n\ndef get_country(lat: float, lon: float) -> str:\n", "13.1.3_sanitized": "def check_country(lat: float, lon: float, polygons: str) -> str:\n    \"\"\"Get the name of a polygon in which a point is. The polygons is the path to the geojson with polygons boundaries with `name` feature.\"\"\"\n    from shapely.geometry import Point, Polygon\n    from shapely.ops import unary_union\n    import geopandas as gpd\n    import json\n\n    gdf = gpd.read_file(polygons)\n    gdf[\"name\"] = gdf[\"name\"].astype(str)\n    gdf[\"geometry\"] = gdf.geometry.map(json.loads)\n    gdf = gdf.set_geometry(\"geometry\")\n    gdf = gdf.set_crs(epsg=4326)\n\n    point = Point(lon, lat)\n    for name, polygon in gdf.set_index(\"name\").geometry.to_dict().items():\n        if polygon.contains(point):\n            return name", "13.1.4_prompt": "import geopandas as gpd\nimport shapely\n\ndef check_country(point: shapely.geometry.Point, polygons: gpd.GeoDataFrame) -> str:\n    \"\"\"Get the name of a polygon in which a point is. The polygons GeoDataFrame contains the polygons boundaries and names in the `name` column.\"\"\"", "13.1.4_generated": "import geopandas as gpd\nimport shapely\n\ndef check_country(point: shapely.geometry.Point, polygons: gpd.GeoDataFrame) -> str:\n    \"\"\"Get the name of a polygon in which a point is. The polygons GeoDataFrame contains the polygons boundaries and names in the `name` column.\"\"\"\n    for i, polygon in polygons.iterrows():\n        if point.within(polygon['geometry']):\n            return polygon['name']\n    return None\n\ndef check_country_multi(points: gpd.GeoDataFrame, polygons: gpd.GeoDataFrame) -> gpd.GeoDataFrame:\n    \"\"\"Get the name of a polygon in which a point is. The polygons GeoDataFrame contains the polygons boundaries and names in the `name` column.\"\"\"\n    points['country'] = points.apply(lambda point: check_country(point['geometry'], polygons), axis=1)\n    return points\n\ndef check_country_multi_fast(points: gpd.GeoDataFrame, polygons: gpd.GeoDataFrame) -> gpd.GeoDataFrame:\n    \"\"\"Get the name of a polygon in which a point", "13.1.4_sanitized": "import geopandas as gpd\nimport shapely\n\ndef check_country(point: shapely.geometry.Point, polygons: gpd.GeoDataFrame) -> str:\n    \"\"\"Get the name of a polygon in which a point is. The polygons GeoDataFrame contains the polygons boundaries and names in the `name` column.\"\"\"\n    for i, polygon in polygons.iterrows():\n        if point.within(polygon['geometry']):\n            return polygon['name']\n    return None\n", "13.1.5_prompt": "import shapely\n\ndef check_country(point: shapely.geometry.Point, polygons: str) -> str:\n    \"\"\"Get the name of a polygon in which a point is. The polygons is the path to the shapefile with polygons boundaries with `name` feature.\"\"\"", "13.1.5_generated": "import shapely\n\ndef check_country(point: shapely.geometry.Point, polygons: str) -> str:\n    \"\"\"Get the name of a polygon in which a point is. The polygons is the path to the shapefile with polygons boundaries with `name` feature.\"\"\"\n    import geopandas\n    import shapely\n    import fiona\n    import rtree\n    import os\n    import pyproj\n    import numpy as np\n    import pandas as pd\n    import geopandas as gpd\n    import shapely\n    import shapely.geometry\n    import shapely.ops\n    import shapely.prepared\n    import shapely.vectorized\n    import shapely.affinity\n    import shapely.speedups\n    import shapely.wkt\n    import shapely.geos\n    import shapely.prepared\n    import shapely.geometry.polygon\n    import shapely.geometry.point\n    import shapely.geometry.linestring\n    import shapely.geometry.multilinestring\n    import shapely.geometry.multilinestring\n", "13.1.5_sanitized": "", "13.1.6_prompt": "import shapely\n\ndef check_country(point: shapely.geometry.Point, polygons: str) -> str:\n    \"\"\"Get the name of a polygon in which a point is. The polygons is the path to the geojson with polygons boundaries with `name` feature.\"\"\"", "13.1.6_generated": "import shapely\n\ndef check_country(point: shapely.geometry.Point, polygons: str) -> str:\n    \"\"\"Get the name of a polygon in which a point is. The polygons is the path to the geojson with polygons boundaries with `name` feature.\"\"\"\n    for polygon in polygons:\n        if point.within(polygon):\n            return polygon['properties']['name']\n    return None\n\ndef check_country_name(point: shapely.geometry.Point, polygons: str) -> str:\n    \"\"\"Get the name of a polygon in which a point is. The polygons is the path to the geojson with polygons boundaries with `name` feature.\"\"\"\n    for polygon in polygons:\n        if point.within(polygon):\n            return polygon['properties']['name']\n    return None\n\ndef check_country_code(point: shapely.geometry.Point, polygons: str) -> str:\n    \"\"\"Get the name of a polygon in which a point is. The polygons is the path to the geojson with polygons boundaries with `name` feature.\"\"\"", "13.1.6_sanitized": "import shapely\n\ndef check_country(point: shapely.geometry.Point, polygons: str) -> str:\n    \"\"\"Get the name of a polygon in which a point is. The polygons is the path to the geojson with polygons boundaries with `name` feature.\"\"\"\n    for polygon in polygons:\n        if point.within(polygon):\n            return polygon['properties']['name']\n    return None\n", "13.2.1_prompt": "import geopandas as gpd\n\ndef check_country(lat: float, lon: float, countries: gpd.GeoDataFrame) -> str:\n    \"\"\"Check in which country a point is. The countries GeoDataFrame contains the countries boundaries and names in the `name` column.\"\"\"", "13.2.1_generated": "import geopandas as gpd\n\ndef check_country(lat: float, lon: float, countries: gpd.GeoDataFrame) -> str:\n    \"\"\"Check in which country a point is. The countries GeoDataFrame contains the countries boundaries and names in the `name` column.\"\"\"\n    point = gpd.GeoSeries(\n        [gpd.points.Point(lon, lat)]\n    )\n    point.crs = countries.crs\n    point = point.to_crs(epsg=3857)\n    point = point.to_crs(epsg=4326)\n    point = point.iloc[0]\n    point = gpd.GeoSeries(point)\n    point.crs = countries.crs\n    point = point.to_crs(epsg=3857)\n    point = point.to_crs(epsg=4326)\n    point = point.iloc[0]\n    point = gpd.GeoSeries(point)\n    point.crs = countries.crs\n    point = point.to_crs(epsg=3", "13.2.1_sanitized": "", "13.2.2_prompt": "def check_country(lat: float, lon: float, countries: str) -> str:\n    \"\"\"Check in which country a point is. The countries is the path to the shapefile with countries boundaries with `name` feature.\"\"\"", "13.2.2_generated": "def check_country(lat: float, lon: float, countries: str) -> str:\n    \"\"\"Check in which country a point is. The countries is the path to the shapefile with countries boundaries with `name` feature.\"\"\"\n    import geopandas as gpd\n    import shapely\n    import os\n    from shapely.geometry import Point\n\n    countries = gpd.read_file(countries)\n    point = Point(lon, lat)\n    for i in range(len(countries)):\n        if countries.iloc[i].geometry.contains(point):\n            return countries.iloc[i].name\n    return None\n\n\ndef check_country_from_coords(coords: tuple, countries: str) -> str:\n    \"\"\"Check in which country a point is. The countries is the path to the shapefile with countries boundaries with `name` feature.\"\"\"\n    import geopandas as gpd\n    import shapely\n    import os\n    from shapely.geometry import Point\n\n    countries = gpd.read_file(countries)\n    point =", "13.2.2_sanitized": "def check_country(lat: float, lon: float, countries: str) -> str:\n    \"\"\"Check in which country a point is. The countries is the path to the shapefile with countries boundaries with `name` feature.\"\"\"\n    import geopandas as gpd\n    import shapely\n    import os\n    from shapely.geometry import Point\n\n    countries = gpd.read_file(countries)\n    point = Point(lon, lat)\n    for i in range(len(countries)):\n        if countries.iloc[i].geometry.contains(point):\n            return countries.iloc[i].name", "13.2.3_prompt": "def check_country(lat: float, lon: float, countries: str) -> str:\n    \"\"\"Check in which country a point is. The countries is the path to the geojson with countries boundaries with `name` feature.\"\"\"", "13.2.3_generated": "def check_country(lat: float, lon: float, countries: str) -> str:\n    \"\"\"Check in which country a point is. The countries is the path to the geojson with countries boundaries with `name` feature.\"\"\"\n    import geopandas as gpd\n    import shapely\n    import json\n\n    countries = gpd.read_file(countries)\n    countries.set_crs(epsg=4326, inplace=True)\n    countries.to_crs(epsg=3857, inplace=True)\n\n    point = shapely.geometry.Point(lon, lat)\n    for i, row in countries.iterrows():\n        if row['geometry'].contains(point):\n            return row['name']\n    return ''\n\n\nif __name__ == '__main__':\n    import sys\n    check_country(*[float(x) for x in sys.argv[1:]])\n", "13.2.3_sanitized": "def check_country(lat: float, lon: float, countries: str) -> str:\n    \"\"\"Check in which country a point is. The countries is the path to the geojson with countries boundaries with `name` feature.\"\"\"\n    import geopandas as gpd\n    import shapely\n    import json\n\n    countries = gpd.read_file(countries)\n    countries.set_crs(epsg=4326, inplace=True)\n    countries.to_crs(epsg=3857, inplace=True)\n\n    point = shapely.geometry.Point(lon, lat)\n    for i, row in countries.iterrows():\n        if row['geometry'].contains(point):\n            return row['name']", "13.2.4_prompt": "import geopandas as gpd\nimport shapely\n\ndef check_country(point: shapely.geometry.Point, countries: gpd.GeoDataFrame) -> str:\n    \"\"\"Check in which country a point is. The countries GeoDataFrame contains the countries boundaries and names in the `name` column.\"\"\"", "13.2.4_generated": "import geopandas as gpd\nimport shapely\n\ndef check_country(point: shapely.geometry.Point, countries: gpd.GeoDataFrame) -> str:\n    \"\"\"Check in which country a point is. The countries GeoDataFrame contains the countries boundaries and names in the `name` column.\"\"\"\n    for i, row in countries.iterrows():\n        if point.within(row.geometry):\n            return row.name\n    return None\n\ndef check_country_from_coords(lat: float, lon: float, countries: gpd.GeoDataFrame) -> str:\n    \"\"\"Check in which country a point is. The countries GeoDataFrame contains the countries boundaries and names in the `name` column.\"\"\"\n    point = shapely.geometry.Point(lon, lat)\n    return check_country(point, countries)\n\ndef check_country_from_gdf(gdf: gpd.GeoDataFrame, countries: gpd.GeoDataFrame) -> gpd.GeoDataFrame:\n    \"\"\"Check in which country a point is. The countries GeoDataFrame contains the countries boundaries and names in the `name` column.\"\"\"\n    gdf[\"country\"] =", "13.2.4_sanitized": "import geopandas as gpd\nimport shapely\n\ndef check_country(point: shapely.geometry.Point, countries: gpd.GeoDataFrame) -> str:\n    \"\"\"Check in which country a point is. The countries GeoDataFrame contains the countries boundaries and names in the `name` column.\"\"\"\n    for i, row in countries.iterrows():\n        if point.within(row.geometry):\n            return row.name\n    return None\n", "13.2.5_prompt": "import shapely\n\ndef check_country(point: shapely.geometry.Point, countries: str) -> str:\n    \"\"\"Check in which country a point is. The countries is the path to the shapefile with countries boundaries with `name` feature.\"\"\"", "13.2.5_generated": "import shapely\n\ndef check_country(point: shapely.geometry.Point, countries: str) -> str:\n    \"\"\"Check in which country a point is. The countries is the path to the shapefile with countries boundaries with `name` feature.\"\"\"\n    import geopandas as gpd\n    import shapely\n    import pandas as pd\n    import os\n    import numpy as np\n\n    countries = gpd.read_file(countries)\n    countries.set_index('name', inplace=True)\n    countries.sort_values(by='name', inplace=True)\n    countries.drop('geometry', axis=1, inplace=True)\n    countries.reset_index(inplace=True)\n    countries.rename(columns={'index': 'name'}, inplace=True)\n    countries['name'] = countries['name'].str.lower()\n    countries['name'] = countries['name'].str.replace(' ', '_')\n    countries['name'] = countries['name'].str.replace('-', '_')\n    countries['name'] = countries['name'].str.replace('(', '_')\n   ", "13.2.5_sanitized": "", "13.2.6_prompt": "import shapely\n\ndef check_country(point: shapely.geometry.Point, countries: str) -> str:\n    \"\"\"Check in which country a point is. The countries is the path to the geojson with countries boundaries with `name` feature.\"\"\"", "13.2.6_generated": "import shapely\n\ndef check_country(point: shapely.geometry.Point, countries: str) -> str:\n    \"\"\"Check in which country a point is. The countries is the path to the geojson with countries boundaries with `name` feature.\"\"\"\n    with open(countries) as f:\n        countries = json.load(f)\n    for country in countries['features']:\n        if point.within(shapely.geometry.shape(country['geometry'])):\n            return country['properties']['name']\n    return ''\n\ndef check_country_in_df(df: pd.DataFrame, countries: str) -> pd.DataFrame:\n    \"\"\"Check in which country a point is. The countries is the path to the geojson with countries boundaries with `name` feature.\"\"\"\n    df['country'] = df.apply(lambda row: check_country(row['geometry'], countries), axis=1)\n    return df\n\ndef check_country_in_df_with_multipolygon(df: pd.DataFrame, countries: str) -> pd.DataFrame:\n    \"\"\"Check in which country a point is. The countries is", "13.2.6_sanitized": "import shapely\n\ndef check_country(point: shapely.geometry.Point, countries: str) -> str:\n    \"\"\"Check in which country a point is. The countries is the path to the geojson with countries boundaries with `name` feature.\"\"\"\n    with open(countries) as f:\n        countries = json.load(f)\n    for country in countries['features']:\n        if point.within(shapely.geometry.shape(country['geometry'])):\n            return country['properties']['name']\n    return ''\n", "14.1_prompt": "def check_country(lat: float, lon: float) -> str:\n    \"\"\"Check in which country a point is. Use the osmnx to perform geocoding to find country name.\"\"\"", "14.1_generated": "def check_country(lat: float, lon: float) -> str:\n    \"\"\"Check in which country a point is. Use the osmnx to perform geocoding to find country name.\"\"\"\n    import osmnx as ox\n    import pandas as pd\n    import geopandas as gpd\n    from shapely.geometry import Point\n\n    # Get the country name\n    country = ox.geocode_to_gdf(f\"{lat}, {lon}\", which_result=1, geocoder=\"nominatim\")\n    country = country.iloc[0][\"country\"]\n\n    return country\n\n\ndef get_country_code(country: str) -> str:\n    \"\"\"Get the country code from the country name.\"\"\"\n    import pandas as pd\n\n    # Get the country code\n    country_code = pd.read_csv(\"data/country_code.csv\")\n    country_code = country_code[country_code[\"country\"] == country][\"country_code\"].iloc[0]\n\n    return country_code\n\n\n", "14.1_sanitized": "def check_country(lat: float, lon: float) -> str:\n    \"\"\"Check in which country a point is. Use the osmnx to perform geocoding to find country name.\"\"\"\n    import osmnx as ox\n    import pandas as pd\n    import geopandas as gpd\n    from shapely.geometry import Point\n\n    # Get the country name\n    country = ox.geocode_to_gdf(f\"{lat}, {lon}\", which_result=1, geocoder=\"nominatim\")\n    country = country.iloc[0][\"country\"]\n\n    return country\n\n", "14.2_prompt": "import shapely\n\ndef check_country(point: shapely.geometry.Point) -> str:\n    \"\"\"Check in which country a point is. Use the osmnx to perform geocoding to find country name.\"\"\"", "14.2_generated": "import shapely\n\ndef check_country(point: shapely.geometry.Point) -> str:\n    \"\"\"Check in which country a point is. Use the osmnx to perform geocoding to find country name.\"\"\"\n    from osmnx import geocoder\n    country = geocoder.geocode_osm(point.y, point.x)\n    return country.get('country')\n\ndef check_country_from_coords(lat: float, long: float) -> str:\n    \"\"\"Check in which country a point is. Use the osmnx to perform geocoding to find country name.\"\"\"\n    from osmnx import geocoder\n    country = geocoder.geocode_osm(lat, long)\n    return country.get('country')\n\ndef check_country_from_coords_list(lat_long_list: list) -> list:\n    \"\"\"Check in which country a point is. Use the osmnx to perform geocoding to find country name.\"\"\"\n    from osmnx import geocoder\n    country_list = []\n    for", "14.2_sanitized": "import shapely\n\ndef check_country(point: shapely.geometry.Point) -> str:\n    \"\"\"Check in which country a point is. Use the osmnx to perform geocoding to find country name.\"\"\"\n    from osmnx import geocoder\n    country = geocoder.geocode_osm(point.y, point.x)\n    return country.get('country')\n", "15.1_prompt": "def check_country(lat: float, lon: float, country: str) -> bool:\n    \"\"\"Check if a point lies within the given country. Use the osmnx to perform geocoding.\"\"\"", "15.1_generated": "def check_country(lat: float, lon: float, country: str) -> bool:\n    \"\"\"Check if a point lies within the given country. Use the osmnx to perform geocoding.\"\"\"\n    from osmnx import geocoder_to_gdf\n\n    gdf = geocoder_to_gdf(country)\n    return gdf.contains(Point(lon, lat)).iloc[0]\n\n\ndef check_country_from_name(country_name: str) -> bool:\n    \"\"\"Check if a point lies within the given country. Use the osmnx to perform geocoding.\"\"\"\n    from osmnx import geocoder_to_gdf\n\n    gdf = geocoder_to_gdf(country_name)\n    return gdf.contains(Point(lon, lat)).iloc[0]\n\n\ndef check_country_from_name_and_coord(country_name: str, lat: float, lon: float) -> bool:\n    \"\"\"Check if a point lies within the given country. Use the os", "15.1_sanitized": "def check_country(lat: float, lon: float, country: str) -> bool:\n    \"\"\"Check if a point lies within the given country. Use the osmnx to perform geocoding.\"\"\"\n    from osmnx import geocoder_to_gdf\n\n    gdf = geocoder_to_gdf(country)\n    return gdf.contains(Point(lon, lat)).iloc[0]\n\n", "15.2_prompt": "import shapely\n\ndef check_country(point: shapely.geometry.Point, country: str) -> bool:\n    \"\"\"Check if a point lies within the given country. Use the osmnx to perform geocoding.\"\"\"", "15.2_generated": "import shapely\n\ndef check_country(point: shapely.geometry.Point, country: str) -> bool:\n    \"\"\"Check if a point lies within the given country. Use the osmnx to perform geocoding.\"\"\"\n    from osmnx import geocoding\n    from shapely.geometry import Point\n\n    # Get the country's boundary\n    country_boundary = geocoding.geocode_to_gdf(country, by_osmid=True)\n\n    # Check if the point lies within the country's boundary\n    return country_boundary.contains(Point(point.x, point.y))\n\ndef check_country_polygon(polygon: shapely.geometry.Polygon, country: str) -> bool:\n    \"\"\"Check if a polygon lies within the given country. Use the osmnx to perform geocoding.\"\"\"\n    from osmnx import geocoding\n    from shapely.geometry import Point\n\n    # Get the country's boundary\n    country_boundary = geocoding.geocode_to_gdf(country, by_", "15.2_sanitized": "import shapely\n\ndef check_country(point: shapely.geometry.Point, country: str) -> bool:\n    \"\"\"Check if a point lies within the given country. Use the osmnx to perform geocoding.\"\"\"\n    from osmnx import geocoding\n    from shapely.geometry import Point\n\n    # Get the country's boundary\n    country_boundary = geocoding.geocode_to_gdf(country, by_osmid=True)\n\n    # Check if the point lies within the country's boundary", "16.1_prompt": "import geopandas as gpd\n\ndef trajectory_length(trajectory: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the length of a trajectory. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"", "16.1_generated": "import geopandas as gpd\n\ndef trajectory_length(trajectory: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the length of a trajectory. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    return trajectory.geometry.length\n\ndef trajectory_duration(trajectory: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the duration of a trajectory. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    return trajectory.t.max() - trajectory.t.min()\n\ndef trajectory_max_speed(trajectory: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the maximum speed of a trajectory. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    return trajectory.velocity.max()\n\ndef trajectory_min_speed(trajectory", "16.1_sanitized": "import geopandas as gpd\n\ndef trajectory_length(trajectory: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the length of a trajectory. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    return trajectory.geometry.length\n", "16.3_prompt": "def trajectory_length(trajectory: str) -> float:\n    \"\"\"Calculate the length of a trajectory. It is saved in a geojson as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"", "16.3_generated": "def trajectory_length(trajectory: str) -> float:\n    \"\"\"Calculate the length of a trajectory. It is saved in a geojson as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    import movingpandas as mpd\n    import pandas as pd\n    df = pd.read_csv(trajectory)\n    df['geometry'] = df.apply(lambda row: Point(row.x, row.y), axis=1)\n    df = df.drop(columns=['x', 'y'])\n    gdf = mpd.GeoDataFrame(df, geometry='geometry', crs={'init': 'epsg:4326'})\n    gdf.set_index('t', inplace=True)\n    gdf.index = pd.to_datetime(gdf.index)\n    gdf.index.name = 't'\n    gdf.sort_index(inplace=True)\n    gdf.crs = {'init': 'epsg:4326'}\n    gdf = gdf.to_crs({'", "16.3_sanitized": "", "16.4_prompt": "import geopandas as gpd\n\ndef walk_length(trip: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the length of a walk. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"", "16.4_generated": "import geopandas as gpd\n\ndef walk_length(trip: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the length of a walk. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    return 0\n\ndef bike_length(trip: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the length of a bike ride. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    return 0\n\ndef bike_time(trip: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the time of a bike ride. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    return 0\n\ndef bike_speed(trip: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the speed of a bike ride. It is saved in a", "16.4_sanitized": "import geopandas as gpd\n\ndef walk_length(trip: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the length of a walk. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    return 0\n", "16.6_prompt": "def walk_length(trip: str) -> float:\n    \"\"\"Calculate the length of a walk. It is saved in a geojson as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"", "16.6_generated": "def walk_length(trip: str) -> float:\n    \"\"\"Calculate the length of a walk. It is saved in a geojson as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    import movingpandas\n    import pandas as pd\n    import numpy as np\n    import geopandas as gpd\n    from shapely.geometry import Point\n    from datetime import datetime\n    from dateutil.parser import parse\n    from movingpandas.trajectory import Trajectory\n    from movingpandas.trajectories import Trajectories\n    from movingpandas.trajectory_utils import get_trajectory\n\n    df = gpd.GeoDataFrame(pd.read_csv(trip))\n    df['geometry'] = df.apply(lambda row: Point(row.geometry), axis=1)\n    df['t'] = df.apply(lambda row: parse(row.t), axis=1)\n    df = df.set_index('t')\n    df = df.sort_index()\n    df = df.drop(['geometry', 't'], axis=", "16.6_sanitized": "", "17.1_prompt": "import geopandas as gpd\n\ndef trajectory_duration(trajectory: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the duration of a trajectory in seconds. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"", "17.1_generated": "import geopandas as gpd\n\ndef trajectory_duration(trajectory: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the duration of a trajectory in seconds. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    return trajectory.geometry.length / trajectory.t.mean()\n\ndef trajectory_distance(trajectory: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the distance of a trajectory in meters. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    return trajectory.geometry.length\n\ndef trajectory_speed(trajectory: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the average speed of a trajectory in meters/second. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    return trajectory.geometry.length / trajectory.t.mean()\n\ndef traject", "17.1_sanitized": "import geopandas as gpd\n\ndef trajectory_duration(trajectory: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the duration of a trajectory in seconds. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    return trajectory.geometry.length / trajectory.t.mean()\n", "17.3_prompt": "def trajectory_duration(trajectory: str) -> float:\n    \"\"\"Calculate the duration of a trajectory in seconds. It is saved in a geojson as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"", "17.3_generated": "def trajectory_duration(trajectory: str) -> float:\n    \"\"\"Calculate the duration of a trajectory in seconds. It is saved in a geojson as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    import movingpandas as mpd\n    import pandas as pd\n    df = pd.read_csv(trajectory)\n    df['geometry'] = df.apply(lambda row: Point(row.lon, row.lat), axis=1)\n    df['t'] = pd.to_datetime(df.t)\n    df = df.set_index('t')\n    df = df.drop(['lon', 'lat'], axis=1)\n    df = df.sort_index()\n    df = mpd.Trajectory(df, 0.1)\n    return df.get_length() / 1000\n\n\ndef trajectory_length(trajectory: str) -> float:\n    \"\"\"Calculate the length of a trajectory in meters. It is saved in a geojson as a collection of points and timestamps in the `geometry` and", "17.3_sanitized": "def trajectory_duration(trajectory: str) -> float:\n    \"\"\"Calculate the duration of a trajectory in seconds. It is saved in a geojson as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    import movingpandas as mpd\n    import pandas as pd\n    df = pd.read_csv(trajectory)\n    df['geometry'] = df.apply(lambda row: Point(row.lon, row.lat), axis=1)\n    df['t'] = pd.to_datetime(df.t)\n    df = df.set_index('t')\n    df = df.drop(['lon', 'lat'], axis=1)\n    df = df.sort_index()\n    df = mpd.Trajectory(df, 0.1)", "17.4_prompt": "import geopandas as gpd\n\ndef walk_duration(trip: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the duration of a walk in seconds. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"", "17.4_generated": "import geopandas as gpd\n\ndef walk_duration(trip: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the duration of a walk in seconds. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    return 0\n\ndef bike_duration(trip: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the duration of a bike trip in seconds. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    return 0\n\ndef car_duration(trip: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the duration of a car trip in seconds. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    return 0\n\ndef public_transport_duration(trip: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the duration of a public transport trip in seconds.", "17.4_sanitized": "import geopandas as gpd\n\ndef walk_duration(trip: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the duration of a walk in seconds. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    return 0\n", "17.6_prompt": "def walk_duration(trip: str) -> float:\n    \"\"\"Calculate the duration of a walk in seconds. It is saved in a geojson as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"", "17.6_generated": "def walk_duration(trip: str) -> float:\n    \"\"\"Calculate the duration of a walk in seconds. It is saved in a geojson as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    import movingpandas as mpd\n    import pandas as pd\n    import numpy as np\n    from shapely.geometry import LineString\n\n    df = pd.read_csv(trip)\n    df[\"geometry\"] = df.apply(lambda row: LineString(np.column_stack([row.t, row.x])), axis=1)\n    gdf = mpd.GeoDataFrame(df, geometry=\"geometry\", crs=\"EPSG:4326\")\n    gdf.set_index(\"t\", inplace=True)\n    gdf.index = pd.to_datetime(gdf.index)\n    gdf.index.name = \"datetime\"\n    gdf.sort_index(inplace=True)\n    gdf.to_csv(\"trip.csv\")\n    return gdf.as_trip(name=\"trip", "17.6_sanitized": "def walk_duration(trip: str) -> float:\n    \"\"\"Calculate the duration of a walk in seconds. It is saved in a geojson as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    import movingpandas as mpd\n    import pandas as pd\n    import numpy as np\n    from shapely.geometry import LineString\n\n    df = pd.read_csv(trip)\n    df[\"geometry\"] = df.apply(lambda row: LineString(np.column_stack([row.t, row.x])), axis=1)\n    gdf = mpd.GeoDataFrame(df, geometry=\"geometry\", crs=\"EPSG:4326\")\n    gdf.set_index(\"t\", inplace=True)\n    gdf.index = pd.to_datetime(gdf.index)\n    gdf.index.name = \"datetime\"\n    gdf.sort_index(inplace=True)\n    gdf.to_csv(\"trip.csv\")", "18.1_prompt": "import geopandas as gpd\n\ndef average_speed(trajectory: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the average speed of a trajectory in meters per second. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"", "18.1_generated": "import geopandas as gpd\n\ndef average_speed(trajectory: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the average speed of a trajectory in meters per second. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    raise NotImplementedError\n\ndef average_speed_kmh(trajectory: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the average speed of a trajectory in kilometers per hour. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    raise NotImplementedError\n\ndef average_speed_mph(trajectory: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the average speed of a trajectory in miles per hour. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    raise NotImplementedError\n\ndef average_speed_mps(trajectory: g", "18.1_sanitized": "", "18.3_prompt": "def average_speed(trajectory: str) -> float:\n    \"\"\"Calculate the average speed of a trajectory in meters per second. It is saved in a geojson as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"", "18.3_generated": "def average_speed(trajectory: str) -> float:\n    \"\"\"Calculate the average speed of a trajectory in meters per second. It is saved in a geojson as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    import movingpandas\n    import pandas as pd\n    df = pd.read_csv(trajectory)\n    gdf = movingpandas.TrajectoryDataFrame(df, t='t', geometry_column='geometry')\n    return gdf.trajectory_speed.mean()\n\n\ndef average_speed_by_day(trajectory: str) -> pd.DataFrame:\n    \"\"\"Calculate the average speed of a trajectory in meters per second. It is saved in a geojson as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library. Return a dataframe with the average speed by day.\"\"\"\n    import movingpandas\n    import pandas as pd\n    df = pd.read_csv(trajectory)\n    gdf = movingpandas.TrajectoryDataFrame(df, t='t', geometry_column='", "18.3_sanitized": "def average_speed(trajectory: str) -> float:\n    \"\"\"Calculate the average speed of a trajectory in meters per second. It is saved in a geojson as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    import movingpandas\n    import pandas as pd\n    df = pd.read_csv(trajectory)\n    gdf = movingpandas.TrajectoryDataFrame(df, t='t', geometry_column='geometry')", "18.4_prompt": "import geopandas as gpd\n\ndef average_walk_speed(trip: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the average speed of a walk in meters per second. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"", "18.4_generated": "import geopandas as gpd\n\ndef average_walk_speed(trip: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the average speed of a walk in meters per second. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    raise NotImplementedError\n\ndef average_bike_speed(trip: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the average speed of a bike in meters per second. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    raise NotImplementedError\n\ndef average_car_speed(trip: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the average speed of a car in meters per second. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    raise NotImplementedError\n\ndef average_transit_speed(trip: gpd.GeoDataFrame)", "18.4_sanitized": "", "18.6_prompt": "def average_walk_speed(trip: str) -> float:\n    \"\"\"Calculate the average speed of a walk in meters per second. It is saved in a geojson as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"", "18.6_generated": "def average_walk_speed(trip: str) -> float:\n    \"\"\"Calculate the average speed of a walk in meters per second. It is saved in a geojson as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    # Import movingpandas\n    import movingpandas as mpd\n\n    # Read the file\n    gdf = mpd.read_postgis(trip, \"postgresql://postgres:testpassword@localhost:5432/postgis_learn\")\n\n    # Calculate the average speed\n    return gdf.mp_agg.average_speed().iloc[0]\n\n\ndef average_walk_speed_pandas(trip: str) -> float:\n    \"\"\"Calculate the average speed of a walk in meters per second. It is saved in a geojson as a collection of points and timestamps in the `geometry` and `t` columns. Use the `pandas` library.\"\"\"\n    # Import pandas\n    import pandas as pd\n\n    # Read the file\n    gdf = pd.read_file(trip)\n\n    # Calculate the", "18.6_sanitized": "def average_walk_speed(trip: str) -> float:\n    \"\"\"Calculate the average speed of a walk in meters per second. It is saved in a geojson as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    # Import movingpandas\n    import movingpandas as mpd\n\n    # Read the file\n    gdf = mpd.read_postgis(trip, \"postgresql://postgres:testpassword@localhost:5432/postgis_learn\")\n\n    # Calculate the average speed\n    return gdf.mp_agg.average_speed().iloc[0]\n\n", "19.1_prompt": "def geocode_city(city: str) -> Polygon:\n    \"\"\"Geocode a city to get its boundaries. Use the osmnx to perform geocoding.\"\"\"", "19.1_generated": "def geocode_city(city: str) -> Polygon:\n    \"\"\"Geocode a city to get its boundaries. Use the osmnx to perform geocoding.\"\"\"\n    gdf = ox.geocoder.geocode_to_gdf(city)\n    return gdf.geometry.iloc[0]\n\n\ndef geocode_address(address: str) -> Polygon:\n    \"\"\"Geocode an address to get its boundaries. Use the osmnx to perform geocoding.\"\"\"\n    gdf = ox.geocoder.geocode_to_gdf(address)\n    return gdf.geometry.iloc[0]\n\n\ndef geocode_place(place: str) -> Polygon:\n    \"\"\"Geocode a place to get its boundaries. Use the osmnx to perform geocoding.\"\"\"\n    gdf = ox.geocoder.geocode_to_gdf(place)\n    return gdf.geometry.iloc[0]\n\n\ndef geocode_postcode(post", "19.1_sanitized": "def geocode_city(city: str) -> Polygon:\n    \"\"\"Geocode a city to get its boundaries. Use the osmnx to perform geocoding.\"\"\"\n    gdf = ox.geocoder.geocode_to_gdf(city)\n    return gdf.geometry.iloc[0]\n\n", "20.1_prompt": "def geocode_city(city: str) -> Point:\n    \"\"\"Geocode a city ant get its center point. Use the osmnx to perform geocoding.\"\"\"", "20.1_generated": "def geocode_city(city: str) -> Point:\n    \"\"\"Geocode a city ant get its center point. Use the osmnx to perform geocoding.\"\"\"\n    gdf = ox.geocoder.geocode(city)\n    return gdf.iloc[0].geometry.centroid\n\n\ndef geocode_address(address: str) -> Point:\n    \"\"\"Geocode an address ant get its center point. Use the osmnx to perform geocoding.\"\"\"\n    gdf = ox.geocoder.geocode(address)\n    return gdf.iloc[0].geometry.centroid\n\n\ndef geocode_place(place: str) -> Point:\n    \"\"\"Geocode a place ant get its center point. Use the osmnx to perform geocoding.\"\"\"\n    gdf = ox.geocoder.geocode(place)\n    return gdf.iloc[0].geometry.centroid\n\n\ndef geocode_postcode(postcode: str) -> Point:\n   ", "20.1_sanitized": "def geocode_city(city: str) -> Point:\n    \"\"\"Geocode a city ant get its center point. Use the osmnx to perform geocoding.\"\"\"\n    gdf = ox.geocoder.geocode(city)\n    return gdf.iloc[0].geometry.centroid\n\n"}