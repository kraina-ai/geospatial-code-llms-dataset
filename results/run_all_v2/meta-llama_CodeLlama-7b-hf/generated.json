{"1.1_prompt": "import geopandas as gpd\n\ndef mean_area(polygons: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate mean area of the polygons in a geodataframe\"\"\"", "1.1_generated": "import geopandas as gpd\n\ndef mean_area(polygons: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate mean area of the polygons in a geodataframe\"\"\"\n    return polygons.area.mean()\n\ndef mean_length(lines: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate mean length of the lines in a geodataframe\"\"\"\n    return lines.length.mean()\n\ndef mean_distance(points: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate mean distance between points in a geodataframe\"\"\"\n    return points.distance.mean()\n\ndef mean_distance_to_line(points: gpd.GeoDataFrame, lines: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate mean distance between points and lines in a geodataframe\"\"\"\n    return points.distance(lines).mean()\n\ndef mean_distance_to_polygon(points: gpd.GeoDataFrame, polygons: gpd.GeoDataFrame) -> float:\n", "1.1_sanitized": "import geopandas as gpd\n\ndef mean_area(polygons: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate mean area of the polygons in a geodataframe\"\"\"\n    return polygons.area.mean()\n", "1.2_prompt": "def mean_area(filename: str) -> float:\n    \"\"\"Calculate mean area of the polygons in a shapefile\"\"\"", "1.2_generated": "def mean_area(filename: str) -> float:\n    \"\"\"Calculate mean area of the polygons in a shapefile\"\"\"\n    with fiona.open(filename) as f:\n        return statistics.mean([poly[\"properties\"][\"AREA\"] for poly in f])\n\n\ndef mean_area_by_year(filename: str) -> dict:\n    \"\"\"Calculate mean area of the polygons in a shapefile by year\"\"\"\n    with fiona.open(filename) as f:\n        return {\n            poly[\"properties\"][\"YEAR\"]: poly[\"properties\"][\"AREA\"]\n            for poly in f\n        }\n\n\ndef mean_area_by_year_and_type(filename: str) -> dict:\n    \"\"\"Calculate mean area of the polygons in a shapefile by year and type\"\"\"\n    with fiona.open(filename) as f:\n        return {\n            (poly[\"properties\"][\"YEAR\"], poly[\"properties\"][\"TYPE\"]):", "1.2_sanitized": "def mean_area(filename: str) -> float:\n    \"\"\"Calculate mean area of the polygons in a shapefile\"\"\"\n    with fiona.open(filename) as f:\n        return statistics.mean([poly[\"properties\"][\"AREA\"] for poly in f])\n\n", "1.3_prompt": "def mean_area(filename: str) -> float:\n    \"\"\"Calculate mean area of the polygons in a geojson file\"\"\"", "1.3_generated": "def mean_area(filename: str) -> float:\n    \"\"\"Calculate mean area of the polygons in a geojson file\"\"\"\n    with open(filename) as f:\n        data = json.load(f)\n    return sum(p[\"properties\"][\"area\"] for p in data[\"features\"]) / len(data[\"features\"])\n\n\ndef mean_area_of_polygons(filename: str) -> float:\n    \"\"\"Calculate mean area of the polygons in a geojson file\"\"\"\n    with open(filename) as f:\n        data = json.load(f)\n    return sum(p[\"properties\"][\"area\"] for p in data[\"features\"]) / len(data[\"features\"])\n\n\ndef mean_area_of_polygons_with_properties(filename: str) -> float:\n    \"\"\"Calculate mean area of the polygons in a geojson file\"\"\"\n    with open(filename) as f:\n        data = json.load(f)\n   ", "1.3_sanitized": "def mean_area(filename: str) -> float:\n    \"\"\"Calculate mean area of the polygons in a geojson file\"\"\"\n    with open(filename) as f:\n        data = json.load(f)\n    return sum(p[\"properties\"][\"area\"] for p in data[\"features\"]) / len(data[\"features\"])\n\n", "1.4_prompt": "import geopandas as gpd\n\ndef buildings_area(building_gdf: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate mean area of the buildings in a geodataframe\"\"\"", "1.4_generated": "import geopandas as gpd\n\ndef buildings_area(building_gdf: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate mean area of the buildings in a geodataframe\"\"\"\n    return building_gdf.area.mean()\n\ndef buildings_per_area(building_gdf: gpd.GeoDataFrame, area: float) -> float:\n    \"\"\"Calculate mean number of buildings per area\"\"\"\n    return building_gdf.area.mean() / area\n\ndef buildings_per_area_per_building(building_gdf: gpd.GeoDataFrame, area: float) -> float:\n    \"\"\"Calculate mean number of buildings per area per building\"\"\"\n    return building_gdf.area.mean() / area / building_gdf.area.mean()\n\ndef buildings_per_area_per_building_per_area(building_gdf: gpd.GeoDataFrame, area: float) -> float:\n    \"\"\"Calculate mean number of buildings per area per building per area\"\"\"\n    return building_gdf.area", "1.4_sanitized": "import geopandas as gpd\n\ndef buildings_area(building_gdf: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate mean area of the buildings in a geodataframe\"\"\"\n    return building_gdf.area.mean()\n", "1.5_prompt": "def buildings_area(building_file: str) -> float:\n    \"\"\"Calculate mean area of the buildings in a shapefile\"\"\"", "1.5_generated": "def buildings_area(building_file: str) -> float:\n    \"\"\"Calculate mean area of the buildings in a shapefile\"\"\"\n    buildings = gpd.read_file(building_file)\n    return buildings.area.mean()\n\n\ndef buildings_per_km2(building_file: str) -> float:\n    \"\"\"Calculate mean number of buildings per km2 of the buildings in a shapefile\"\"\"\n    buildings = gpd.read_file(building_file)\n    return buildings.area.sum() / buildings.area.mean()\n\n\ndef buildings_per_km2_with_buffer(building_file: str, buffer_distance: float) -> float:\n    \"\"\"Calculate mean number of buildings per km2 of the buildings in a shapefile\"\"\"\n    buildings = gpd.read_file(building_file)\n    buildings_buffer = buildings.buffer(buffer_distance)\n    return buildings_buffer.area.sum() / buildings_buffer.area.mean()\n\n\ndef", "1.5_sanitized": "def buildings_area(building_file: str) -> float:\n    \"\"\"Calculate mean area of the buildings in a shapefile\"\"\"\n    buildings = gpd.read_file(building_file)\n    return buildings.area.mean()\n\n", "1.6_prompt": "def buildings_area(building_file: str) -> float:\n    \"\"\"Calculate mean area of the buildings in a geojson file\"\"\"", "1.6_generated": "def buildings_area(building_file: str) -> float:\n    \"\"\"Calculate mean area of the buildings in a geojson file\"\"\"\n    with open(building_file) as f:\n        data = json.load(f)\n    area = 0\n    for feature in data['features']:\n        area += feature['properties']['area']\n    return area / len(data['features'])\n\n\ndef buildings_per_area(building_file: str) -> float:\n    \"\"\"Calculate mean number of buildings per area in a geojson file\"\"\"\n    with open(building_file) as f:\n        data = json.load(f)\n    area = 0\n    for feature in data['features']:\n        area += feature['properties']['area']\n    return len(data['features']) / area\n\n\ndef buildings_per_area_and_height(building_file: str) -> float:\n    \"\"\"Calculate mean number of buildings per area and height in a geojson file\"\"\"", "1.6_sanitized": "def buildings_area(building_file: str) -> float:\n    \"\"\"Calculate mean area of the buildings in a geojson file\"\"\"\n    with open(building_file) as f:\n        data = json.load(f)\n    area = 0\n    for feature in data['features']:\n        area += feature['properties']['area']\n    return area / len(data['features'])\n\n", "2.1_prompt": "import geopandas as gpd\n\ndef mean_intersection_area(first: gpd.GeoDataFrame, second: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the mean intersection ratio of polygons. Both arguments are geodataframes.\"\"\"", "2.1_generated": "import geopandas as gpd\n\ndef mean_intersection_area(first: gpd.GeoDataFrame, second: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the mean intersection ratio of polygons. Both arguments are geodataframes.\"\"\"\n    return (first.intersection(second)).area.mean() / (first.area.mean() + second.area.mean())\n\ndef mean_intersection_area_with_buffer(first: gpd.GeoDataFrame, second: gpd.GeoDataFrame, buffer_size: float) -> float:\n    \"\"\"Calculate the mean intersection ratio of polygons. Both arguments are geodataframes.\"\"\"\n    return (first.intersection(second.buffer(buffer_size))).area.mean() / (first.area.mean() + second.area.mean())\n\ndef mean_intersection_area_with_buffer_and_buffer_size(first: gpd.GeoDataFrame, second: gpd.GeoDataFrame, buffer_size: float) -> float:\n    \"\"\"Calculate the mean intersection ratio of polygons. Both arguments are geodataframes.\"", "2.1_sanitized": "import geopandas as gpd\n\ndef mean_intersection_area(first: gpd.GeoDataFrame, second: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the mean intersection ratio of polygons. Both arguments are geodataframes.\"\"\"\n    return (first.intersection(second)).area.mean() / (first.area.mean() + second.area.mean())\n", "2.2_prompt": "def mean_intersection_area(first_filename: str, second_filename: str) -> float:\n    \"\"\"Calculate the mean intersection ratio of polygons. Both arguments are shapefiles.\"\"\"", "2.2_generated": "def mean_intersection_area(first_filename: str, second_filename: str) -> float:\n    \"\"\"Calculate the mean intersection ratio of polygons. Both arguments are shapefiles.\"\"\"\n    first_shp = gpd.read_file(first_filename)\n    second_shp = gpd.read_file(second_filename)\n\n    first_shp_area = first_shp.area\n    second_shp_area = second_shp.area\n\n    first_shp_area_sum = first_shp_area.sum()\n    second_shp_area_sum = second_shp_area.sum()\n\n    first_shp_area_sum_square = first_shp_area_sum ** 2\n    second_shp_area_sum_square = second_shp_area_sum ** 2\n\n    first_shp_area_sum_square_square = first_shp_area_sum_square ** 2\n    second_shp_area_sum_square_square", "2.2_sanitized": "", "2.3_prompt": "def mean_intersection_area(first_filename: str, second_filename: str) -> float:\n    \"\"\"Calculate the mean intersection ratio of polygons. Both arguments are geojson files.\"\"\"", "2.3_generated": "def mean_intersection_area(first_filename: str, second_filename: str) -> float:\n    \"\"\"Calculate the mean intersection ratio of polygons. Both arguments are geojson files.\"\"\"\n    first_polygons = load_polygons(first_filename)\n    second_polygons = load_polygons(second_filename)\n    return mean_intersection_area_from_polygons(first_polygons, second_polygons)\n\n\ndef mean_intersection_area_from_polygons(first_polygons: List[Polygon], second_polygons: List[Polygon]) -> float:\n    \"\"\"Calculate the mean intersection ratio of polygons.\"\"\"\n    intersections = [\n        intersection_area(first_polygon, second_polygon)\n        for first_polygon in first_polygons\n        for second_polygon in second_polygons\n    ]\n    return sum(intersections) / len(intersections)\n\n\ndef intersection_area(first_polygon: Pol", "2.3_sanitized": "def mean_intersection_area(first_filename: str, second_filename: str) -> float:\n    \"\"\"Calculate the mean intersection ratio of polygons. Both arguments are geojson files.\"\"\"\n    first_polygons = load_polygons(first_filename)\n    second_polygons = load_polygons(second_filename)\n    return mean_intersection_area_from_polygons(first_polygons, second_polygons)\n\n", "2.4_prompt": "import geopandas as gpd\n\ndef building_to_parcel_ratio(buildings_gdf: gpd.GeoDataFrame, parcels_gdf: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the mean ratio of the buliding area compared to the parcel it stands on. Buildings and parcels are in separate geodataframes.\"\"\"", "2.4_generated": "import geopandas as gpd\n\ndef building_to_parcel_ratio(buildings_gdf: gpd.GeoDataFrame, parcels_gdf: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the mean ratio of the buliding area compared to the parcel it stands on. Buildings and parcels are in separate geodataframes.\"\"\"\n    # Calculate the ratio of the building area to the parcel area\n    ratio = buildings_gdf.area / parcels_gdf.area\n    # Calculate the mean ratio\n    mean_ratio = ratio.mean()\n    return mean_ratio\n\ndef building_to_parcel_ratio_by_year(buildings_gdf: gpd.GeoDataFrame, parcels_gdf: gpd.GeoDataFrame, year: int) -> float:\n    \"\"\"Calculate the mean ratio of the buliding area compared to the parcel it stands on. Buildings and parcels are in separate geodataframes.\"\"\"\n    # Filter the buildings and parcels to the year\n    buildings_gdf = buildings_gdf[buildings_gdf.year == year]\n    parcels_gdf = parcels_gdf[parcels_gdf", "2.4_sanitized": "import geopandas as gpd\n\ndef building_to_parcel_ratio(buildings_gdf: gpd.GeoDataFrame, parcels_gdf: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the mean ratio of the buliding area compared to the parcel it stands on. Buildings and parcels are in separate geodataframes.\"\"\"\n    # Calculate the ratio of the building area to the parcel area\n    ratio = buildings_gdf.area / parcels_gdf.area\n    # Calculate the mean ratio\n    mean_ratio = ratio.mean()", "2.5_prompt": "def building_to_parcel_ratio(buildings_file: str, parcels_file: str) -> float:\n    \"\"\"Calculate the mean ratio of the buliding area compared to the parcel it stands on. Buildings and parcels are in separate shapefiles.\"\"\"", "2.5_generated": "def building_to_parcel_ratio(buildings_file: str, parcels_file: str) -> float:\n    \"\"\"Calculate the mean ratio of the buliding area compared to the parcel it stands on. Buildings and parcels are in separate shapefiles.\"\"\"\n    buildings = gpd.read_file(buildings_file)\n    parcels = gpd.read_file(parcels_file)\n    buildings_area = buildings.area\n    parcels_area = parcels.area\n    ratio = buildings_area / parcels_area\n    return ratio.mean()\n\n\ndef building_to_parcel_ratio_by_year(buildings_file: str, parcels_file: str, year: int) -> float:\n    \"\"\"Calculate the mean ratio of the buliding area compared to the parcel it stands on. Buildings and parcels are in separate shapefiles.\"\"\"\n    buildings = gpd.read_file(buildings_file)\n    parcels = gpd.read_file(parcels_file)\n    buildings_area = buildings.loc[buildings.year == year].area\n   ", "2.5_sanitized": "def building_to_parcel_ratio(buildings_file: str, parcels_file: str) -> float:\n    \"\"\"Calculate the mean ratio of the buliding area compared to the parcel it stands on. Buildings and parcels are in separate shapefiles.\"\"\"\n    buildings = gpd.read_file(buildings_file)\n    parcels = gpd.read_file(parcels_file)\n    buildings_area = buildings.area\n    parcels_area = parcels.area\n    ratio = buildings_area / parcels_area\n    return ratio.mean()\n\n", "2.6_prompt": "def building_to_parcel_ratio(buildings_file: str, parcels_file: str) -> float:\n    \"\"\"Calculate the mean ratio of the buliding area compared to the parcel it stands on. Buildings and parcels are in separate geojson files.\"\"\"", "2.6_generated": "def building_to_parcel_ratio(buildings_file: str, parcels_file: str) -> float:\n    \"\"\"Calculate the mean ratio of the buliding area compared to the parcel it stands on. Buildings and parcels are in separate geojson files.\"\"\"\n    buildings = gpd.read_file(buildings_file)\n    parcels = gpd.read_file(parcels_file)\n    buildings_area = buildings.area\n    parcels_area = parcels.area\n    ratio = buildings_area / parcels_area\n    return ratio.mean()\n\n\ndef building_to_parcel_ratio_by_year(buildings_file: str, parcels_file: str, year: int) -> float:\n    \"\"\"Calculate the mean ratio of the buliding area compared to the parcel it stands on. Buildings and parcels are in separate geojson files.\"\"\"\n    buildings = gpd.read_file(buildings_file)\n    parcels = gpd.read_file(parcels_file)\n    buildings_area = buildings.loc[buildings.year == year].area", "2.6_sanitized": "def building_to_parcel_ratio(buildings_file: str, parcels_file: str) -> float:\n    \"\"\"Calculate the mean ratio of the buliding area compared to the parcel it stands on. Buildings and parcels are in separate geojson files.\"\"\"\n    buildings = gpd.read_file(buildings_file)\n    parcels = gpd.read_file(parcels_file)\n    buildings_area = buildings.area\n    parcels_area = parcels.area\n    ratio = buildings_area / parcels_area\n    return ratio.mean()\n\n", "3.1_prompt": "import geopandas as gpd\n\ndef points_in_polygons(points_gdf: gpd.GeoDataFrame, polygons_gdf: gpd.GeoDataFrame) -> int:\n    \"\"\"Calculate the number of points that are inside polygons. Points and polygons are stored in GeoDataFrames.\"\"\"", "3.1_generated": "import geopandas as gpd\n\ndef points_in_polygons(points_gdf: gpd.GeoDataFrame, polygons_gdf: gpd.GeoDataFrame) -> int:\n    \"\"\"Calculate the number of points that are inside polygons. Points and polygons are stored in GeoDataFrames.\"\"\"\n    points_gdf = points_gdf.copy()\n    polygons_gdf = polygons_gdf.copy()\n\n    # Check that the points and polygons are in the same CRS\n    if points_gdf.crs != polygons_gdf.crs:\n        raise ValueError(\"Points and polygons must be in the same CRS\")\n\n    # Check that the points and polygons have the same geometry type\n    if points_gdf.geometry.type != polygons_gdf.geometry.type:\n        raise ValueError(\"Points and polygons must have the same geometry type\")\n\n    # Check that the points and polygons have the same geometry type\n    if points_gdf.geometry.type != \"Point\":\n        raise ValueError(\"Points and polygons must have geometry type 'Point'\")\n", "3.1_sanitized": "", "3.2_prompt": "def points_in_polygons(points: str, polygons: str) -> int:\n    \"\"\"Calculate the number of points that are inside polygons. Points and polygons are stored in shapefiles.\"\"\"", "3.2_generated": "def points_in_polygons(points: str, polygons: str) -> int:\n    \"\"\"Calculate the number of points that are inside polygons. Points and polygons are stored in shapefiles.\"\"\"\n    points_shp = gpd.read_file(points)\n    polygons_shp = gpd.read_file(polygons)\n    points_shp = points_shp.to_crs(epsg=4326)\n    polygons_shp = polygons_shp.to_crs(epsg=4326)\n    points_shp = points_shp.to_crs(epsg=3857)\n    polygons_shp = polygons_shp.to_crs(epsg=3857)\n    points_shp = points_shp.to_crs(epsg=4326)\n    polygons_shp = polygons_shp.to_crs(epsg=4326)\n   ", "3.2_sanitized": "", "3.3_prompt": "def points_in_polygons(points: str, polygons: str) -> int:\n    \"\"\"Calculate the number of points that are inside polygons. Points and polygons are stored in geojson files.\"\"\"", "3.3_generated": "def points_in_polygons(points: str, polygons: str) -> int:\n    \"\"\"Calculate the number of points that are inside polygons. Points and polygons are stored in geojson files.\"\"\"\n    points_gdf = gpd.read_file(points)\n    polygons_gdf = gpd.read_file(polygons)\n    points_gdf = points_gdf.to_crs(polygons_gdf.crs)\n    points_gdf = points_gdf.set_geometry('geometry')\n    points_gdf = points_gdf.set_index('id')\n    polygons_gdf = polygons_gdf.set_geometry('geometry')\n    polygons_gdf = polygons_gdf.set_index('id')\n    points_gdf = points_gdf.sindex\n    points_in_polygons = points_gdf.intersection(polygons_gdf)\n    points_in_polygons = points_in_polygons.", "3.3_sanitized": "", "3.4_prompt": "import geopandas as gpd\ndef mean_stations_count(bus_stops: gpd.GeoDataFrames, districts: gpd.GeoDataFrames) -> float:\n    \"\"\"Calculate the mean number of bus stops in a districs. Stations and districts are stored in GeoDataFrames.\"\"\"", "3.4_generated": "import geopandas as gpd\ndef mean_stations_count(bus_stops: gpd.GeoDataFrames, districts: gpd.GeoDataFrames) -> float:\n    \"\"\"Calculate the mean number of bus stops in a districs. Stations and districts are stored in GeoDataFrames.\"\"\"\n    # TODO: Implement the function\n    # Hint: Use the `districts` GeoDataFrame to filter the `bus_stops` GeoDataFrame\n    # Hint: Use the `count` method of the `bus_stops` GeoDataFrame\n    # Hint: Use the `mean` method of the resulting Series\n    # Hint: Use the `loc` method of the `districts` GeoDataFrame\n    # Hint: Use the `count` method of the `districts` GeoDataFrame\n    # Hint: Use the `mean` method of the resulting Series\n    # Hint: Use the `loc` method of the `districts` GeoDataFrame\n    # Hint: Use the `count` method of the `districts` GeoDataFrame\n    # Hint: Use the `mean` method of the resulting Series\n    # H", "3.4_sanitized": "", "3.5_prompt": "def mean_stations_count(bus_stops: str, districts: str) -> float:\n    \"\"\"Calculate the mean number of bus stops in a districs. Stations and districts are stored in shapefiles.\"\"\"", "3.5_generated": "def mean_stations_count(bus_stops: str, districts: str) -> float:\n    \"\"\"Calculate the mean number of bus stops in a districs. Stations and districts are stored in shapefiles.\"\"\"\n    # Load the districts shapefile\n    districts_gdf = gpd.read_file(districts)\n\n    # Load the bus stops shapefile\n    bus_stops_gdf = gpd.read_file(bus_stops)\n\n    # Calculate the mean number of bus stops per district\n    mean_stations_per_district = bus_stops_gdf.groupby('DISTRICT').count()['STATION_ID'].mean()\n\n    return mean_stations_per_district\n\n\ndef mean_stations_count_by_district(bus_stops: str, districts: str) -> pd.DataFrame:\n    \"\"\"Calculate the mean number of bus stops in a districs. Stations and districts are stored in shapefiles.\"\"\"\n    # Load the districts shapefile\n    districts_gdf = gpd.read", "3.5_sanitized": "def mean_stations_count(bus_stops: str, districts: str) -> float:\n    \"\"\"Calculate the mean number of bus stops in a districs. Stations and districts are stored in shapefiles.\"\"\"\n    # Load the districts shapefile\n    districts_gdf = gpd.read_file(districts)\n\n    # Load the bus stops shapefile\n    bus_stops_gdf = gpd.read_file(bus_stops)\n\n    # Calculate the mean number of bus stops per district\n    mean_stations_per_district = bus_stops_gdf.groupby('DISTRICT').count()['STATION_ID'].mean()\n\n    return mean_stations_per_district\n\n", "3.6_prompt": "def mean_stations_count(bus_stops: str, districts: str) -> float:\n    \"\"\"Calculate the mean number of bus stops in a districs. Stations and districts are stored in geojson files.\"\"\"", "3.6_generated": "def mean_stations_count(bus_stops: str, districts: str) -> float:\n    \"\"\"Calculate the mean number of bus stops in a districs. Stations and districts are stored in geojson files.\"\"\"\n    stations = gpd.read_file(bus_stops)\n    districts = gpd.read_file(districts)\n    stations_per_district = stations.groupby(\"district\").count()[\"stop_id\"]\n    stations_per_district = stations_per_district.div(stations_per_district.sum())\n    return stations_per_district.mean()\n\n\ndef mean_stations_count_by_district(bus_stops: str, districts: str) -> pd.Series:\n    \"\"\"Calculate the mean number of bus stops in a districs. Stations and districts are stored in geojson files.\"\"\"\n    stations = gpd.read_file(bus_stops)\n    districts = gpd.read_file(districts)\n    stations_per_district = stations.groupby(\"d", "3.6_sanitized": "def mean_stations_count(bus_stops: str, districts: str) -> float:\n    \"\"\"Calculate the mean number of bus stops in a districs. Stations and districts are stored in geojson files.\"\"\"\n    stations = gpd.read_file(bus_stops)\n    districts = gpd.read_file(districts)\n    stations_per_district = stations.groupby(\"district\").count()[\"stop_id\"]\n    stations_per_district = stations_per_district.div(stations_per_district.sum())", "4.1_prompt": "import geopandas as gpd\n\ndef is_point_present(x: float, y: float, points: gpd.GeoDataFrame) -> bool:\n    \"\"\"Check if a point is present in a list of points stored in a geojson file.\"\"\"", "4.1_generated": "import geopandas as gpd\n\ndef is_point_present(x: float, y: float, points: gpd.GeoDataFrame) -> bool:\n    \"\"\"Check if a point is present in a list of points stored in a geojson file.\"\"\"\n    point = gpd.GeoDataFrame(geometry=[gpd.points_from_xy([x, y])])\n    return point.intersects(points).any()\n\ndef is_point_in_polygon(x: float, y: float, polygon: gpd.GeoDataFrame) -> bool:\n    \"\"\"Check if a point is present in a polygon stored in a geojson file.\"\"\"\n    point = gpd.GeoDataFrame(geometry=[gpd.points_from_xy([x, y])])\n    return point.within(polygon).any()\n\ndef is_point_in_polygons(x: float, y: float, polygons: gpd.GeoDataFrame) -> bool:\n    \"\"\"Check if a point is present in a list of polygons stored in a geojson file.\"\"\"\n    point = gpd.", "4.1_sanitized": "import geopandas as gpd\n\ndef is_point_present(x: float, y: float, points: gpd.GeoDataFrame) -> bool:\n    \"\"\"Check if a point is present in a list of points stored in a geojson file.\"\"\"\n    point = gpd.GeoDataFrame(geometry=[gpd.points_from_xy([x, y])])\n    return point.intersects(points).any()\n", "4.2_prompt": "import geopandas as gpd\n\ndef is_point_present(x: float, y: float, filename: str) -> bool:\n    \"\"\"Check if a point is present in a list of points stored in a shapefile.\"\"\"", "4.2_generated": "import geopandas as gpd\n\ndef is_point_present(x: float, y: float, filename: str) -> bool:\n    \"\"\"Check if a point is present in a list of points stored in a shapefile.\"\"\"\n    points = gpd.read_file(filename)\n    return points.loc[points.geometry.contains(points.geometry.centroid)].empty\n\ndef is_point_present_in_polygon(x: float, y: float, filename: str) -> bool:\n    \"\"\"Check if a point is present in a list of points stored in a shapefile.\"\"\"\n    points = gpd.read_file(filename)\n    return points.loc[points.geometry.contains(points.geometry.centroid)].empty\n\ndef is_point_present_in_polygon_with_buffer(x: float, y: float, filename: str, buffer: float) -> bool:\n    \"\"\"Check if a point is present in a list of points stored in a shapefile.\"\"\"\n    points = gpd.read_file(filename)\n    return points.loc[points.", "4.2_sanitized": "import geopandas as gpd\n\ndef is_point_present(x: float, y: float, filename: str) -> bool:\n    \"\"\"Check if a point is present in a list of points stored in a shapefile.\"\"\"\n    points = gpd.read_file(filename)\n    return points.loc[points.geometry.contains(points.geometry.centroid)].empty\n", "4.3_prompt": "import geopandas as gpd\n\ndef is_point_present(x: float, y: float, filename: str) -> bool:\n    \"\"\"Check if a point is present in a list of points stored in a geojson file.\"\"\"", "4.3_generated": "import geopandas as gpd\n\ndef is_point_present(x: float, y: float, filename: str) -> bool:\n    \"\"\"Check if a point is present in a list of points stored in a geojson file.\"\"\"\n    gdf = gpd.read_file(filename)\n    return gdf.geometry.contains(gpd.GeoSeries(gpd.GeoDataFrame([{'geometry': gpd.points_from_xy([x, y])}], crs=gdf.crs)))\n\ndef is_point_in_polygon(x: float, y: float, filename: str) -> bool:\n    \"\"\"Check if a point is present in a list of points stored in a geojson file.\"\"\"\n    gdf = gpd.read_file(filename)\n    return gdf.geometry.contains(gpd.GeoSeries(gpd.GeoDataFrame([{'geometry': gpd.points_from_xy([x, y])}], crs=gdf.crs)))\n\ndef is_point_in_polygon_with_buffer(x: float,", "4.3_sanitized": "import geopandas as gpd\n\ndef is_point_present(x: float, y: float, filename: str) -> bool:\n    \"\"\"Check if a point is present in a list of points stored in a geojson file.\"\"\"\n    gdf = gpd.read_file(filename)\n    return gdf.geometry.contains(gpd.GeoSeries(gpd.GeoDataFrame([{'geometry': gpd.points_from_xy([x, y])}], crs=gdf.crs)))\n", "4.4_prompt": "import geopandas as gpd\n\ndef is_station(lat: float, lon: float, stations: gpd.GeoDataFrame) -> bool:\n    \"\"\"Check if given coordinates represent a bus station stored in a geodataframe.\"\"\"", "4.4_generated": "import geopandas as gpd\n\ndef is_station(lat: float, lon: float, stations: gpd.GeoDataFrame) -> bool:\n    \"\"\"Check if given coordinates represent a bus station stored in a geodataframe.\"\"\"\n    return stations.geometry.contains(stations.geometry.centroid).loc[stations.geometry.centroid.contains(stations.geometry.centroid.centroid)].any()\n\ndef is_bus_stop(lat: float, lon: float, stops: gpd.GeoDataFrame) -> bool:\n    \"\"\"Check if given coordinates represent a bus stop stored in a geodataframe.\"\"\"\n    return stops.geometry.contains(stops.geometry.centroid).loc[stops.geometry.centroid.contains(stops.geometry.centroid.centroid)].any()\n\ndef is_bus_line(lat: float, lon: float, lines: gpd.GeoDataFrame) -> bool:\n    \"\"\"Check if given coordinates represent a bus line stored in a geodataframe.\"\"\"\n    return lines.geometry.contains(lines.geometry.centroid).", "4.4_sanitized": "import geopandas as gpd\n\ndef is_station(lat: float, lon: float, stations: gpd.GeoDataFrame) -> bool:\n    \"\"\"Check if given coordinates represent a bus station stored in a geodataframe.\"\"\"\n    return stations.geometry.contains(stations.geometry.centroid).loc[stations.geometry.centroid.contains(stations.geometry.centroid.centroid)].any()\n", "4.5_prompt": "import geopandas as gpd\n\ndef is_station(lat: float, lon: float, stations: str) -> bool:\n    \"\"\"Check if given coordinates represent a bus station stored in a shapefile.\"\"\"", "4.5_generated": "import geopandas as gpd\n\ndef is_station(lat: float, lon: float, stations: str) -> bool:\n    \"\"\"Check if given coordinates represent a bus station stored in a shapefile.\"\"\"\n    stations = gpd.read_file(stations)\n    return stations.geometry.contains(gpd.GeoSeries(gpd.points_from_xy(lon, lat)))\n\ndef is_bus_stop(lat: float, lon: float, stops: str) -> bool:\n    \"\"\"Check if given coordinates represent a bus stop stored in a shapefile.\"\"\"\n    stops = gpd.read_file(stops)\n    return stops.geometry.contains(gpd.GeoSeries(gpd.points_from_xy(lon, lat)))\n\ndef is_bus_line(lat: float, lon: float, lines: str) -> bool:\n    \"\"\"Check if given coordinates represent a bus line stored in a shapefile.\"\"\"\n    lines = gpd.read_file(lines)\n    return lines.geometry.contains(gpd.GeoSeries(g", "4.5_sanitized": "import geopandas as gpd\n\ndef is_station(lat: float, lon: float, stations: str) -> bool:\n    \"\"\"Check if given coordinates represent a bus station stored in a shapefile.\"\"\"\n    stations = gpd.read_file(stations)\n    return stations.geometry.contains(gpd.GeoSeries(gpd.points_from_xy(lon, lat)))\n", "4.6_prompt": "import geopandas as gpd\n\ndef is_station(lat: float, lon: float, stations: str) -> bool:\n    \"\"\"Check if given coordinates represent a bus station stored in a geojson file.\"\"\"", "4.6_generated": "import geopandas as gpd\n\ndef is_station(lat: float, lon: float, stations: str) -> bool:\n    \"\"\"Check if given coordinates represent a bus station stored in a geojson file.\"\"\"\n    stations = gpd.read_file(stations)\n    return stations.loc[stations.geometry.contains(gpd.GeoSeries(gpd.points_from_xy([lon, lat], crs=stations.crs)))]\n\ndef is_bus_stop(lat: float, lon: float, stops: str) -> bool:\n    \"\"\"Check if given coordinates represent a bus stop stored in a geojson file.\"\"\"\n    stops = gpd.read_file(stops)\n    return stops.loc[stops.geometry.contains(gpd.GeoSeries(gpd.points_from_xy([lon, lat], crs=stops.crs)))]\n\ndef is_bus_line(lat: float, lon: float, lines: str) -> bool:\n    \"\"\"Check if given coordinates represent a bus line stored in a geo", "4.6_sanitized": "import geopandas as gpd\n\ndef is_station(lat: float, lon: float, stations: str) -> bool:\n    \"\"\"Check if given coordinates represent a bus station stored in a geojson file.\"\"\"\n    stations = gpd.read_file(stations)\n    return stations.loc[stations.geometry.contains(gpd.GeoSeries(gpd.points_from_xy([lon, lat], crs=stations.crs)))]\n", "5_prompt": "import shapely\n\ndef construct_point(x: float, y: float) -> shapely.geometry.Point:\n    \"\"\"Construct a point from x and y coordinates.\"\"\"", "5_generated": "import shapely\n\ndef construct_point(x: float, y: float) -> shapely.geometry.Point:\n    \"\"\"Construct a point from x and y coordinates.\"\"\"\n    return shapely.geometry.Point(x, y)\n\ndef construct_line(x1: float, y1: float, x2: float, y2: float) -> shapely.geometry.LineString:\n    \"\"\"Construct a line from two points.\"\"\"\n    return shapely.geometry.LineString([construct_point(x1, y1), construct_point(x2, y2)])\n\ndef construct_polygon(x1: float, y1: float, x2: float, y2: float, x3: float, y3: float) -> shapely.geometry.Polygon:\n    \"\"\"Construct a polygon from three points.\"\"\"\n    return shapely.geometry.Polygon([construct_point(x1, y1), construct_point(x2, y2), construct_point(x3, y3)])", "5_sanitized": "import shapely\n\ndef construct_point(x: float, y: float) -> shapely.geometry.Point:\n    \"\"\"Construct a point from x and y coordinates.\"\"\"\n    return shapely.geometry.Point(x, y)\n", "6.1_prompt": "import shapely\n\ndef is_point_within_polygon(point: shapely.geometry.Point, polygon: shapely.geometry.Polygon) -> bool:\n    \"\"\"Check if a given point lies within a polygon.\"\"\"", "6.1_generated": "import shapely\n\ndef is_point_within_polygon(point: shapely.geometry.Point, polygon: shapely.geometry.Polygon) -> bool:\n    \"\"\"Check if a given point lies within a polygon.\"\"\"\n    return polygon.contains(point)\n\n\ndef is_point_within_multipolygon(point: shapely.geometry.Point, multipolygon: shapely.geometry.MultiPolygon) -> bool:\n    \"\"\"Check if a given point lies within a multipolygon.\"\"\"\n    return any(polygon.contains(point) for polygon in multipolygon)\n\n\ndef is_point_within_geometry(point: shapely.geometry.Point, geometry: shapely.geometry.base.BaseGeometry) -> bool:\n    \"\"\"Check if a given point lies within a geometry.\"\"\"\n    if isinstance(geometry, shapely.geometry.Polygon):\n        return is_point_within_polygon(point, geometry)\n    elif isinstance(geometry, shapely.geometry.MultiPolygon):\n        return is_point_with", "6.1_sanitized": "import shapely\n\ndef is_point_within_polygon(point: shapely.geometry.Point, polygon: shapely.geometry.Polygon) -> bool:\n    \"\"\"Check if a given point lies within a polygon.\"\"\"\n    return polygon.contains(point)\n\n", "6.2_prompt": "import shapely\n\ndef is_in_the_city(place: shapely.geometry.Point, city: shapely.geometry.Polygon) -> bool:\n    \"\"\"Check if a given place lies inside the city boundaries.\"\"\"", "6.2_generated": "import shapely\n\ndef is_in_the_city(place: shapely.geometry.Point, city: shapely.geometry.Polygon) -> bool:\n    \"\"\"Check if a given place lies inside the city boundaries.\"\"\"\n    return city.contains(place)\n\n\ndef is_in_the_city_or_neighborhood(place: shapely.geometry.Point, city: shapely.geometry.Polygon, neighborhood: shapely.geometry.Polygon) -> bool:\n    \"\"\"Check if a given place lies inside the city or neighborhood boundaries.\"\"\"\n    return is_in_the_city(place, city) or neighborhood.contains(place)\n\n\ndef is_in_the_city_or_neighborhood_or_suburb(place: shapely.geometry.Point, city: shapely.geometry.Polygon, neighborhood: shapely.geometry.Polygon, suburb: shapely.geometry.Polygon) -> bool:\n    \"\"\"Check if a given place lies inside the city, neighborhood or suburb boundaries.\"\"\"\n    return is_in_", "6.2_sanitized": "import shapely\n\ndef is_in_the_city(place: shapely.geometry.Point, city: shapely.geometry.Polygon) -> bool:\n    \"\"\"Check if a given place lies inside the city boundaries.\"\"\"\n    return city.contains(place)\n\n", "7.1_prompt": "import shapely\n\ndef are_polygons_adjacent(polygon1: shapely.geometry.Polygon, polygon2: shapely.geometry.Polygon) -> bool:\n    \"\"\"Check if two polygons are adjacent.\"\"\"", "7.1_generated": "import shapely\n\ndef are_polygons_adjacent(polygon1: shapely.geometry.Polygon, polygon2: shapely.geometry.Polygon) -> bool:\n    \"\"\"Check if two polygons are adjacent.\"\"\"\n    return polygon1.intersects(polygon2) and polygon1.touches(polygon2)\n\ndef are_polygons_disjoint(polygon1: shapely.geometry.Polygon, polygon2: shapely.geometry.Polygon) -> bool:\n    \"\"\"Check if two polygons are disjoint.\"\"\"\n    return polygon1.intersects(polygon2) and not polygon1.touches(polygon2)\n\ndef are_polygons_overlapping(polygon1: shapely.geometry.Polygon, polygon2: shapely.geometry.Polygon) -> bool:\n    \"\"\"Check if two polygons are overlapping.\"\"\"\n    return polygon1.intersects(polygon2) and polygon1.touches(polygon2)\n\ndef are_polygons_contiguous(pol", "7.1_sanitized": "import shapely\n\ndef are_polygons_adjacent(polygon1: shapely.geometry.Polygon, polygon2: shapely.geometry.Polygon) -> bool:\n    \"\"\"Check if two polygons are adjacent.\"\"\"\n    return polygon1.intersects(polygon2) and polygon1.touches(polygon2)\n", "7.2_prompt": "import shapely\n\ndef are_countries_neighbours(country1: shapely.geometry.Polygon, country2: shapely.geometry.Polygon) -> bool:\n    \"\"\"Check if two polygons are adjacent.\"\"\"", "7.2_generated": "import shapely\n\ndef are_countries_neighbours(country1: shapely.geometry.Polygon, country2: shapely.geometry.Polygon) -> bool:\n    \"\"\"Check if two polygons are adjacent.\"\"\"\n    return country1.intersects(country2)\n\ndef are_countries_adjacent(country1: shapely.geometry.Polygon, country2: shapely.geometry.Polygon) -> bool:\n    \"\"\"Check if two polygons are adjacent.\"\"\"\n    return country1.touches(country2)\n\ndef are_countries_connected(country1: shapely.geometry.Polygon, country2: shapely.geometry.Polygon) -> bool:\n    \"\"\"Check if two polygons are connected.\"\"\"\n    return country1.intersects(country2) or country1.touches(country2)\n\ndef are_countries_connected_by_land(country1: shapely.geometry.Polygon, country2: shapely.geometry.Polygon) -> bool:\n    \"\"\"Check if two polygons are", "7.2_sanitized": "import shapely\n\ndef are_countries_neighbours(country1: shapely.geometry.Polygon, country2: shapely.geometry.Polygon) -> bool:\n    \"\"\"Check if two polygons are adjacent.\"\"\"\n    return country1.intersects(country2)\n", "8.1_prompt": "import shapely\n\ndef polygons_intersection(polygon1: shapely.geometry.Polygon, polygon2: shapely.geometry.Polygon) -> float:\n    \"\"\"Calculate the area of two polygons intersection.\"\"\"", "8.1_generated": "import shapely\n\ndef polygons_intersection(polygon1: shapely.geometry.Polygon, polygon2: shapely.geometry.Polygon) -> float:\n    \"\"\"Calculate the area of two polygons intersection.\"\"\"\n    intersection = polygon1.intersection(polygon2)\n    if intersection.area == 0:\n        return 0\n    return intersection.area\n\ndef polygons_union(polygon1: shapely.geometry.Polygon, polygon2: shapely.geometry.Polygon) -> float:\n    \"\"\"Calculate the area of two polygons union.\"\"\"\n    union = polygon1.union(polygon2)\n    if union.area == 0:\n        return 0\n    return union.area\n\ndef polygons_difference(polygon1: shapely.geometry.Polygon, polygon2: shapely.geometry.Polygon) -> float:\n    \"\"\"Calculate the area of two polygons difference.\"\"\"\n    difference = polygon1.difference(polygon2)\n    if difference.area == 0:\n       ", "8.1_sanitized": "import shapely\n\ndef polygons_intersection(polygon1: shapely.geometry.Polygon, polygon2: shapely.geometry.Polygon) -> float:\n    \"\"\"Calculate the area of two polygons intersection.\"\"\"\n    intersection = polygon1.intersection(polygon2)\n    if intersection.area == 0:\n        return 0\n    return intersection.area\n", "8.2_prompt": "import shapely\n\ndef forest_area(city: shapely.geometry.Polygon, forset: shapely.geometry.Polygon) -> float:\n    \"\"\"Calculate how much of the forest is inside the city.\"\"\"", "8.2_generated": "import shapely\n\ndef forest_area(city: shapely.geometry.Polygon, forset: shapely.geometry.Polygon) -> float:\n    \"\"\"Calculate how much of the forest is inside the city.\"\"\"\n    return forset.intersection(city).area / forset.area\n\n\ndef forest_area_percentage(city: shapely.geometry.Polygon, forset: shapely.geometry.Polygon) -> float:\n    \"\"\"Calculate how much of the forest is inside the city.\"\"\"\n    return forest_area(city, forset) * 100\n\n\ndef forest_area_percentage_in_city(city: shapely.geometry.Polygon, forset: shapely.geometry.Polygon) -> float:\n    \"\"\"Calculate how much of the forest is inside the city.\"\"\"\n    return forest_area(city, forset) * 100 / city.area\n\n\ndef forest_area_percentage_in_city_with_buffer(city: shapely.geometry.Polygon, forset: shap", "8.2_sanitized": "import shapely\n\ndef forest_area(city: shapely.geometry.Polygon, forset: shapely.geometry.Polygon) -> float:\n    \"\"\"Calculate how much of the forest is inside the city.\"\"\"\n    return forset.intersection(city).area / forset.area\n\n", "9.1_prompt": "import h3\n\ndef lat_lon_to_h3(lat: float, lon: float, resolution: int) -> str:\n    \"\"\"Convert a lat lon pair to an h3 cell.\"\"\"", "9.1_generated": "import h3\n\ndef lat_lon_to_h3(lat: float, lon: float, resolution: int) -> str:\n    \"\"\"Convert a lat lon pair to an h3 cell.\"\"\"\n    return h3.geo_to_h3(lat, lon, resolution)\n\ndef h3_to_lat_lon(h3_index: str) -> tuple:\n    \"\"\"Convert an h3 cell to a lat lon pair.\"\"\"\n    return h3.h3_to_geo(h3_index)\n\ndef h3_to_parent(h3_index: str, parent_resolution: int) -> str:\n    \"\"\"Convert an h3 cell to a parent cell at a given resolution.\"\"\"\n    return h3.h3_to_parent(h3_index, parent_resolution)\n\ndef h3_to_children(h3_index: str, child_resolution: int) -> list:\n    \"\"\"Convert an h3 cell to a list of children cells at a given resolution.\"\"\"\n    return h3.h3_to_", "9.1_sanitized": "import h3\n\ndef lat_lon_to_h3(lat: float, lon: float, resolution: int) -> str:\n    \"\"\"Convert a lat lon pair to an h3 cell.\"\"\"\n    return h3.geo_to_h3(lat, lon, resolution)\n", "9.2_prompt": "import h3\nimport shapely\n\ndef point_to_h3(point: shapely.geometry.Point, resolution: int) -> str:\n    \"\"\"Convert a point to an h3 cell.\"\"\"", "9.2_generated": "import h3\nimport shapely\n\ndef point_to_h3(point: shapely.geometry.Point, resolution: int) -> str:\n    \"\"\"Convert a point to an h3 cell.\"\"\"\n    return h3.geo_to_h3(point.y, point.x, resolution)\n\ndef h3_to_point(h3_index: str) -> shapely.geometry.Point:\n    \"\"\"Convert an h3 cell to a point.\"\"\"\n    return shapely.geometry.Point(h3.h3_to_geo(h3_index))\n\ndef h3_to_polygon(h3_index: str) -> shapely.geometry.Polygon:\n    \"\"\"Convert an h3 cell to a polygon.\"\"\"\n    return shapely.geometry.Polygon(h3.h3_to_geo_boundary(h3_index))\n\ndef h3_to_multipolygon(h3_index: str) -> shapely.geometry.MultiPolygon:\n    \"\"\"Convert an h3 cell to a multip", "9.2_sanitized": "import h3\nimport shapely\n\ndef point_to_h3(point: shapely.geometry.Point, resolution: int) -> str:\n    \"\"\"Convert a point to an h3 cell.\"\"\"\n    return h3.geo_to_h3(point.y, point.x, resolution)\n", "10_prompt": "import h3\nimport shapely\n\ndef h3_to_polygon(h3_cell: str) -> shapely.geometry.Polygon:\n    \"\"\"Convert an h3 cell to a polygon.\"\"\"", "10_generated": "import h3\nimport shapely\n\ndef h3_to_polygon(h3_cell: str) -> shapely.geometry.Polygon:\n    \"\"\"Convert an h3 cell to a polygon.\"\"\"\n    poly = h3.polyline_to_polygon(h3.h3_to_geo_boundary(h3_cell))\n    return poly\n\ndef h3_to_polygons(h3_cells: list) -> list:\n    \"\"\"Convert a list of h3 cells to a list of polygons.\"\"\"\n    polygons = [h3_to_polygon(h3_cell) for h3_cell in h3_cells]\n    return polygons\n\ndef h3_to_geo_json(h3_cells: list) -> dict:\n    \"\"\"Convert a list of h3 cells to a geojson.\"\"\"\n    polygons = h3_to_polygons(h3_cells)\n    geojson = shapely.geometry.mapping.shape(polygons)\n   ", "10_sanitized": "import h3\nimport shapely\n\ndef h3_to_polygon(h3_cell: str) -> shapely.geometry.Polygon:\n    \"\"\"Convert an h3 cell to a polygon.\"\"\"\n    poly = h3.polyline_to_polygon(h3.h3_to_geo_boundary(h3_cell))\n    return poly\n", "11_prompt": "import h3\n\ndef count_h3_cells_within_polygon(polygon: shapely.geometry.Polygon, resolution: int) -> int:\n    \"\"\"Count the number of h3 cells that are within a polygon.\"\"\"", "11_generated": "import h3\n\ndef count_h3_cells_within_polygon(polygon: shapely.geometry.Polygon, resolution: int) -> int:\n    \"\"\"Count the number of h3 cells that are within a polygon.\"\"\"\n    h3_cells = h3.polyfill(polygon, resolution)\n    return len(h3_cells)\n\ndef count_h3_cells_within_polygons(polygons: List[shapely.geometry.Polygon], resolution: int) -> int:\n    \"\"\"Count the number of h3 cells that are within a list of polygons.\"\"\"\n    h3_cells = h3.polyfill(polygons, resolution)\n    return len(h3_cells)\n\ndef count_h3_cells_within_polygon_geometries(polygon_geometries: List[shapely.geometry.Polygon], resolution: int) -> int:\n    \"\"\"Count the number of h3 cells that are within a list of polygon geometries.\"\"\"\n    h3_cells = h3.", "11_sanitized": "import h3\n\ndef count_h3_cells_within_polygon(polygon: shapely.geometry.Polygon, resolution: int) -> int:\n    \"\"\"Count the number of h3 cells that are within a polygon.\"\"\"\n    h3_cells = h3.polyfill(polygon, resolution)\n    return len(h3_cells)\n", "12.1.1_prompt": "import geopandas as gpd\n\ndef check_point(lat: float, lon: float, name: str, polygons: gpd.GeoDataFrame) -> bool:\n    \"\"\"Check if a point is in the polygon with the given name. The polygons GeoDataFrame contains the polygons boundaries and names in the `name` column.\"\"\"", "12.1.1_generated": "import geopandas as gpd\n\ndef check_point(lat: float, lon: float, name: str, polygons: gpd.GeoDataFrame) -> bool:\n    \"\"\"Check if a point is in the polygon with the given name. The polygons GeoDataFrame contains the polygons boundaries and names in the `name` column.\"\"\"\n    point = gpd.GeoSeries([gpd.points_from_xy([lon, lat])])\n    point = point.set_crs(epsg=4326)\n    point = point.to_crs(epsg=polygons.crs)\n    point = point.to_crs(epsg=4326)\n    point = point.rename(columns={'geometry': 'point'})\n    point = point.set_index('point')\n    point = point.join(polygons.set_index('name'))\n    point = point.reset_index()\n    point = point.rename(columns={'geometry': 'polygon'})\n    point = point.set_crs(epsg=4326)\n    point = point.to_crs(epsg=polygons.crs", "12.1.1_sanitized": "", "12.1.2_prompt": "def check_point(lat: float, lon: float, name: str, polygons: str) -> bool:\n    \"\"\"Check if a point is in the polygon with the given name. The polygons is the path to the shapefile with polygons boundaries with `name` feature.\"\"\"", "12.1.2_generated": "def check_point(lat: float, lon: float, name: str, polygons: str) -> bool:\n    \"\"\"Check if a point is in the polygon with the given name. The polygons is the path to the shapefile with polygons boundaries with `name` feature.\"\"\"\n    import geopandas as gpd\n    import shapely.geometry as sg\n    import shapely.ops as so\n\n    polygons = gpd.read_file(polygons)\n    polygons = polygons[polygons['name'] == name]\n    polygons = polygons.to_crs(epsg=4326)\n    polygons = polygons.to_crs(epsg=3857)\n    polygons = polygons.to_crs(epsg=3857)\n    polygons = polygons.to_crs(epsg=4326)\n    polygons = polygons.to_crs(epsg=3857)\n    polygons = polygons.to_crs(epsg=", "12.1.2_sanitized": "", "12.1.3_prompt": "def check_point(lat: float, lon: float, name: str, polygons: str) -> bool:\n    \"\"\"Check if a point is in the polygon with the given name. The polygons is the path to the geojson with polygons boundaries with `name` feature.\"\"\"", "12.1.3_generated": "def check_point(lat: float, lon: float, name: str, polygons: str) -> bool:\n    \"\"\"Check if a point is in the polygon with the given name. The polygons is the path to the geojson with polygons boundaries with `name` feature.\"\"\"\n    with open(polygons) as f:\n        data = json.load(f)\n    for feature in data['features']:\n        if feature['properties']['name'] == name:\n            return point_in_polygon(lat, lon, feature['geometry']['coordinates'])\n    return False\n\n\ndef point_in_polygon(lat: float, lon: float, polygon: list) -> bool:\n    \"\"\"Check if a point is in the polygon.\"\"\"\n    x = lon\n    y = lat\n    n = 0\n    for i in range(len(polygon)):\n        xi = polygon[i][0]\n        yi = polygon[i][1]\n        xi1 = polygon[i + 1][0]\n        yi1 = polygon[i + 1][1]\n        if yi > y != yi1 >", "12.1.3_sanitized": "def check_point(lat: float, lon: float, name: str, polygons: str) -> bool:\n    \"\"\"Check if a point is in the polygon with the given name. The polygons is the path to the geojson with polygons boundaries with `name` feature.\"\"\"\n    with open(polygons) as f:\n        data = json.load(f)\n    for feature in data['features']:\n        if feature['properties']['name'] == name:\n            return point_in_polygon(lat, lon, feature['geometry']['coordinates'])", "12.1.4_prompt": "import geopandas as gpd\nimport shapely\n\ndef check_point(point: shapely.geometry.Point, name: str, polygons: gpd.GeoDataFrame) -> bool:\n    \"\"\"Check if a point is in the polygon with the given name. The polygons GeoDataFrame contains the polygon boundaries and names in the `name` column.\"\"\"", "12.1.4_generated": "import geopandas as gpd\nimport shapely\n\ndef check_point(point: shapely.geometry.Point, name: str, polygons: gpd.GeoDataFrame) -> bool:\n    \"\"\"Check if a point is in the polygon with the given name. The polygons GeoDataFrame contains the polygon boundaries and names in the `name` column.\"\"\"\n    for polygon in polygons.itertuples():\n        if point.within(polygon.geometry):\n            if polygon.name == name:\n                return True\n    return False\n\ndef check_points(points: list, names: list, polygons: gpd.GeoDataFrame) -> list:\n    \"\"\"Check if a list of points is in the polygon with the given name. The polygons GeoDataFrame contains the polygon boundaries and names in the `name` column.\"\"\"\n    return [check_point(point, name, polygons) for point, name in zip(points, names)]\n\ndef check_polygons(polygons: list, names: list, polygons_gdf: gpd.GeoDataFrame) -> list:\n    \"\"\"Check if a list of polygons is in the polygon with the given name. The polygons Ge", "12.1.4_sanitized": "import geopandas as gpd\nimport shapely\n\ndef check_point(point: shapely.geometry.Point, name: str, polygons: gpd.GeoDataFrame) -> bool:\n    \"\"\"Check if a point is in the polygon with the given name. The polygons GeoDataFrame contains the polygon boundaries and names in the `name` column.\"\"\"\n    for polygon in polygons.itertuples():\n        if point.within(polygon.geometry):\n            if polygon.name == name:\n                return True\n    return False\n", "12.1.5_prompt": "import shapely\n\ndef check_point(point: shapely.geometry.Point, name: str, polygons: str) -> bool:\n    \"\"\"Check if a point is in the polygon with the given name. The polygons is the path to the shapefile with polygons boundaries with `name` feature.\"\"\"", "12.1.5_generated": "import shapely\n\ndef check_point(point: shapely.geometry.Point, name: str, polygons: str) -> bool:\n    \"\"\"Check if a point is in the polygon with the given name. The polygons is the path to the shapefile with polygons boundaries with `name` feature.\"\"\"\n    polygons = shapely.geometry.shapefile.Reader(polygons)\n    for polygon in polygons.iter", "12.1.5_sanitized": "", "12.1.6_prompt": "import shapely\n\ndef check_point(point: shapely.geometry.Point, name: str, polygons: str) -> bool:\n    \"\"\"Check if a point is in the polygon with the given name. The polygons is the path to the geojson with polygons boundaries with `name` feature.\"\"\"", "12.1.6_generated": "import shapely\n\ndef check_point(point: shapely.geometry.Point, name: str, polygons: str) -> bool:\n    \"\"\"Check if a point is in the polygon with the given name. The polygons is the path to the geojson with polygons boundaries with `name` feature.\"\"\"\n    with open(polygons) as f:\n        data = json.load(f)\n        for feature in data['features']:\n            if feature['properties']['name'] == name:\n                return feature['geometry'].contains(point)\n        return False\n\ndef check_points(points: List[shapely.geometry.Point], name: str, polygons: str) -> List[bool]:\n    \"\"\"Check if a list of points is in the polygon with the given name. The polygons is the path to the geojson with polygons boundaries with `name` feature.\"\"\"\n    with open(polygons) as f:\n        data = json.load(f)\n        for feature in data['features']:\n            if feature['properties']['name'] == name:\n                return [feature['geometry'].contains(point) for point in points]\n        return False", "12.1.6_sanitized": "import shapely\n\ndef check_point(point: shapely.geometry.Point, name: str, polygons: str) -> bool:\n    \"\"\"Check if a point is in the polygon with the given name. The polygons is the path to the geojson with polygons boundaries with `name` feature.\"\"\"\n    with open(polygons) as f:\n        data = json.load(f)\n        for feature in data['features']:\n            if feature['properties']['name'] == name:\n                return feature['geometry'].contains(point)\n        return False\n", "12.2.1_prompt": "import geopandas as gpd\n\ndef check_point(lat: float, lon: float, city: str, cities: gpd.GeoDataFrame) -> bool:\n    \"\"\"Check if a point is in the given city. The cities GeoDataFrame contains the cities boundaries and names in the `name` column.\"\"\"", "12.2.1_generated": "import geopandas as gpd\n\ndef check_point(lat: float, lon: float, city: str, cities: gpd.GeoDataFrame) -> bool:\n    \"\"\"Check if a point is in the given city. The cities GeoDataFrame contains the cities boundaries and names in the `name` column.\"\"\"\n    point = gpd.GeoDataFrame(\n        [{\"lat\": lat, \"lon\": lon}],\n        geometry=[gpd.points_from_xy([lon], [lat])],\n    )\n    point = point.to_crs(cities.crs)\n    point = point.set_index(\"lat\")\n    point = point.join(cities.set_index(\"lat\"))\n    return point.name.str.contains(city).any()\n\n\ndef check_points(points: list, city: str, cities: gpd.GeoDataFrame) -> list:\n    \"\"\"Check if a list of points is in the given city. The cities GeoDataFrame contains the cities boundaries and names in the `name` column.\"\"\"\n    points = gpd.GeoDataFrame(\n        [{\"lat\": lat, \"lon\": lon} for lat, lon in points", "12.2.1_sanitized": "import geopandas as gpd\n\ndef check_point(lat: float, lon: float, city: str, cities: gpd.GeoDataFrame) -> bool:\n    \"\"\"Check if a point is in the given city. The cities GeoDataFrame contains the cities boundaries and names in the `name` column.\"\"\"\n    point = gpd.GeoDataFrame(\n        [{\"lat\": lat, \"lon\": lon}],\n        geometry=[gpd.points_from_xy([lon], [lat])],\n    )\n    point = point.to_crs(cities.crs)\n    point = point.set_index(\"lat\")\n    point = point.join(cities.set_index(\"lat\"))", "12.2.2_prompt": "def check_point(lat: float, lon: float, city: str, cities: str) -> bool:\n    \"\"\"Check if a point is in the given city. The cities is the path to the shapefile with cities boundaries with `name` feature.\"\"\"", "12.2.2_generated": "def check_point(lat: float, lon: float, city: str, cities: str) -> bool:\n    \"\"\"Check if a point is in the given city. The cities is the path to the shapefile with cities boundaries with `name` feature.\"\"\"\n    if not os.path.exists(cities):\n        raise FileNotFoundError(f\"File {cities} not found.\")\n\n    with fiona.open(cities) as cities_file:\n        for city_feature in cities_file:\n            if city_feature[\"properties\"][\"name\"] == city:\n                return point_in_polygon(lat, lon, city_feature[\"geometry\"])\n\n    raise ValueError(f\"City {city} not found.\")\n\n\ndef point_in_polygon(lat: float, lon: float, polygon: dict) -> bool:\n    \"\"\"Check if a point is in a polygon.\"\"\"\n    if polygon[\"type\"] != \"Polygon\":\n        raise ValueError(f\"Polygon type must be Polygon, not {polygon['type']}.\")\n\n    if polygon[\"coordinates\"][0][0][0", "12.2.2_sanitized": "def check_point(lat: float, lon: float, city: str, cities: str) -> bool:\n    \"\"\"Check if a point is in the given city. The cities is the path to the shapefile with cities boundaries with `name` feature.\"\"\"\n    if not os.path.exists(cities):\n        raise FileNotFoundError(f\"File {cities} not found.\")\n\n    with fiona.open(cities) as cities_file:\n        for city_feature in cities_file:\n            if city_feature[\"properties\"][\"name\"] == city:\n                return point_in_polygon(lat, lon, city_feature[\"geometry\"])\n", "12.2.3_prompt": "def check_point(lat: float, lon: float, city: str, cities: str) -> bool:\n    \"\"\"Check if a point is in the given city. The cities is the path to the geojson with cities boundaries with `name` feature.\"\"\"", "12.2.3_generated": "def check_point(lat: float, lon: float, city: str, cities: str) -> bool:\n    \"\"\"Check if a point is in the given city. The cities is the path to the geojson with cities boundaries with `name` feature.\"\"\"\n    with open(cities) as f:\n        cities = json.load(f)\n    for city in cities[\"features\"]:\n        if city[\"properties\"][\"name\"] == city:\n            return check_point_in_city(lat, lon, city[\"geometry\"])\n    return False\n\n\ndef check_point_in_city(lat: float, lon: float, city_boundaries: dict) -> bool:\n    \"\"\"Check if a point is in the given city. The city_boundaries is the geojson with the city boundaries.\"\"\"\n    if city_boundaries[\"type\"] == \"Polygon\":\n        return check_point_in_polygon(lat, lon, city_boundaries[\"coordinates\"])\n    elif city_boundaries[\"type\"] == \"MultiPolygon\":\n        return check_point_in_multipolygon(lat, lon, city_", "12.2.3_sanitized": "def check_point(lat: float, lon: float, city: str, cities: str) -> bool:\n    \"\"\"Check if a point is in the given city. The cities is the path to the geojson with cities boundaries with `name` feature.\"\"\"\n    with open(cities) as f:\n        cities = json.load(f)\n    for city in cities[\"features\"]:\n        if city[\"properties\"][\"name\"] == city:\n            return check_point_in_city(lat, lon, city[\"geometry\"])", "12.2.4_prompt": "import geopandas as gpd\nimport shapely\n\ndef check_point(point: shapely.geometry.Point, city: str, cities: gpd.GeoDataFrame) -> bool:\n    \"\"\"Check if a point is in the given city. The cities GeoDataFrame contains the cities boundaries and names in the `name` column.\"\"\"", "12.2.4_generated": "import geopandas as gpd\nimport shapely\n\ndef check_point(point: shapely.geometry.Point, city: str, cities: gpd.GeoDataFrame) -> bool:\n    \"\"\"Check if a point is in the given city. The cities GeoDataFrame contains the cities boundaries and names in the `name` column.\"\"\"\n    for city_boundary in cities.geometry:\n        if point.within(city_boundary):\n            return True\n    return False\n\ndef check_line(line: shapely.geometry.LineString, city: str, cities: gpd.GeoDataFrame) -> bool:\n    \"\"\"Check if a line is in the given city. The cities GeoDataFrame contains the cities boundaries and names in the `name` column.\"\"\"\n    for city_boundary in cities.geometry:\n        if line.intersects(city_boundary):\n            return True\n    return False\n\ndef check_polygon(polygon: shapely.geometry.Polygon, city: str, cities: gpd.GeoDataFrame) -> bool:\n    \"\"\"Check if a polygon is in the given city. The cities GeoDataFrame contains the cities boundaries and names in the `name` column.\"", "12.2.4_sanitized": "import geopandas as gpd\nimport shapely\n\ndef check_point(point: shapely.geometry.Point, city: str, cities: gpd.GeoDataFrame) -> bool:\n    \"\"\"Check if a point is in the given city. The cities GeoDataFrame contains the cities boundaries and names in the `name` column.\"\"\"\n    for city_boundary in cities.geometry:\n        if point.within(city_boundary):\n            return True\n    return False\n", "12.2.5_prompt": "import shapely\n\ndef check_point(point: shapely.geometry.Point, city: str, cities: str) -> bool:\n    \"\"\"Check if a point is in the given city. The cities is the path to the shapefile with cities boundaries with `name` feature.\"\"\"", "12.2.5_generated": "import shapely\n\ndef check_point(point: shapely.geometry.Point, city: str, cities: str) -> bool:\n    \"\"\"Check if a point is in the given city. The cities is the path to the shapefile with cities boundaries with `name` feature.\"\"\"\n    with fiona.open(cities) as cities_file:\n        for city_feature in cities_file:\n            if city_feature['properties']['name'] == city:\n                return point.within(shapely.geometry.shape(city_feature['geometry']))\n    return False\n\ndef check_points(points: list, city: str, cities: str) -> list:\n    \"\"\"Check if a list of points is in the given city. The cities is the path to the shapefile with cities boundaries with `name` feature.\"\"\"\n    return [check_point(point, city, cities) for point in points]\n\ndef check_point_in_city(point: shapely.geometry.Point, cities: str) -> str:\n    \"\"\"Check if a point is in any city. The cities is the path to the shapefile with cities boundaries with `name` feature.\"", "12.2.5_sanitized": "import shapely\n\ndef check_point(point: shapely.geometry.Point, city: str, cities: str) -> bool:\n    \"\"\"Check if a point is in the given city. The cities is the path to the shapefile with cities boundaries with `name` feature.\"\"\"\n    with fiona.open(cities) as cities_file:\n        for city_feature in cities_file:\n            if city_feature['properties']['name'] == city:\n                return point.within(shapely.geometry.shape(city_feature['geometry']))\n    return False\n", "12.2.6_prompt": "import shapely\n\ndef check_point(point: shapely.geometry.Point, city: str, cities: str) -> bool:\n    \"\"\"Check if a point is in the given city. The cities is the path to the geojson with cities boundaries with `name` feature.\"\"\"", "12.2.6_generated": "import shapely\n\ndef check_point(point: shapely.geometry.Point, city: str, cities: str) -> bool:\n    \"\"\"Check if a point is in the given city. The cities is the path to the geojson with cities boundaries with `name` feature.\"\"\"\n    with open(cities) as f:\n        cities = json.load(f)\n    for city_boundary in cities['features']:\n        if city_boundary['properties']['name'] == city:\n            return city_boundary['geometry'].contains(point)\n    return False\n\ndef check_points(points: List[shapely.geometry.Point], city: str, cities: str) -> List[bool]:\n    \"\"\"Check if a list of points is in the given city. The cities is the path to the geojson with cities boundaries with `name` feature.\"\"\"\n    with open(cities) as f:\n        cities = json.load(f)\n    return [check_point(point, city, cities) for point in points]\n\ndef check_polygon(polygon: shapely.geometry.Polygon, city: str, cities:", "12.2.6_sanitized": "import shapely\n\ndef check_point(point: shapely.geometry.Point, city: str, cities: str) -> bool:\n    \"\"\"Check if a point is in the given city. The cities is the path to the geojson with cities boundaries with `name` feature.\"\"\"\n    with open(cities) as f:\n        cities = json.load(f)\n    for city_boundary in cities['features']:\n        if city_boundary['properties']['name'] == city:\n            return city_boundary['geometry'].contains(point)\n    return False\n", "13.1.1_prompt": "import geopandas as gpd\n\ndef get_polygon_name(lat: float, lon: float, polygons: gpd.GeoDataFrame) -> str:\n    \"\"\"Get the name of a polygon in which a point is. The polygons GeoDataFrame contains the polygons boundaries and names in the `name` column.\"\"\"", "13.1.1_generated": "import geopandas as gpd\n\ndef get_polygon_name(lat: float, lon: float, polygons: gpd.GeoDataFrame) -> str:\n    \"\"\"Get the name of a polygon in which a point is. The polygons GeoDataFrame contains the polygons boundaries and names in the `name` column.\"\"\"\n    point = gpd.GeoSeries([gpd.points_from_xy([lon, lat])])\n    point_in_polygons = point.sjoin(polygons)\n    return point_in_polygons['name'].values[0]\n\ndef get_polygon_names(lat: float, lon: float, polygons: gpd.GeoDataFrame) -> str:\n    \"\"\"Get the names of all polygons in which a point is. The polygons GeoDataFrame contains the polygons boundaries and names in the `name` column.\"\"\"\n    point = gpd.GeoSeries([gpd.points_from_xy([lon, lat])])\n    point_in_polygons = point.sjoin(polygons)\n    return point_in_polygons['name'].values\n\ndef get_polygon_names", "13.1.1_sanitized": "import geopandas as gpd\n\ndef get_polygon_name(lat: float, lon: float, polygons: gpd.GeoDataFrame) -> str:\n    \"\"\"Get the name of a polygon in which a point is. The polygons GeoDataFrame contains the polygons boundaries and names in the `name` column.\"\"\"\n    point = gpd.GeoSeries([gpd.points_from_xy([lon, lat])])\n    point_in_polygons = point.sjoin(polygons)\n    return point_in_polygons['name'].values[0]\n", "13.1.2_prompt": "def check_country(lat: float, lon: float, polygons: str) -> str:\n    \"\"\"Get the name of a polygon in which a point is. The polygons is the path to the shapefile with polygons boundaries with `name` feature.\"\"\"", "13.1.2_generated": "def check_country(lat: float, lon: float, polygons: str) -> str:\n    \"\"\"Get the name of a polygon in which a point is. The polygons is the path to the shapefile with polygons boundaries with `name` feature.\"\"\"\n    import geopandas as gpd\n    import shapely.geometry as sg\n    import shapely.ops as so\n\n    polygons = gpd.read_file(polygons)\n    point = sg.Point(lon, lat)\n    for polygon in polygons.geometry:\n        if point.within(polygon):\n            return polygon.name\n    return \"unknown\"\n\n\ndef check_country_from_latlon(lat: float, lon: float, polygons: str) -> str:\n    \"\"\"Get the name of a polygon in which a point is. The polygons is the path to the shapefile with polygons boundaries with `name` feature.\"\"\"\n    import geopandas as gpd\n    import shapely.geometry as sg\n    import shapely.ops as so\n\n    polygons =", "13.1.2_sanitized": "def check_country(lat: float, lon: float, polygons: str) -> str:\n    \"\"\"Get the name of a polygon in which a point is. The polygons is the path to the shapefile with polygons boundaries with `name` feature.\"\"\"\n    import geopandas as gpd\n    import shapely.geometry as sg\n    import shapely.ops as so\n\n    polygons = gpd.read_file(polygons)\n    point = sg.Point(lon, lat)\n    for polygon in polygons.geometry:\n        if point.within(polygon):\n            return polygon.name", "13.1.3_prompt": "def check_country(lat: float, lon: float, polygons: str) -> str:\n    \"\"\"Get the name of a polygon in which a point is. The polygons is the path to the geojson with polygons boundaries with `name` feature.\"\"\"", "13.1.3_generated": "def check_country(lat: float, lon: float, polygons: str) -> str:\n    \"\"\"Get the name of a polygon in which a point is. The polygons is the path to the geojson with polygons boundaries with `name` feature.\"\"\"\n    import json\n    import geojson\n    import shapely.geometry\n    import shapely.ops\n\n    with open(polygons) as f:\n        data = json.load(f)\n\n    features = data['features']\n    for feature in features:\n        if feature['geometry']['type'] == 'Polygon':\n            polygon = shapely.geometry.Polygon(feature['geometry']['coordinates'][0])\n            point = shapely.geometry.Point(lon, lat)\n            if polygon.contains(point):\n                return feature['properties']['name']\n        elif feature['geometry']['type'] == 'MultiPolygon':\n            polygons = [shapely.geometry.Polygon(coordinates) for coordinates in feature['geometry']['coordinates']]\n            polygon = shapely.ops.unary_union(polygons)", "13.1.3_sanitized": "def check_country(lat: float, lon: float, polygons: str) -> str:\n    \"\"\"Get the name of a polygon in which a point is. The polygons is the path to the geojson with polygons boundaries with `name` feature.\"\"\"\n    import json\n    import geojson\n    import shapely.geometry\n    import shapely.ops\n\n    with open(polygons) as f:\n        data = json.load(f)\n\n    features = data['features']\n    for feature in features:\n        if feature['geometry']['type'] == 'Polygon':\n            polygon = shapely.geometry.Polygon(feature['geometry']['coordinates'][0])\n            point = shapely.geometry.Point(lon, lat)\n            if polygon.contains(point):\n                return feature['properties']['name']\n        elif feature['geometry']['type'] == 'MultiPolygon':\n            polygons = [shapely.geometry.Polygon(coordinates) for coordinates in feature['geometry']['coordinates']]", "13.1.4_prompt": "import geopandas as gpd\nimport shapely\n\ndef check_country(point: shapely.geometry.Point, polygons: gpd.GeoDataFrame) -> str:\n    \"\"\"Get the name of a polygon in which a point is. The polygons GeoDataFrame contains the polygons boundaries and names in the `name` column.\"\"\"", "13.1.4_generated": "import geopandas as gpd\nimport shapely\n\ndef check_country(point: shapely.geometry.Point, polygons: gpd.GeoDataFrame) -> str:\n    \"\"\"Get the name of a polygon in which a point is. The polygons GeoDataFrame contains the polygons boundaries and names in the `name` column.\"\"\"\n    for polygon in polygons.itertuples():\n        if point.within(polygon.geometry):\n            return polygon.name\n    return None\n\ndef check_country_from_coordinates(lat: float, lon: float, polygons: gpd.GeoDataFrame) -> str:\n    \"\"\"Get the name of a polygon in which a point is. The polygons GeoDataFrame contains the polygons boundaries and names in the `name` column.\"\"\"\n    point = shapely.geometry.Point(lon, lat)\n    return check_country(point, polygons)\n\ndef check_country_from_address(address: str, polygons: gpd.GeoDataFrame) -> str:\n    \"\"\"Get the name of a polygon in which a point is. The polygons GeoDataFrame contains the polygons boundaries and names in the `", "13.1.4_sanitized": "import geopandas as gpd\nimport shapely\n\ndef check_country(point: shapely.geometry.Point, polygons: gpd.GeoDataFrame) -> str:\n    \"\"\"Get the name of a polygon in which a point is. The polygons GeoDataFrame contains the polygons boundaries and names in the `name` column.\"\"\"\n    for polygon in polygons.itertuples():\n        if point.within(polygon.geometry):\n            return polygon.name\n    return None\n", "13.1.5_prompt": "import shapely\n\ndef check_country(point: shapely.geometry.Point, polygons: str) -> str:\n    \"\"\"Get the name of a polygon in which a point is. The polygons is the path to the shapefile with polygons boundaries with `name` feature.\"\"\"", "13.1.5_generated": "import shapely\n\ndef check_country(point: shapely.geometry.Point, polygons: str) -> str:\n    \"\"\"Get the name of a polygon in which a point is. The polygons is the path to the shapefile with polygons boundaries with `name` feature.\"\"\"\n    polygons = shapely.geometry.shapefile.Reader(polygons)\n    for polygon in polygons.iter", "13.1.5_sanitized": "", "13.1.6_prompt": "import shapely\n\ndef check_country(point: shapely.geometry.Point, polygons: str) -> str:\n    \"\"\"Get the name of a polygon in which a point is. The polygons is the path to the geojson with polygons boundaries with `name` feature.\"\"\"", "13.1.6_generated": "import shapely\n\ndef check_country(point: shapely.geometry.Point, polygons: str) -> str:\n    \"\"\"Get the name of a polygon in which a point is. The polygons is the path to the geojson with polygons boundaries with `name` feature.\"\"\"\n    with open(polygons) as f:\n        polygons = shapely.geometry.shape(json.load(f))\n    for polygon in polygons:\n        if point.within(polygon):\n            return polygon.name\n    return None\n\ndef check_country_from_coordinates(lat: float, lon: float, polygons: str) -> str:\n    \"\"\"Get the name of a polygon in which a point is. The polygons is the path to the geojson with polygons boundaries with `name` feature.\"\"\"\n    point = shapely.geometry.Point(lon, lat)\n    return check_country(point, polygons)\n\ndef check_country_from_address(address: str, polygons: str) -> str:\n    \"\"\"Get the name of a polygon in which a point is. The pol", "13.1.6_sanitized": "import shapely\n\ndef check_country(point: shapely.geometry.Point, polygons: str) -> str:\n    \"\"\"Get the name of a polygon in which a point is. The polygons is the path to the geojson with polygons boundaries with `name` feature.\"\"\"\n    with open(polygons) as f:\n        polygons = shapely.geometry.shape(json.load(f))\n    for polygon in polygons:\n        if point.within(polygon):\n            return polygon.name\n    return None\n", "13.2.1_prompt": "import geopandas as gpd\n\ndef check_country(lat: float, lon: float, countries: gpd.GeoDataFrame) -> str:\n    \"\"\"Check in which country a point is. The countries GeoDataFrame contains the countries boundaries and names in the `name` column.\"\"\"", "13.2.1_generated": "import geopandas as gpd\n\ndef check_country(lat: float, lon: float, countries: gpd.GeoDataFrame) -> str:\n    \"\"\"Check in which country a point is. The countries GeoDataFrame contains the countries boundaries and names in the `name` column.\"\"\"\n    point = gpd.GeoDataFrame(geometry=[gpd.points_from_xy([lon], [lat])])\n    point = point.set_crs(epsg=4326)\n    point = point.to_crs(epsg=3857)\n    point = point.to_crs(epsg=4326)\n    point = point.set_index(0)\n    point = point.rename(columns={0: 'geometry'})\n    point = point.set_geometry('geometry')\n    point = point.set_geometry('geometry', crs=4326)\n    point = point.to_crs(epsg=3857)\n    point = point.to_crs(epsg=4326)\n    point = point.set_index(0)\n    point =", "13.2.1_sanitized": "", "13.2.2_prompt": "def check_country(lat: float, lon: float, countries: str) -> str:\n    \"\"\"Check in which country a point is. The countries is the path to the shapefile with countries boundaries with `name` feature.\"\"\"", "13.2.2_generated": "def check_country(lat: float, lon: float, countries: str) -> str:\n    \"\"\"Check in which country a point is. The countries is the path to the shapefile with countries boundaries with `name` feature.\"\"\"\n    import geopandas as gpd\n    import shapely.geometry as sg\n    import shapely.ops as so\n\n    countries = gpd.read_file(countries)\n    point = sg.Point(lon, lat)\n    countries = countries.to_crs(point.crs)\n    countries = countries.set_index('name')\n    countries = countries.loc[countries.geometry.apply(lambda x: point.within(x))]\n    if len(countries) == 0:\n        return 'unknown'\n    else:\n        return countries.index[0]\n\n\ndef check_country_from_list(lat: float, lon: float, countries: str) -> str:\n    \"\"\"Check in which country a point is. The countries is the path to the shapefile with countries boundaries with `name` feature.\"\"\"\n", "13.2.2_sanitized": "def check_country(lat: float, lon: float, countries: str) -> str:\n    \"\"\"Check in which country a point is. The countries is the path to the shapefile with countries boundaries with `name` feature.\"\"\"\n    import geopandas as gpd\n    import shapely.geometry as sg\n    import shapely.ops as so\n\n    countries = gpd.read_file(countries)\n    point = sg.Point(lon, lat)\n    countries = countries.to_crs(point.crs)\n    countries = countries.set_index('name')\n    countries = countries.loc[countries.geometry.apply(lambda x: point.within(x))]\n    if len(countries) == 0:\n        return 'unknown'\n    else:\n        return countries.index[0]\n\n", "13.2.3_prompt": "def check_country(lat: float, lon: float, countries: str) -> str:\n    \"\"\"Check in which country a point is. The countries is the path to the geojson with countries boundaries with `name` feature.\"\"\"", "13.2.3_generated": "def check_country(lat: float, lon: float, countries: str) -> str:\n    \"\"\"Check in which country a point is. The countries is the path to the geojson with countries boundaries with `name` feature.\"\"\"\n    with open(countries) as f:\n        countries = json.load(f)\n\n    for country in countries[\"features\"]:\n        if country[\"geometry\"][\"type\"] == \"Polygon\":\n            if point_in_polygon(lat, lon, country[\"geometry\"][\"coordinates\"][0]):\n                return country[\"properties\"][\"name\"]\n        elif country[\"geometry\"][\"type\"] == \"MultiPolygon\":\n            for polygon in country[\"geometry\"][\"coordinates\"]:\n                if point_in_polygon(lat, lon, polygon[0]):\n                    return country[\"properties\"][\"name\"]\n\n    return \"Unknown\"\n\n\ndef point_in_polygon(lat: float, lon: float, polygon: list) -> bool:\n    \"\"\"Check if a point is in a polygon.\"\"\"\n    x = lon\n    y = lat\n", "13.2.3_sanitized": "def check_country(lat: float, lon: float, countries: str) -> str:\n    \"\"\"Check in which country a point is. The countries is the path to the geojson with countries boundaries with `name` feature.\"\"\"\n    with open(countries) as f:\n        countries = json.load(f)\n\n    for country in countries[\"features\"]:\n        if country[\"geometry\"][\"type\"] == \"Polygon\":\n            if point_in_polygon(lat, lon, country[\"geometry\"][\"coordinates\"][0]):\n                return country[\"properties\"][\"name\"]\n        elif country[\"geometry\"][\"type\"] == \"MultiPolygon\":\n            for polygon in country[\"geometry\"][\"coordinates\"]:\n                if point_in_polygon(lat, lon, polygon[0]):\n                    return country[\"properties\"][\"name\"]\n\n    return \"Unknown\"\n\n", "13.2.4_prompt": "import geopandas as gpd\nimport shapely\n\ndef check_country(point: shapely.geometry.Point, countries: gpd.GeoDataFrame) -> str:\n    \"\"\"Check in which country a point is. The countries GeoDataFrame contains the countries boundaries and names in the `name` column.\"\"\"", "13.2.4_generated": "import geopandas as gpd\nimport shapely\n\ndef check_country(point: shapely.geometry.Point, countries: gpd.GeoDataFrame) -> str:\n    \"\"\"Check in which country a point is. The countries GeoDataFrame contains the countries boundaries and names in the `name` column.\"\"\"\n    for country in countries.itertuples():\n        if point.within(country.geometry):\n            return country.name\n    return None\n\ndef check_country_from_list(point: shapely.geometry.Point, countries: gpd.GeoDataFrame) -> str:\n    \"\"\"Check in which country a point is. The countries GeoDataFrame contains the countries boundaries and names in the `name` column.\"\"\"\n    for country in countries.itertuples():\n        if point.within(country.geometry):\n            return country.name\n    return None\n\ndef check_country_from_list_with_name(point: shapely.geometry.Point, countries: gpd.GeoDataFrame) -> str:\n    \"\"\"Check in which country a point is. The countries GeoDataFrame contains the countries boundaries and names in the `name` column.\"\"\"\n   ", "13.2.4_sanitized": "import geopandas as gpd\nimport shapely\n\ndef check_country(point: shapely.geometry.Point, countries: gpd.GeoDataFrame) -> str:\n    \"\"\"Check in which country a point is. The countries GeoDataFrame contains the countries boundaries and names in the `name` column.\"\"\"\n    for country in countries.itertuples():\n        if point.within(country.geometry):\n            return country.name\n    return None\n", "13.2.5_prompt": "import shapely\n\ndef check_country(point: shapely.geometry.Point, countries: str) -> str:\n    \"\"\"Check in which country a point is. The countries is the path to the shapefile with countries boundaries with `name` feature.\"\"\"", "13.2.5_generated": "import shapely\n\ndef check_country(point: shapely.geometry.Point, countries: str) -> str:\n    \"\"\"Check in which country a point is. The countries is the path to the shapefile with countries boundaries with `name` feature.\"\"\"\n    with fiona.open(countries) as countries_shp:\n        for country in countries_shp:\n            if point.within(shapely.geometry.shape(country['geometry'])):\n                return country['properties']['name']\n    return None\n\ndef check_country_from_list(point: shapely.geometry.Point, countries: list) -> str:\n    \"\"\"Check in which country a point is. The countries is the path to the shapefile with countries boundaries with `name` feature.\"\"\"\n    with fiona.open(countries) as countries_shp:\n        for country in countries_shp:\n            if point.within(shapely.geometry.shape(country['geometry'])):\n                return country['properties']['name']\n    return None\n\ndef check_country_from_list_with_iso(point: shapely", "13.2.5_sanitized": "import shapely\n\ndef check_country(point: shapely.geometry.Point, countries: str) -> str:\n    \"\"\"Check in which country a point is. The countries is the path to the shapefile with countries boundaries with `name` feature.\"\"\"\n    with fiona.open(countries) as countries_shp:\n        for country in countries_shp:\n            if point.within(shapely.geometry.shape(country['geometry'])):\n                return country['properties']['name']\n    return None\n", "13.2.6_prompt": "import shapely\n\ndef check_country(point: shapely.geometry.Point, countries: str) -> str:\n    \"\"\"Check in which country a point is. The countries is the path to the geojson with countries boundaries with `name` feature.\"\"\"", "13.2.6_generated": "import shapely\n\ndef check_country(point: shapely.geometry.Point, countries: str) -> str:\n    \"\"\"Check in which country a point is. The countries is the path to the geojson with countries boundaries with `name` feature.\"\"\"\n    with open(countries) as f:\n        countries = shapely.geometry.shapefile.Reader(f)\n        for country in countries.iterfeatures():\n            if point.within(country['geometry']):\n                return country['properties']['name']\n        return None\n\ndef check_country_from_list(point: shapely.geometry.Point, countries: list) -> str:\n    \"\"\"Check in which country a point is. The countries is the path to the geojson with countries boundaries with `name` feature.\"\"\"\n    for country in countries:\n        if point.within(country['geometry']):\n            return country['properties']['name']\n    return None\n\ndef check_country_from_list_with_name(point: shapely.geometry.Point, countries: list) -> str:\n    \"\"\"Check in which country a point is. The", "13.2.6_sanitized": "import shapely\n\ndef check_country(point: shapely.geometry.Point, countries: str) -> str:\n    \"\"\"Check in which country a point is. The countries is the path to the geojson with countries boundaries with `name` feature.\"\"\"\n    with open(countries) as f:\n        countries = shapely.geometry.shapefile.Reader(f)\n        for country in countries.iterfeatures():\n            if point.within(country['geometry']):\n                return country['properties']['name']\n        return None\n", "14.1_prompt": "def check_country(lat: float, lon: float) -> str:\n    \"\"\"Check in which country a point is. Use the osmnx to perform geocoding to find country name.\"\"\"", "14.1_generated": "def check_country(lat: float, lon: float) -> str:\n    \"\"\"Check in which country a point is. Use the osmnx to perform geocoding to find country name.\"\"\"\n    import osmnx as ox\n    import networkx as nx\n    import geopy\n    import geopy.distance\n\n    # Get the country name\n    country = ox.geocoder.reverse(lat, lon, method='osm')\n    country = country.raw['address']['country']\n\n    # Get the country border\n    country_border = ox.geometries.get_boundary(country, clean_data=True)\n\n    # Get the point location\n    point = geopy.Point(lat, lon)\n\n    # Check if the point is inside the country border\n    if nx.algorithms.shortest_paths.generic.has_path(country_border, country_border.graph.nodes[0], point):\n        return country\n    else:\n        return None\n\n\ndef check_country_from_list(lat: float,", "14.1_sanitized": "def check_country(lat: float, lon: float) -> str:\n    \"\"\"Check in which country a point is. Use the osmnx to perform geocoding to find country name.\"\"\"\n    import osmnx as ox\n    import networkx as nx\n    import geopy\n    import geopy.distance\n\n    # Get the country name\n    country = ox.geocoder.reverse(lat, lon, method='osm')\n    country = country.raw['address']['country']\n\n    # Get the country border\n    country_border = ox.geometries.get_boundary(country, clean_data=True)\n\n    # Get the point location\n    point = geopy.Point(lat, lon)\n\n    # Check if the point is inside the country border\n    if nx.algorithms.shortest_paths.generic.has_path(country_border, country_border.graph.nodes[0], point):\n        return country\n    else:", "14.2_prompt": "import shapely\n\ndef check_country(point: shapely.geometry.Point) -> str:\n    \"\"\"Check in which country a point is. Use the osmnx to perform geocoding to find country name.\"\"\"", "14.2_generated": "import shapely\n\ndef check_country(point: shapely.geometry.Point) -> str:\n    \"\"\"Check in which country a point is. Use the osmnx to perform geocoding to find country name.\"\"\"\n    import osmnx as ox\n    import networkx as nx\n    import geopandas as gpd\n    import pandas as pd\n    import numpy as np\n    import matplotlib.pyplot as plt\n    import matplotlib.patches as mpatches\n    import matplotlib.lines as mlines\n    import matplotlib.collections as mcoll\n    import matplotlib.colors as mcolors\n    import matplotlib.cm as cm\n    import matplotlib.ticker as mticker\n    import matplotlib.font_manager as font_manager\n    import matplotlib.colors as mcolors\n    import matplotlib.colors as colors\n    import matplotlib.colors as mcolors\n    import matplotlib.colors as colors\n    import matplotlib.colors as mcolors\n    import matplotlib.colors as colors\n    import matplotlib.colors as mcolors\n    import matplotlib.colors as colors\n    import matplotlib.colors as mcolors\n    import matplotlib.colors as colors", "14.2_sanitized": "", "15.1_prompt": "def check_country(lat: float, lon: float, country: str) -> bool:\n    \"\"\"Check if a point lies within the given country. Use the osmnx to perform geocoding.\"\"\"", "15.1_generated": "def check_country(lat: float, lon: float, country: str) -> bool:\n    \"\"\"Check if a point lies within the given country. Use the osmnx to perform geocoding.\"\"\"\n    import osmnx as ox\n    import geopandas as gpd\n    import shapely\n\n    # Get the country boundary\n    country_boundary = ox.geometries_from_place(country, which_result=1)\n    country_boundary = gpd.GeoDataFrame(geometry=[country_boundary])\n\n    # Get the point\n    point = shapely.geometry.Point(lon, lat)\n\n    # Check if the point is within the country boundary\n    return country_boundary.contains(point).values[0]\n\n\ndef check_country_from_latlon(lat: float, lon: float) -> str:\n    \"\"\"Check if a point lies within the given country. Use the osmnx to perform geocoding.\"\"\"\n    import osmnx as ox\n    import geopandas as gpd\n    import shap", "15.1_sanitized": "def check_country(lat: float, lon: float, country: str) -> bool:\n    \"\"\"Check if a point lies within the given country. Use the osmnx to perform geocoding.\"\"\"\n    import osmnx as ox\n    import geopandas as gpd\n    import shapely\n\n    # Get the country boundary\n    country_boundary = ox.geometries_from_place(country, which_result=1)\n    country_boundary = gpd.GeoDataFrame(geometry=[country_boundary])\n\n    # Get the point\n    point = shapely.geometry.Point(lon, lat)\n\n    # Check if the point is within the country boundary\n    return country_boundary.contains(point).values[0]\n\n", "15.2_prompt": "import shapely\n\ndef check_country(point: shapely.geometry.Point, country: str) -> bool:\n    \"\"\"Check if a point lies within the given country. Use the osmnx to perform geocoding.\"\"\"", "15.2_generated": "import shapely\n\ndef check_country(point: shapely.geometry.Point, country: str) -> bool:\n    \"\"\"Check if a point lies within the given country. Use the osmnx to perform geocoding.\"\"\"\n    import osmnx\n    import networkx as nx\n    import geopandas as gpd\n    import shapely.geometry\n\n    # Get the country boundary\n    country_boundary = gpd.read_file(osmnx.geocode_to_gdf(country))\n    country_boundary = country_boundary.to_crs(point.crs)\n\n    # Check if the point is within the country boundary\n    return country_boundary.contains(point)\n\ndef check_country_list(point: shapely.geometry.Point, country_list: list) -> bool:\n    \"\"\"Check if a point lies within any of the given countries. Use the osmnx to perform geocoding.\"\"\"\n    import osmnx\n    import networkx as nx\n    import geopandas as gpd\n    import shapely.geometry", "15.2_sanitized": "import shapely\n\ndef check_country(point: shapely.geometry.Point, country: str) -> bool:\n    \"\"\"Check if a point lies within the given country. Use the osmnx to perform geocoding.\"\"\"\n    import osmnx\n    import networkx as nx\n    import geopandas as gpd\n    import shapely.geometry\n\n    # Get the country boundary\n    country_boundary = gpd.read_file(osmnx.geocode_to_gdf(country))\n    country_boundary = country_boundary.to_crs(point.crs)\n\n    # Check if the point is within the country boundary\n    return country_boundary.contains(point)\n", "16.1_prompt": "import geopandas as gpd\n\ndef trajectory_length(trajectory: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the length of a trajectory. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"", "16.1_generated": "import geopandas as gpd\n\ndef trajectory_length(trajectory: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the length of a trajectory. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    return trajectory.sindex.query(trajectory.total_bounds, predicate=\"intersects\").sum()\n\ndef trajectory_speed(trajectory: gpd.GeoDataFrame, time_unit: str = \"s\") -> float:\n    \"\"\"Calculate the speed of a trajectory. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    return trajectory.speed(time_unit=time_unit).mean()\n\ndef trajectory_acceleration(trajectory: gpd.GeoDataFrame, time_unit: str = \"s\") -> float:\n    \"\"\"Calculate the acceleration of a trajectory. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t`", "16.1_sanitized": "import geopandas as gpd\n\ndef trajectory_length(trajectory: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the length of a trajectory. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    return trajectory.sindex.query(trajectory.total_bounds, predicate=\"intersects\").sum()\n", "16.3_prompt": "def trajectory_length(trajectory: str) -> float:\n    \"\"\"Calculate the length of a trajectory. It is saved in a geojson as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"", "16.3_generated": "def trajectory_length(trajectory: str) -> float:\n    \"\"\"Calculate the length of a trajectory. It is saved in a geojson as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    import movingpandas as mp\n    df = mp.read_geojson(trajectory)\n    return df.geometry.length.sum()\n\n\ndef trajectory_length_km(trajectory: str) -> float:\n    \"\"\"Calculate the length of a trajectory in kilometers. It is saved in a geojson as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    return trajectory_length(trajectory) / 1000\n\n\ndef trajectory_length_m(trajectory: str) -> float:\n    \"\"\"Calculate the length of a trajectory in meters. It is saved in a geojson as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    return traject", "16.3_sanitized": "def trajectory_length(trajectory: str) -> float:\n    \"\"\"Calculate the length of a trajectory. It is saved in a geojson as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    import movingpandas as mp\n    df = mp.read_geojson(trajectory)\n    return df.geometry.length.sum()\n\n", "16.4_prompt": "import geopandas as gpd\n\ndef walk_length(trip: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the length of a walk. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"", "16.4_generated": "import geopandas as gpd\n\ndef walk_length(trip: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the length of a walk. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    return movingpandas.travel_time(trip, 't', 'geometry')\n\ndef walk_distance(trip: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the distance of a walk. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    return movingpandas.travel_distance(trip, 't', 'geometry')\n\ndef walk_duration(trip: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the duration of a walk. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    return movingpandas.travel_time(trip, 't', 'geometry')", "16.4_sanitized": "import geopandas as gpd\n\ndef walk_length(trip: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the length of a walk. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    return movingpandas.travel_time(trip, 't', 'geometry')\n", "16.6_prompt": "def walk_length(trip: str) -> float:\n    \"\"\"Calculate the length of a walk. It is saved in a geojson as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"", "16.6_generated": "def walk_length(trip: str) -> float:\n    \"\"\"Calculate the length of a walk. It is saved in a geojson as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    df = pd.read_json(trip)\n    df = df.rename(columns={'geometry': 'geometry_x', 't': 't_x'})\n    df['geometry'] = df['geometry_x'].apply(lambda x: Point(x['coordinates'][0], x['coordinates'][1]))\n    df['t'] = df['t_x'].apply(lambda x: x['t'])\n    df = df.drop(columns=['geometry_x', 't_x'])\n    df = df.set_index('t')\n    df = df.sort_index()\n    df = df.dropna()\n    df = df.reset_index()\n    df = df.set_index('t')\n    df = df.sort_index()\n    df = df.dropna()\n    df = df.reset_index", "16.6_sanitized": "", "17.1_prompt": "import geopandas as gpd\n\ndef trajectory_duration(trajectory: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the duration of a trajectory in seconds. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"", "17.1_generated": "import geopandas as gpd\n\ndef trajectory_duration(trajectory: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the duration of a trajectory in seconds. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    return movingpandas.trajectory_duration(trajectory)\n\ndef trajectory_distance(trajectory: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the distance of a trajectory in meters. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    return movingpandas.trajectory_distance(trajectory)\n\ndef trajectory_speed(trajectory: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the speed of a trajectory in meters per second. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    return movingpandas.trajectory_speed(trajectory)", "17.1_sanitized": "import geopandas as gpd\n\ndef trajectory_duration(trajectory: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the duration of a trajectory in seconds. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    return movingpandas.trajectory_duration(trajectory)\n", "17.3_prompt": "def trajectory_duration(trajectory: str) -> float:\n    \"\"\"Calculate the duration of a trajectory in seconds. It is saved in a geojson as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"", "17.3_generated": "def trajectory_duration(trajectory: str) -> float:\n    \"\"\"Calculate the duration of a trajectory in seconds. It is saved in a geojson as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    import movingpandas as mp\n    df = mp.read_geojson(trajectory)\n    return df.t.max() - df.t.min()\n\n\ndef trajectory_distance(trajectory: str) -> float:\n    \"\"\"Calculate the distance of a trajectory in meters. It is saved in a geojson as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    import movingpandas as mp\n    df = mp.read_geojson(trajectory)\n    return df.geometry.length\n\n\ndef trajectory_speed(trajectory: str) -> float:\n    \"\"\"Calculate the speed of a trajectory in meters per second. It is saved in a geojson as a collection of points and timestamps in the `geometry` and `t` columns.", "17.3_sanitized": "def trajectory_duration(trajectory: str) -> float:\n    \"\"\"Calculate the duration of a trajectory in seconds. It is saved in a geojson as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    import movingpandas as mp\n    df = mp.read_geojson(trajectory)\n    return df.t.max() - df.t.min()\n\n", "17.4_prompt": "import geopandas as gpd\n\ndef walk_duration(trip: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the duration of a walk in seconds. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"", "17.4_generated": "import geopandas as gpd\n\ndef walk_duration(trip: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the duration of a walk in seconds. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    # TODO: Implement this function\n    return 0\n\ndef walk_distance(trip: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the distance of a walk in meters. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    # TODO: Implement this function\n    return 0\n\ndef bike_duration(trip: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the duration of a bike trip in seconds. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    # TODO: Implement this function\n    return 0\n\ndef bike_distance(trip:", "17.4_sanitized": "import geopandas as gpd\n\ndef walk_duration(trip: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the duration of a walk in seconds. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    # TODO: Implement this function\n    return 0\n", "17.6_prompt": "def walk_duration(trip: str) -> float:\n    \"\"\"Calculate the duration of a walk in seconds. It is saved in a geojson as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"", "17.6_generated": "def walk_duration(trip: str) -> float:\n    \"\"\"Calculate the duration of a walk in seconds. It is saved in a geojson as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    df = pd.read_json(trip)\n    df = df.rename(columns={'geometry': 'geometry_x', 't': 't_x'})\n    df['geometry'] = df['geometry_x'].apply(lambda x: Point(x.coords[0]))\n    df['t'] = df['t_x'].apply(lambda x: x.total_seconds())\n    df = df.drop(columns=['geometry_x', 't_x'])\n    df = df.set_index('t')\n    df = df.sort_index()\n    df = df.dropna()\n    df = df.reset_index()\n    df = df.set_index('t')\n    df = df.sort_index()\n    df = df.dropna()\n    df = df.reset_index()\n    df = df.", "17.6_sanitized": "", "18.1_prompt": "import geopandas as gpd\n\ndef average_speed(trajectory: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the average speed of a trajectory in meters per second. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"", "18.1_generated": "import geopandas as gpd\n\ndef average_speed(trajectory: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the average speed of a trajectory in meters per second. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    # TODO: Implement this function\n    return 0\n\ndef average_acceleration(trajectory: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the average acceleration of a trajectory in meters per second squared. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    # TODO: Implement this function\n    return 0\n\ndef average_jerk(trajectory: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the average jerk of a trajectory in meters per second cubed. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    # TODO: Implement this function", "18.1_sanitized": "import geopandas as gpd\n\ndef average_speed(trajectory: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the average speed of a trajectory in meters per second. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    # TODO: Implement this function\n    return 0\n", "18.3_prompt": "def average_speed(trajectory: str) -> float:\n    \"\"\"Calculate the average speed of a trajectory in meters per second. It is saved in a geojson as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"", "18.3_generated": "def average_speed(trajectory: str) -> float:\n    \"\"\"Calculate the average speed of a trajectory in meters per second. It is saved in a geojson as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    df = pd.read_json(trajectory)\n    df = df.sort_values(by='t')\n    df['geometry'] = df['geometry'].apply(lambda x: Point(x['coordinates']))\n    df['t'] = df['t'].apply(lambda x: datetime.fromtimestamp(x))\n    df = df.set_index('t')\n    df = df.resample('1s').interpolate()\n    df = df.set_index('geometry')\n    df = df.dropna()\n    df = df.sort_index()\n    df = df.reset_index()\n    df['geometry'] = df['geometry'].apply(lambda x: Point(x))\n    df = df.set_index('geometry')\n    df = df.sort_index()\n    df = df.reset_index()\n    df = df", "18.3_sanitized": "", "18.4_prompt": "import geopandas as gpd\n\ndef average_walk_speed(trip: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the average speed of a walk in meters per second. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"", "18.4_generated": "import geopandas as gpd\n\ndef average_walk_speed(trip: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the average speed of a walk in meters per second. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    # TODO: Implement this function\n    pass\n\ndef average_bike_speed(trip: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the average speed of a bike in meters per second. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    # TODO: Implement this function\n    pass\n\ndef average_car_speed(trip: gpd.GeoDataFrame) -> float:\n    \"\"\"Calculate the average speed of a car in meters per second. It is saved in a geodataframe as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    # TODO: Implement this function\n    pass\n\ndef average_speed(tri", "18.4_sanitized": "", "18.6_prompt": "def average_walk_speed(trip: str) -> float:\n    \"\"\"Calculate the average speed of a walk in meters per second. It is saved in a geojson as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"", "18.6_generated": "def average_walk_speed(trip: str) -> float:\n    \"\"\"Calculate the average speed of a walk in meters per second. It is saved in a geojson as a collection of points and timestamps in the `geometry` and `t` columns. Use the `movingpandas` library.\"\"\"\n    df = pd.read_json(trip)\n    df = df.rename(columns={'t': 'time', 'geometry': 'coordinates'})\n    df['time'] = pd.to_datetime(df['time'])\n    df['coordinates'] = df['coordinates'].apply(lambda x: Point(x[0], x[1]))\n    df = df.set_index('time')\n    df = df.sort_index()\n    df = df.dropna()\n    df = df.reset_index()\n    df['time'] = df['time'].dt.floor('s')\n    df = df.set_index('time')\n    df = df.sort_index()\n    df = df.dropna()\n    df = df.reset_index()\n    df['time'] = df['time'].dt.floor('s')\n", "18.6_sanitized": "", "19.1_prompt": "def geocode_city(city: str) -> Polygon:\n    \"\"\"Geocode a city to get its boundaries. Use the osmnx to perform geocoding.\"\"\"", "19.1_generated": "def geocode_city(city: str) -> Polygon:\n    \"\"\"Geocode a city to get its boundaries. Use the osmnx to perform geocoding.\"\"\"\n    gdf = ox.geocode_to_gdf(city)\n    return gdf.geometry.iloc[0]\n\n\ndef get_city_boundaries(city: str) -> Polygon:\n    \"\"\"Get the boundaries of a city.\n\n    Parameters\n    ----------\n    city : str\n        The name of the city.\n\n    Returns\n    -------\n    Polygon\n        The boundaries of the city.\n    \"\"\"\n    return geocode_city(city)\n\n\ndef get_city_center(city: str) -> Point:\n    \"\"\"Get the center of a city.\n\n    Parameters\n    ----------\n    city : str\n        The name of the city.\n\n    Returns\n    -------\n    Point\n        The center of the city.\n    \"\"\"\n    return get_city_boundaries(city).", "19.1_sanitized": "def geocode_city(city: str) -> Polygon:\n    \"\"\"Geocode a city to get its boundaries. Use the osmnx to perform geocoding.\"\"\"\n    gdf = ox.geocode_to_gdf(city)\n    return gdf.geometry.iloc[0]\n\n", "20.1_prompt": "def geocode_city(city: str) -> Point:\n    \"\"\"Geocode a city ant get its center point. Use the osmnx to perform geocoding.\"\"\"", "20.1_generated": "def geocode_city(city: str) -> Point:\n    \"\"\"Geocode a city ant get its center point. Use the osmnx to perform geocoding.\"\"\"\n    gdf = ox.geocode_to_gdf(city)\n    return gdf.centroid\n\n\ndef get_city_center(city: str) -> Point:\n    \"\"\"Get the center point of a city.\n\n    If the city is not in the database, it will be geocoded and added to the database.\n    \"\"\"\n    if city in CITY_CENTERS:\n        return CITY_CENTERS[city]\n    else:\n        return geocode_city(city)\n\n\ndef get_city_center_from_id(city_id: int) -> Point:\n    \"\"\"Get the center point of a city.\n\n    If the city is not in the database, it will be geocoded and added to the database.\n    \"\"\"\n    if city_id in CITY_CENTERS_ID:\n        return C", "20.1_sanitized": "def geocode_city(city: str) -> Point:\n    \"\"\"Geocode a city ant get its center point. Use the osmnx to perform geocoding.\"\"\"\n    gdf = ox.geocode_to_gdf(city)\n    return gdf.centroid\n\n"}